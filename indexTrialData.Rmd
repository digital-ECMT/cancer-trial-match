---
title: "Index clinicaltrials.gov data"
author: "digital ECMT"
date: "19/11/2021"
output: html_document
---

```{r copyright notice}
 # 
 # This file is part of the cancer-trial-match distribution (https://github.com/digital-ECMT/cancer-trial-match).
 # Copyright (C) 2021 digital ECMT
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3 or later.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #


## Copyright and Reproduction of UK Ordnance Survey data
## As per : https://www.ons.gov.uk/methodology/geography/licences

## You may re-use this information (not including logos or Northern Ireland data) free of charge in any format or medium, under the terms of the relevant data owners' licence. In addition, the following attribution statements must be acknowledged or displayed whenever the owners data is used:

## Contains Ordnance Survey data © Crown copyright and database right 2021

## Contains Royal Mail data © Royal Mail copyright and database right 2021

## Source: Office for National Statistics licensed under the Open Government Licence v.3.0
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
##NOTE: the following packages are required to run this script, but should be installed (e.g. using code snippets below) before runnning the script, NOT as part of the script itself
# options(repos = "http://cran.us.r-project.org")
# install.packages("BiocManager")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("KEGGREST")
# BiocManager::install("KEGGlincs")
# BiocManager::install("hgu133a.db")
require(KEGGlincs)        ## GPL-3
require(KEGGgraph)        ## GPL >= 2
require(org.Hs.eg.db)     ## Artistic-2.0
require(KEGGREST)         ## Artistic 2.0
require(DBI)              ## LGPL-2.1 | LGPL-3 
require(RODBC)            ## GPL-2 | GPL-3
require(RPostgres)        ## GPL-3
require(RSQLite)          ## LGPL-2.1 | LGPL-3
require(jsonlite)         ## MIT
require(plyr)             ## MIT + LICENCE file
require(dplyr)            ## MIT
require(tidyr)            ## MIT
require(formattable)      ## MIT
require(kableExtra)       ## MIT
require(stringr)          ## MIT
require(splitstackshape)  ## GPL-3
require(reshape2)         ## MIT
require(tictoc)           ## Apache License (== 2.0)
require(leaflet)          ## GPL-3
require(PostcodesioR)     ## GPL-3
require(igraph)           ## GPL-2 | GPL-3
require(tidygeocoder)     ## MIT
require(caret)            ## GPL (>= 2)
require(rpart)            ## GPL-2 | GPL-3
require(rpart.plot)       ## GPL-3
## require(textstem)         ## GPL-2
require(quanteda)         ## GPL-3
require(corpus)           ## 	Apache License (== 2.0) 
require(tidytext)         ## MIT

## clean up first
rm(list=ls())

##get today's date
today <- format(Sys.Date(), format = "%d %B %Y")

## load configuration data from JSON file
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password
```

```{r download CHEMBL as SQLite database}

## note this: You will need around 35GB of free space available to import the ChEMBL dump files. (https://chembl.gitbook.io/chembl-interface-documentation/frequently-asked-questions/chembl-download-questions)

## see here for schema: https://ftp.ebi.ac.uk/pub/databases/chembl/ChEMBLdb/latest/chembl_32_schema.png
## and here for schema documentation: https://ftp.ebi.ac.uk/pub/databases/chembl/ChEMBLdb/latest/schema_documentation.txt 
## specify which release of chembl to be downloaded
chembl_download_url <- "https://ftp.ebi.ac.uk/pub/databases/chembl/ChEMBLdb/releases/chembl_32/chembl_32_sqlite.tar.gz"
chembl_db_filename <- "chembl_32/chembl_32_sqlite/chembl_32.db"
destfile <- "chembl_32_sqlite.tar.gz"

## allow longer download time before timeout
options(timeout=1000)

if(!file.exists(chembl_db_filename)) {
  tic("download CHEMBL DB...")
  download.file(url=chembl_download_url,destfile = destfile)
  toc()
  untar(destfile,list=TRUE)  ## list files without extracting
  untar(destfile)           ## extract files
}

chemblDB_con <- dbConnect(RSQLite::SQLite(), chembl_db_filename)
# dbListTables(chemblDB_con)

```

**Date of data refresh: `r today`**  
 
```{r connect to SQLite DB} 
# Create an RSQLite database
sqlite_con <- dbConnect(RSQLite::SQLite(), "indexedTrialData.sqlite")

```
  
### **Download and save a table of human genes and synonyms**  
  
```{r REFACTORED download and process a list of all human genes and their synonyms, warning=FALSE, message=FALSE}  

## define common false hits among gene aliases
common_false_hits_gene_aliases <- c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", "NA", "B12", "EL", "G6PD", "CAT", "CT", "MRI", "OTC", "polymerase", "G1", "PI", "COPD", "A1", "ARM", "ALS", "AA", "B5", "C1", "C2", "C3", "C5", "C6", "D3", "D4", "A-2", "A3", "1D", "1A", "L1")

## download a list of gene symbols and synonyms
humanGenes <- AnnotationDbi::select(org.Hs.eg.db, columns=c("ENTREZID", "SYMBOL", "ALIAS"), keys(org.Hs.eg.db, keytype="SYMBOL"), keytype = "SYMBOL") %>%
  as.data.frame() %>% 
  dplyr::select( "GeneID" = "ENTREZID", "Symbol"="SYMBOL", "Aliases" = "ALIAS") %>%
  dplyr::filter(nchar(Aliases)>1) %>%                    ## drop any rows where Aliases value is only a single character
  dplyr::filter(is.na(as.numeric(Aliases))) %>%          ## drop any rows where Aliases is a number
  dplyr::filter(!Aliases %in% common_false_hits_gene_aliases) %>%           ## drop any rows where Aliases is a common false hit (e.g. Roman numerals)
  unique()

## check if there are any Symbol values that don't appear in Aliases column  
# setdiff(x=humanGenes$Symbol, y=humanGenes$Aliases)  
```

### **Download and save NCI thesaurus**  
  
```{r REFACTORED download NCI thesaurus, message=FALSE}

## latest version should always be at this url...
NCItURL <- "https://evs.nci.nih.gov/ftp1/NCI_Thesaurus/Thesaurus.FLAT.zip"

destFlatFilename <- "NCIt_FLAT.zip"

# download.file(url=NCItURL,destfile = destFlatFilename)
# unzip(zipfile = paste0(getwd(),"/",destFlatFilename))

## try to download, if not available, fall back to last downloaded version
tryCatch(
  expr = {
    download.file(url=NCItURL,destfile = destFlatFilename)
    unzip(zipfile = paste0(getwd(),"/",destFlatFilename))
  }, error = function(e) {
    print("NCIt download failed")
  }
)

## if download fails, fall back to using last downloaded version
NCIt <- read.table("Thesaurus.txt",header = FALSE, sep = "\t", comment.char = "", fill = TRUE, stringsAsFactors = FALSE, quote = "")

names(NCIt) <- c("code", "concept_IRI", "parents", "synonyms", "definition", "display_name", "concept_status", "semantic_type", "concept_in_subset")

## clean up, remove files
file.remove("NCIt_FLAT.zip")
file.remove("Thesaurus.txt")
```

```{r REFACTORED normalise NCI thesaurus}
## normalise columns with concatenated values
NCIt <- NCIt %>%
  dplyr::mutate(semantic_type = str_split(semantic_type, pattern = "\\|")) %>%    ## an entity may have more than one semantic_type - split and unnest...
  unnest(semantic_type) %>%
  dplyr::mutate(parents = str_split(parents, pattern = "\\|")) %>%     ## idem parents...
  unnest(parents) %>%
  dplyr::mutate(synonyms = str_split(synonyms, pattern = "\\|")) %>%     ## idem synonyms...
  unnest(synonyms) %>%
  dplyr::mutate(concept_status = str_split(concept_status, pattern = "\\|")) %>%     ## idem concept_status...
  unnest(concept_status) %>%
  as.data.frame() %>%
  dplyr::select(code, parents, synonyms, display_name, semantic_type, concept_status) %>%
  dplyr::mutate(downloaded = Sys.Date()) %>%
  unique()

```

```{r REFACTORED join parent synonyms}
## parent synonym will be used for mechanism search in UI (e.g. MTOR inhibitor is a parent of Everolimus)

## create a temporary table that will hold a synonym for each parent
NCItParents <- NCIt %>%
  dplyr::filter(code %in% parents)  %>%     ## keep ony entities that have at least one child term
  dplyr::select("ParentID"="code", "Parent_synonym"="synonyms") %>%
  unique() %>%
  dplyr::group_by(ParentID) %>% 
  dplyr::slice_head(n=1) %>%                ## just keep first synonym for each parent term
  as.data.frame()


## join to NCIt
NCIt <- merge(x=NCIt,y=NCItParents,by.x="parents",by.y="ParentID",all.x=TRUE)

## delete temp table
rm(NCItParents)

## see example for Everolimus... 
# dplyr::filter(NCIt, synonyms == "Everolimus")

```

```{r REFACTORED exclude uninformative entities from NCIt}

NCIt <- NCIt %>%
  dplyr::filter(!(concept_status %in% c("Retired_Concept", "Obsolete_Concept", "Provisional_Concept", "Header_Concept", "Concept_Pending_Approval"))) %>% 
  dplyr::filter(grepl(pattern = "[a-zA-Z]", x = synonyms))                 ## delete any rows that don't contain any letters... (e.g. "0" for ECOG PS 0)

## delete any synonyms that map to >1 entities within a semantic_type   
# create a temp table with synonyms that map to multiple entities
NCIt_multiple_terms <- NCIt %>%
  dplyr::group_by(synonyms, semantic_type) %>%
  dplyr::summarise(
    number_terms = length(unique(code))
  ) %>%
  dplyr::filter(number_terms >1) %>%
  as.data.frame()
## anti join
NCIt <- dplyr::anti_join(NCIt, NCIt_multiple_terms, by=c("synonyms", "semantic_type"))
rm(NCIt_multiple_terms)

```

* A subset of the preprocessed NCI thesaurus (semantic_type==*Pharmacologic Substance* is saved in memory in the NCIt_Pharmacologics table (not saved to DB).  

```{r subset NCIt for Pharmacologic Substance}

NCIt_Pharmacologics <- unique(dplyr::filter(NCIt, semantic_type %in% c("Immunologic Factor", "Pharmacologic Substance")))

```
  
### **Map NCIt drugs to their targets via CHEMBL**  
  
```{r read data from tables}
# COMPONENT_SYNONYMS <- dbGetQuery(con, "SELECT * FROM COMPONENT_SYNONYMS")         ## Table storing synonyms for the components of molecular targets
# dim(COMPONENT_SYNONYMS)       ## 104,000 rows
# 
# DRUG_INDICATION <- dbGetQuery(chemblDB_con, "SELECT * FROM DRUG_INDICATION")           ## Table storing indications for drugs, and clinical candidate drugs, from a variety of sources (e.g., ATC, DailyMed, ClinicalTrials.gov)

DRUG_MECHANISM <- dbGetQuery(chemblDB_con, "SELECT * FROM drug_mechanism")           ## Table storing mechanism of action information for drugs, and clinical candidate drugs, from a variety of sources (e.g., ATC, FDA, ClinicalTrials.gov)

DRUG_WARNING <- dbGetQuery(chemblDB_con, "SELECT * FROM drug_warning")           ## Table storing safety-related information for drugs and clinical candidates

MOLECULE_DICTIONARY <- dbGetQuery(chemblDB_con, "SELECT * FROM molecule_dictionary")           ## Table storing a non-redundant list of curated compounds for ChEMBL (includes preclinical compounds, drugs and clinical candidate drugs) and some associated attributes

MOLECULE_SYNONYMS <- dbGetQuery(chemblDB_con, "SELECT * FROM molecule_synonyms")           ## Stores synonyms for a compound (e.g., common names, trade names, research codes etc)

TARGET_DICTIONARY <- dbGetQuery(chemblDB_con, "SELECT * FROM target_dictionary")           ## Target Dictionary containing all curated targets for ChEMBL. Includes both protein targets and non-protein targets (e.g., organisms, tissues, cell lines)

ACTION_TYPE <- dbGetQuery(chemblDB_con, "SELECT * FROM action_type")           ## Table storing the distinct list of action types used in the drug_mechanism table, together with a higher-level parent action type.

COMPONENT_SEQUENCES <- dbGetQuery(chemblDB_con, "SELECT * FROM component_sequences")           ## Table storing the sequences for components of molecular targets (e.g., protein sequences), along with other details taken from sequence databases (e.g., names, accessions). Single protein targets will have a single protein component in this table, whereas protein complexes/protein families will have multiple protein components

TARGET_COMPONENTS  <- dbGetQuery(chemblDB_con, "SELECT * FROM target_components")           ## Links molecular target from the target_dictionary to the components they consist of (in the component_sequences table). For a protein complex or protein family target, for example, there will be multiple protein components in the component_sequences table
```
  
```{r map NCIt codes to CHEMBL IDs}
## NOTE: for a given NCIt entity, some synonyms can map to one CHEMBL ID, but not to others 
## this causes issues later, we end up with 2 rows for the same NCIt_code

NCIt_Pharmacologics <- NCIt_Pharmacologics %>%
  dplyr::mutate(synonyms_lower = tolower(synonyms))

MOLECULE_SYNONYMS <- MOLECULE_SYNONYMS %>%
  dplyr::mutate(synonyms_lower = tolower(synonyms))


## get mapppings between NCIt codes and ChEMBL molregno (Internal Primary Key for the molecule)
NCIt_to_CHEMBL <- NCIt_Pharmacologics %>%
  dplyr::select(code, synonyms_lower) %>%
  unique() %>%
  merge(by.x = "synonyms_lower", all.x = FALSE, y=dplyr::select(MOLECULE_SYNONYMS, molregno, synonyms_lower)) %>%
  dplyr::select(-synonyms_lower) %>%
  unique()
  
## join to CHEMBL_ID (ChEMBL identifier for this compound (for use on web interface etc))
## also: 
# MAX_PHASE: Maximum phase of development reached for the compound across all indications (4 = Approved, 3 = Phase 3 Clinical Trials, 2 = Phase 2 Clinical Trials, 1 = Phase 1 Clinical Trials, 0.5 = Early Phase 1 Clinical Trials, -1 = Clinical Phase unknown for drug or clinical candidate drug ie where ChEMBL cannot assign a clinical phase, NULL = preclinical compounds with bioactivity data)
# BLACK_BOX_WARNING: 	Indicates that the drug has a black box warning (1 = yes, 0 = default value)
NCIt_to_CHEMBL <- NCIt_to_CHEMBL %>% 
  merge(by.x = "molregno", all.x = TRUE, y=dplyr::select(MOLECULE_DICTIONARY, molregno, chembl_id, max_phase, black_box_warning), by.y = "molregno") %>%
  dplyr::mutate(black_box_warning = as.logical(black_box_warning))

```
  
```{r join drugs to their mechanisms}
# MECHANISM_OF_ACTION: Description of the mechanism of action e.g., 'Phosphodiesterase 5 inhibitor'
# ACTION_TYPE:  Type of action of the drug on the target e.g., agonist/antagonist etc (foreign key to action_type table)
# DISEASE_EFFICACY: Flag to show whether the target assigned is believed to play a role in the efficacy of the drug in the indication(s) for which it is approved (1 = yes, 0 = no)
# SELECTIVITY_COMMENT: Additional comments regarding the selectivity of the drug
# TID: Target associated with this mechanism of action (foreign key to target_dictionary table)
NCIt_to_CHEMBL <- NCIt_to_CHEMBL %>%
  merge(by.x = "molregno", all.x = TRUE, y=dplyr::select(DRUG_MECHANISM, molregno, mechanism_of_action, action_type, disease_efficacy, selectivity_comment, tid), by.y = "molregno") %>%
  unique() %>%
  dplyr::mutate(disease_efficacy = as.logical(disease_efficacy))
  

# PARENT_TYPE: Higher-level grouping of action types e.g., positive vs negative action
NCIt_to_CHEMBL <- NCIt_to_CHEMBL %>%
  merge(by.x = "action_type", all.x = TRUE, y=dplyr::select(ACTION_TYPE, action_type, "parent_action_type"="parent_type"), by.y = "action_type") %>%
  unique()

```
  
```{r join drugs to their targets}
## join drugs to targets (UniProt accession numbers)
NCIt_to_CHEMBL <- NCIt_to_CHEMBL %>%
  merge(by.x = "tid", all.x = TRUE, y=dplyr::select(TARGET_DICTIONARY, tid, "target_chembl_id"="chembl_id"), by.y = "tid") %>%
  merge(by.x = "tid", all.x = TRUE, y=dplyr::select(TARGET_COMPONENTS, tid, component_id), by.y = "tid") %>%
  merge(by.x = "component_id", all.x = TRUE, y=dplyr::select(COMPONENT_SEQUENCES, component_id, organism, accession), by.y = "component_id") %>%
  dplyr::filter(organism == "Homo sapiens") %>%             ## drop rows related to non-human targets
  unique()
```

```{r map from target UniProt IDs to Entrez Symbols}

## create a temp table with mappings between UniProt accession numbers to Entrez Symbols
uniprot_entrez_cols <- c("SYMBOL", "UNIPROT" )
uniprot_ids <- AnnotationDbi::select(org.Hs.eg.db, keys=NCIt_to_CHEMBL$accession, columns=uniprot_entrez_cols, keytype="UNIPROT") %>%
  as.data.frame()

## merge with mechanisms table
NCIt_to_CHEMBL <- NCIt_to_CHEMBL %>%
  merge(by.x = "accession", all.x=TRUE, y=uniprot_ids, by.y = "UNIPROT") %>%
  dplyr::rename("TARGET_SYMBOL"= "SYMBOL") %>%
  unique()

## delete temp table
rm(uniprot_ids)
```
  
```{r select desired columns from NCIt_to_CHEMBL}
drugs_targets <- NCIt_to_CHEMBL %>%
  dplyr::select(code, TARGET_SYMBOL, action_type) %>%
  dplyr::rename("NCIt_code"="code") %>%
  unique()
  
```

### **Map NCIt drugs to their targets via IUPHAR**  
  
* Although CHEMBL is comprehensive, it does not include MTOR as a target for Everolimus (only FKBP1A)  
* There are likely to be other examples  
* Therefore, supplement drug->target edges from CHEMBL with data from other sources - this case, IUPHAR  
  * See descriptions for downloads here: https://www.guidetopharmacology.org/DATA/file_descriptions.txt  
  
```{r download tables from IUPHAR }
iuphar_interactions <- read.csv("https://www.guidetopharmacology.org/DATA/interactions.csv", 
                                skip = 1:1, stringsAsFactors = FALSE)      ## first row is date refreshed, not a header

iuphar_ligand_id_mappings <- read.csv("https://www.guidetopharmacology.org/DATA/ligand_id_mapping.csv", 
                                      skip = 1:1, stringsAsFactors = FALSE)      ## first row is date refreshed, not a header

```
 
```{r process iuphar interactions}

iuphar_processed <- iuphar_interactions %>%
  dplyr::select( Ligand, Ligand.ID, Target.UniProt.ID, Type, Selectivity, Primary.Target) %>%
  dplyr::rename("drug_name"="Ligand") %>%
  dplyr::rename("action_type"="Type") %>%
  merge(by.x = "Ligand.ID", y = dplyr::select(iuphar_ligand_id_mappings, ChEMBl.ID, Ligand.id), by.y = "Ligand.id") %>%        ## join to molecule ChEMBL IDs
  dplyr::select(ChEMBl.ID, Target.UniProt.ID, action_type) %>%
  dplyr::rename("drug_chembl_id"="ChEMBl.ID") %>%
  dplyr::rename("target_uniprot_id"="Target.UniProt.ID") %>%
  dplyr::filter(drug_chembl_id != "") %>%                        ## drop rows where there is no chembl id
  dplyr::filter(target_uniprot_id != "") %>%                     ## drop rows where there is no target uniprot id
  dplyr::mutate(target_uniprot_id = strsplit(target_uniprot_id, split = "\\|")) %>%        ## some entries have >1 uniprot id, pipe-delimited, split and unnest....
  tidyr::unnest(target_uniprot_id) %>% 
  as.data.frame() %>%  
  merge(by.x = "drug_chembl_id", y = dplyr::select(NCIt_to_CHEMBL,"NCIt_code"="code", chembl_id), by.y = "chembl_id") %>%           ## join to NCIt ID's on CHEMBL ID
  unique()

```

```{r map from IUPHAR target accession numbers to Entrez Symbols}

## map from UniProt accession numbers to Entrez Symbols
iuphar_uniprot_ids <- AnnotationDbi::select(org.Hs.eg.db, keys=iuphar_processed$target_uniprot_id, columns=uniprot_entrez_cols, keytype="UNIPROT") %>% 
  as.data.frame()

## join to iuphar_processed
iuphar_processed <- iuphar_processed %>% 
  merge( by.x = "target_uniprot_id", y=iuphar_uniprot_ids, by.y = "UNIPROT") %>%
  dplyr::rename("TARGET_SYMBOL"= "SYMBOL") %>%
  dplyr::select(names(drugs_targets) )     %>%         ## harmonise column names with drugs_targets table
  unique()


rm(iuphar_uniprot_ids)
```

```{r add IUPHAR drug target data to ChEMBL data}

## bind as new rows to drugs_targets table
drugs_targets <- unique(rbind(drugs_targets, iuphar_processed))

## check e.g. for Everolimus (C48387)
#dplyr::filter(drugs_targets, NCIt_code == "C48387")
```

```{r NOT NEEDED write drugs_targets to database}
## create as a table in database
#dbWriteTable(conn = con,name = "drugs_targets", value = drugs_targets, overwrite=TRUE)
```

### **Define controlled terms and synonyms for cancer types**  
  
```{r create table of cancer types}
## conditionSynonyms specifies which cancer types are of interest, and which condition names (as used by clinicaltrials.gov) will be considered as matches for each

## synonyms define on basis of those in clinicaltrials.gov
conditionSynonyms <- read.csv(file = "conditionSynonyms6.csv", stringsAsFactors = FALSE)
```

```{r add simple synonyms to improve recall of mapping to cancer types}

## study NCT02264678 has a single value listed for condition: "Adv Solid Malig - H&N SCC, ATM Pro / Def NSCLC, Gastric, Breast and Ovarian Cancer"
## currently, this is correctly mapped to NSCLC, Lung and Ovarian cancer
## however it should also be mapped to Head and neck squamous cell carcinoma (H&N SCC), Solid (Adv Solid Malig), Gastric (Gastric) and Breast (Breast)
## in order to deal with this, we will include just the words "Breast", "Gastric", "Solid" as synonyms 
## since we are already selecting for cancer studies in the SQL query on clinicaltrials.gov, just the mention of these words should be sufficient... 
## first, create a new table where the synonym is just the controlled cancer type 
simple_conditions <- data.frame(controlled_cancer_type = unique(conditionSynonyms$controlled_cancer_type), condition_synonyms = unique(conditionSynonyms$controlled_cancer_type))
## second, bind this to the conditionSynonyms table
conditionSynonyms <- unique(rbind(conditionSynonyms, simple_conditions))
### now proceed as before - study NCT02264678 should get correctly mapped to Solid, NSCLC, Lung, Gastric, Breast and Ovarian cancer types... 
```

```{r process condition synonyms}

## trim leading/trailing whitespace, if any
conditionSynonyms$condition_synonyms <- str_squish(string = conditionSynonyms$condition_synonyms)

## remove redundancy, if any
conditionSynonyms <- unique(conditionSynonyms)

## create as a table in database
dbWriteTable(conn = sqlite_con,name = "conditionSynonyms", value = conditionSynonyms, overwrite=TRUE)

## check it has saved
# dbListTables(sqlite_con)

```
  
* A set of mappings between cancer types of interest and condition names (as used by clinicaltrials.gov) must be provided via a file named *conditionSynonyms5.csv*, and these are saved in the *conditionSynonyms* table:  
  
`r formattable(head(conditionSynonyms))`  
    
### **Connect to clinicaltrials.gov**  
  
* A user name and password for an AACT account is required.  
* see https://aact.ctti-clinicaltrials.org/ for how to create an account  
  
```{r connect to clinicaltrialsgov, message=FALSE}  

## connect via RPostgres (GPL-3 licence)
drv = RPostgres::Postgres()
ctgov_con <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
```
 
### **Get study info for all interventional cancer studies**  
  
* We will download, index and store data (including results) for all interventional cancer studies (globally, ever)  
* For now, only data for studies with sites open in the specified country will be used by the trial finder  
  
```{r get data for open cancer studies in configured country}

## get data for all cancer studies that have reported results
cancerStudiesQ <- paste0("SELECT s.nct_id, s.brief_title, s.primary_completion_date, s.last_update_posted_date, s.phase, s.acronym, s.number_of_arms, s.number_of_groups,  s.overall_status,  c.name AS condition, f.city, f.status AS site_status, fc.email AS site_contacts, cc.email AS central_contacts
FROM studies s
INNER JOIN conditions c ON c.nct_id = s.nct_id
INNER JOIN calculated_values cv ON cv.nct_id = s.nct_id
INNER JOIN facilities f on s.nct_id = f.nct_id
LEFT JOIN facility_contacts fc ON f.id = fc.facility_id
LEFT JOIN central_contacts cc ON s.nct_id = cc.nct_id
WHERE s.study_type LIKE ('Interventional')
AND s.overall_status IN ('Recruiting', 'Not yet recruiting')
AND lower(f.country) = '", tolower(configuration$country), "'
AND f.status IN ('Recruiting', 'Not yet recruiting')
AND (c.downcase_name LIKE '%cancer%'
OR c.downcase_name LIKE '%neoplasm%'
OR c.downcase_name LIKE '%carcinoma%'
OR c.downcase_name LIKE '%tumo%'
OR c.downcase_name LIKE '%sarcoma%'
OR c.downcase_name LIKE '%melanoma%'
OR c.downcase_name LIKE '%mesothelioma%'
OR c.downcase_name LIKE '%chordoma%')")

## get data from clinicaltrials.gov
cancerStudies <- dbGetQuery(ctgov_con,cancerStudiesQ)

cancerStudies <- cancerStudies %>%
  dplyr::mutate(refresh_date = today) %>%                                                 ## add a column to indicate refresh date
  dplyr::mutate(Link = paste0("https://clinicaltrials.gov/ct2/show/", nct_id))            ## add a column to hold link

```
  
* As of `r today`, there are a total of **`r length(unique(cancerStudies$nct_id))` cancer studies** listed in clinicaltrials.gov and included in this analysis.  
  
`r formattable(head(cancerStudies))`  
    
#### **Map verbatim condition names to controlled set of cancer types**  
  
```{r create dictionary of cancer types}

## create a dictionary to use for finding matches among study condition.name values
cancer_type_dictionary <- conditionSynonyms %>%
  unstack(form = condition_synonyms ~ controlled_cancer_type)   %>%       ## convert to named list
  quanteda::dictionary()                                                  ## convert to dictionary

# ## for example
#cancer_type_dictionary[["Colorectal"]]

```
  
```{r lookup condition names using dictionary}

## match condition names for study to preferred terms in dictionary
# ensure no punctutation (e.g. commas) present in condition_name when tokenising
cancerStudies$condition_PT <- cancerStudies$condition %>%
  tokens( remove_punct = T) %>%
  tokens_lookup( dictionary = cancer_type_dictionary, nested_scope = "dictionary") %>%
  as.list()



## drop any rows that don't find a match... 
cancerStudies <- cancerStudies %>%
  unnest( cols = "condition_PT", keep_empty = TRUE) %>% 
  as.data.frame()

## keep detail of unmapped condition names... 
unmapped_condition_names <- unique(cancerStudies$condition[is.na(cancerStudies$condition_PT) ])

## now delete rows that haven't been mapped
cancerStudies <- cancerStudies %>%
  dplyr::filter(!is.na(condition_PT))

```

* **The following condition names have not mapped to controlled terms and are lost at this stage**:  
  
**`r unmapped_condition_names`**  
  
* After mapping to controlled terms for cancer types, **`r length(unique(cancerStudies$nct_id))` studies remain**  
  
`r formattable(head(cancerStudies))`  
  
### **Get latitude and longitude values for cities**  
  
```{r get lat and long values for cities}

cancerStudies <- cancerStudies %>%
    dplyr::mutate(city_country = paste0(city, ", ", configuration$country)) %>%
    geocode(city_country, method = 'osm', lat = latitude , long = longitude) %>%
    dplyr::select(-city_country) %>%
    as.data.frame()

```
    
### **Get other tables from clinicaltrials.gov**  
  
```{r format list of study IDs for SQL}
## format study IDs for SQL query
studyIDsForSQL <- paste0("\'",paste(unique(cancerStudies$nct_id), collapse = "\',\'"), "\'")
```
  
```{r get study interventions}
getInterventionsQ <- paste0("select i.nct_id, i.id AS intervention_id, i.name AS intervention_name 
from interventions i
where i.nct_id in (",
"", studyIDsForSQL,
")")

## get interventions from clinicaltrials.gov
interventions <- dbGetQuery(ctgov_con,getInterventionsQ)

```
  
```{r get design group interventions}

## get design group interventions
get_dgi <- paste0("select *
from design_group_interventions
where nct_id in (",
"", studyIDsForSQL,
")")

## get data from clinicaltrials.gov
dgi <- dbGetQuery(ctgov_con,get_dgi)

```

```{r get eligibility criteria from ct}
getEligibilities <- paste0("select * 
from eligibilities 
where nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
eligibilities <- dbGetQuery(ctgov_con,getEligibilities)
```

```{r get design groups from ct}
getDesignGroupsQ <- paste0("select dg.nct_id, dg.id as dg_id, dg.title as dg_title, dg.description as dg_description, dg.group_type as dg_group_type, dgi.intervention_id
from design_groups dg
left join design_group_interventions dgi on dg.id = dgi.design_group_id 
where dg.nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
design_groups <- dbGetQuery(ctgov_con,getDesignGroupsQ)

## NOTE, SOME STUDIES HAVE NO DESIGN GROUPS SPECIFIED, BUT MAY HAVE RESULT GROUPS SPECIFIED
```

### **Index study interventions**  

* Interventions are stored as follows in clinicaltrials.gov 
  * each intervention_id value is unique, i.e. same intervention in different studies is given different *intervention_id* values:
  
`r formattable(head(interventions))`  
  
* We will map study interventions (as listed in clinicaltrials.gov) to drug entities in the NCI thesaurus (provides preferred terms, mechanism and other info)...  
  
```{r create dictionary of drug names}
## define semantic types to be included
## include "Therapeutic or Preventive Procedure" to get chemotherapy regimens (e.g. FOLFOX)
semantic_types_drug <- c("Pharmacologic Substance", "Biologically Active Substance", "Clinical Drug", "Steroid", "Immunologic Factor")

drug_dictionary <- NCIt %>%
  dplyr::filter(semantic_type %in% semantic_types_drug) %>%
  dplyr::select(code, synonyms) %>%
  dplyr::filter(str_detect(string = synonyms, pattern = "\\(|\\)", negate = TRUE)) %>%           ## omit any rows where synonyms value contains parentheses, as these cause issues with lookup
  unique() %>%
  unstack(form = synonyms ~ code)   %>%                                   ## convert to named list
  quanteda::dictionary()                                                  ## convert to dictionary

## check for e.g. everolimus
#drug_dictionary[["C48387"]]

```
  
```{r lookup intervention names in drug dictionary}
## map intervention names to NCIt codes
interventions$NCIt_code <- interventions$intervention_name %>%
  tokens( remove_punct = T) %>%
  tokens_lookup( dictionary = drug_dictionary, nested_scope = "dictionary") %>%
  as.list()

interventions <- interventions %>%
  unnest( cols = "NCIt_code", keep_empty = TRUE) %>%           ## keep all rows including those that don't find a match... 
  as.data.frame() %>% 
  merge(by.x = "NCIt_code", all.x = TRUE, y = dplyr::select(NCIt, code, display_name), by.y = "code") %>%         ## get PT for intervention from NCIt
  dplyr::rename("intervention_pt" = "display_name") %>%
  merge(by.x="NCIt_code", all.x=TRUE, y=drugs_targets, by.y = "NCIt_code", incomparables = NA) %>%    ## get targets and mechanisms
  #dplyr::rename("Mechanism"="action_type") %>%
  dplyr::select(nct_id, intervention_id, intervention_name, NCIt_code, intervention_pt,TARGET_SYMBOL, action_type) %>%
  unique()

```

* We retain all interventions at this stage, including those that have not mapped to either NCI thesaurus or KEGG drug target...  

```{r join intervention parent terms from NCIt}
## to support searching on parent term (drug mechanism) in UI
interventions <- interventions %>%
    merge(by.x = "NCIt_code", y = dplyr::select(NCIt, code, Parent_synonym), by.y = "code") %>%
    unique() 


```
  
### **Index eligibility criteria**  
  
#### **Index inclusion criteria on gene alterations**  

```{r preprocess eligibility criteria}

eligibilities <- eligibilities %>%
    dplyr::mutate(criteria = str_split(string = criteria, pattern = "\n")) %>%      ## split into individual criteria on single line break
    unnest(cols = "criteria", keep_empty = FALSE) %>%
    as.data.frame() %>%
    dplyr::filter(criteria != "") %>%
    dplyr::group_by(nct_id) %>% 
    dplyr::mutate(criterion_index = paste0(nct_id, "_", row_number())) %>%         ## add an index column that uniquely identifies each criterion
    as.data.frame() %>%
    dplyr::select(nct_id, criterion_index, criteria ) %>%
    unique()
```

Eligibility criteria are classified as either *INCLUSION* or *EXCLUSION* based on the occurrence of the patterns *inclusion criteria:* and *exclusion criteria:*  
  
```{r classify as inclusion exclusion criteria}

## add a column to indicate criterion type
eligibilities$criterion_type <- NA

## set first value as "INCLUSION"
eligibilities$criterion_type[1] <- "INCLUSION"

## tag each criterion that contains "inclusion criteria:" (case-insensitive, with or without colon)
eligibilities$criterion_type[grep(pattern = "inclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "INCLUSION"

## tag each criterion that contains "exclusion criteria:" (case-insensitive, with or without colon)
eligibilities$criterion_type[grep(pattern = "exclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "EXCLUSION"

## fill "down" using the tdiyr::fill() function
eligibilities <- tidyr::fill(data=eligibilities, criterion_type, .direction="down")

```
  
* There are some common patterns observed in criteria that are complicate named entity recognition, for example:  
 * The string *BRCA1/2* is shorthand for *BRCA1 or BRCA2* and *RAD51C/D* is shorthand for *RAD51C or RAD51D*  
 * Likewise, the string *BRCA* is shorthand for *BRCA1 or BRCA2*  
* Expand these so that e.g. *BRCA1/2* is converted to *BRCA1 or BRCA2*  
  
```{r expand gene abbreviations in eligibility criteria text}
## create a copy of criterion text for processing
eligibilities$criteria_processed <- eligibilities$criteria %>%
  gsub(pattern = "\\bBRCAm\\b", replacement = "BRCA1 or BRCA2 mutation")   %>%              ## replace whole-word matches of "BRCAm" with "BRCA1 or BRCA2 mutation"
  gsub(pattern = "\\bBRCA\\b", replacement = "BRCA1 or BRCA2")                        ## replace whole-word matches of "BRCA" with "BRCA1 or BRCA2"
  

## processing of patterns such as BRCA1/2 or RAD51C/D
# first, create a table with all substrings in criteria that contain a forward slash
replacements <- data.frame(verbatim = stringr::str_extract_all(string = eligibilities$criteria_processed, pattern = "\\w*/.\\b") %>% unlist()) %>% 
    unique() %>%
    dplyr::mutate(pre = stringr::str_extract(verbatim, pattern = "[^ ]*(?=/)")) %>%        ## get the substring BEFORE the slash
    dplyr::mutate(stem = stringr::str_sub(pre, end = -2))                       %>%        ## nibble the last character off the pre substring
    dplyr::mutate(post = stringr::str_extract(verbatim, pattern = "(?<=/)."))   %>%        ## get the substring AFTER the slash
    dplyr::mutate(post_expanded = paste0(stem, post))                           %>%        ## expand the text after the abbreviation
    dplyr::filter(pre %in% humanGenes$Aliases & post_expanded  %in% humanGenes$Aliases ) %>%        ## only keep rows where both pre and post_expanded are valid gene alias
    dplyr::mutate(expanded = paste0(pre, " or ", post_expanded))


## create a named vector to use with str_replace_all
replacement_strings <- as.character(replacements$expanded)
names(replacement_strings) <- replacements$verbatim
# replacement_strings

## replace all occurrences of the verbatim string with the expanded string
eligibilities$criteria_processed <- eligibilities$criteria_processed %>%
  stringr::str_replace_all(pattern = replacement_strings)


 ########################################################################


## do similar for the pattern <GENE NAME>m
replacements2 <- data.frame(verbatim = str_extract_all(string = eligibilities$criteria_processed, pattern = "\\b[A-Z|0-9]+m") %>% unlist()) %>%
  dplyr::mutate(stem = verbatim %>% str_sub( end = -2)) %>%
  dplyr::filter(stem %in% humanGenes$Aliases) %>%
  dplyr::mutate(expanded = paste(stem, "mutation", sep = " ")) %>%
  unique()

## create a named vector to use with str_replace_all
replacement_strings2 <- as.character(replacements2$expanded)
names(replacement_strings2) <- replacements2$verbatim
#replacement_strings2

## replace all occurrences of the verbatim string with the expanded string
eligibilities$criteria_processed <- eligibilities$criteria_processed %>%
  stringr::str_replace_all(pattern = replacement_strings2)

```

```{r create dictionary of genetic alteration types}
## create named list of alteration types
alteration_types <- list(
  "mutation" = c("mutant", "mutants", "mutation", "mutations", "mutated", "loss of function", "loss-of-function", "alteration", "alterations", "altered", "deficient", "deficiency", "variant", "variants"), 
  "amplification" = c("amplified", "amplification", "amplifications", "overexpress", "overexpression", "overexpressing", "overexpressed"),
  "loss" = c("deletion", "deletions", "deleted", "loss", "lost"),
  "rearrangement" = c("fusion", "fusions", "fusion-positive", "rearranged", "gene fusion", "truncation", "truncations", "truncated", "truncating", "duplication", "duplications", "duplicated", "translocation", "translocations", "translocated", "rearranged", "rearrangement", "rearrangements")
 )

## convert to a dictionary for use by quanteda
alterations_dictionary <- quanteda::dictionary(alteration_types)

## for example... 
# alterations_dictionary[["mutation"]]
```

```{r create dictionary of gene name tokens}

## filter out genes not included as synonyms in NCIt
humanGenes_dictionary <- humanGenes %>%
    dplyr::filter(Symbol %in% NCIt$synonyms) %>%
    unstack(form = Aliases ~ Symbol)   %>%                                   ## convert to named list, Entrez symbol are keys, values are Aliases
    quanteda::dictionary(tolower = FALSE)

## look up HER2 as an example
# humanGenes_dictionary[["ERBB2"]]
```

```{r look for co occurrence of gene name and alteration pattern in processed criterion text}

## define size of window (either side) for co occurrence
window_size <- 6

eligibilities_alterations_genes <- eligibilities %>%
    corpus(docid_field = "criterion_index",  text_field = "criteria_processed") %>% 
    tokens() %>%
    kwic(pattern =  alterations_dictionary, window = window_size) %>% 
    as.data.frame() %>%
    dplyr::mutate(window = paste0(pre, " ", keyword, " ", post)) %>% 
    dplyr::mutate(geneSymbol = as.list(tokens_lookup(x=tokens(window), dictionary = humanGenes_dictionary, case_insensitive = FALSE))) %>%
    unnest(cols = "geneSymbol") %>%
    as.data.frame() %>%
    dplyr::select(docname, window, geneSymbol, pattern) %>%
    dplyr::rename("criterion_index"="docname") %>%
    dplyr::rename("alteration_type"="pattern") %>%
    dplyr::mutate(gene_alteration_type = paste(geneSymbol, alteration_type, sep = " ")) %>%
    unique()


eligibilities <- eligibilities %>%
  merge(by.x = "criterion_index", all.x = TRUE, y = eligibilities_alterations_genes, by.y = "criterion_index") %>%
  dplyr::select(nct_id, criterion_index, criterion_type, criteria, gene_alteration_type) %>%
  unique()



```

#### **Index exclusion criteria on prior treatment**  
  
```{r create a dictionary of therapies and procedures}

## include "Therapeutic or Preventive Procedure" to get chemotherapy regimens (e.g. FOLFOX)
semantic_types_therapy <- c("Therapeutic or Preventive Procedure", "Pharmacologic Substance")

therapy_dictionary <- NCIt %>%
  dplyr::filter(semantic_type %in% semantic_types_therapy) %>%
  dplyr::select(code, synonyms) %>%
  dplyr::filter(str_detect(string = synonyms, pattern = "\\(|\\)", negate = TRUE)) %>%           ## omit any rows where synonyms value contains parentheses, as these cause issues with lookup
  unique() %>%
  unstack(form = synonyms ~ code)   %>%                                   ## convert to named list
  quanteda::dictionary()                                                  ## convert to dictionary


```

```{r look for co occurrence of prior therapy terms with treatment terms}

## we are looking specifically within exclusion criteria
## scanning the verbatim criterion text
## for mention of a word like "prior" or "previous"
## and mention of a therapy within a defined window
## then we just keep the entire verbatim criterion

prior_tx_exclusions <- eligibilities %>%
    dplyr::filter(criterion_type == "EXCLUSION") %>%
    dplyr::select(nct_id, criterion_index, criteria) %>%
    unique() %>%
    corpus(docid_field = "criterion_index",  text_field = "criteria") %>% 
    tokens() %>%
    kwic(pattern =  "previous|prior", window = window_size, valuetype = "regex") %>% 
    as.data.frame() %>%
    #kwic(pattern =  "previous|prior", window = window_size, valuetype = "regex") %>% 
    dplyr::mutate(window = paste0(pre, " ", keyword, " ", post)) %>% 
    dplyr::mutate(therapy_code = as.list(tokens_lookup(x=tokens(window), dictionary = therapy_dictionary, nested_scope = "dictionary"))) %>%
    unnest(cols = "therapy_code") %>%
    as.data.frame() %>%
    dplyr::select(docname, window, therapy_code) %>%
    dplyr::rename("criterion_index"="docname") %>%
    merge(by.x = "therapy_code", y = NCIt, by.y = "code") %>%
    merge(by.x = "criterion_index", y = eligibilities, by.y = "criterion_index") %>%
    dplyr::select(nct_id, criterion_index, criteria, therapy_code, display_name) %>%
    dplyr::group_by(nct_id) %>%
    dplyr::summarise(
        tx_exclusions = paste(unique(criteria), collapse = ";\n")
    ) %>%
    as.data.frame() %>%
    unique()

```

```{r join prior therapy exclusions to cancerStudies table}

cancerStudies <- cancerStudies %>%
  merge(by.x = "nct_id", all.x = TRUE, y = prior_tx_exclusions, by.y = "nct_id")

```

### **Index design groups**  
  
```{r preprocess design group descriptions}

design_groups <- design_groups %>%
  dplyr::mutate(dg_title_description = paste(dg_title, dg_description, sep = ": ")) %>%
  dplyr::select(nct_id, dg_id, dg_title_description) %>%            
  unique()

## expand gene abbreviations in dg_title_description as for eligibility criteria
## create a copy of criterion text for processing
design_groups$dg_title_description_processed <- design_groups$dg_title_description %>%
  gsub(pattern = "\\bBRCAm\\b", replacement = "BRCA1 or BRCA2 mutation")   %>%              ## replace whole-word matches of "BRCAm" with "BRCA1 or BRCA2 mutation"
  gsub(pattern = "\\bBRCA\\b", replacement = "BRCA1 or BRCA2")                        ## replace whole-word matches of "BRCA" with "BRCA1 or BRCA2"


## processing of patterns such as BRCA1/2 or RAD51C/D
# first, create a table with all substrings in criteria that contain a forward slash
replacements <- data.frame(verbatim = stringr::str_extract_all(string = design_groups$dg_title_description_processed, pattern = "\\w*/.\\b") %>% unlist()) %>% 
    unique() %>%
    dplyr::mutate(pre = stringr::str_extract(verbatim, pattern = "[^ ]*(?=/)")) %>%        ## get the substring BEFORE the slash
    dplyr::mutate(stem = stringr::str_sub(pre, end = -2))                       %>%        ## nibble the last character off the pre substring
    dplyr::mutate(post = stringr::str_extract(verbatim, pattern = "(?<=/)."))   %>%        ## get the substring AFTER the slash
    dplyr::mutate(post_expanded = paste0(stem, post))                           %>%        ## expand the text after the abbreviation
    dplyr::filter(pre %in% humanGenes$Aliases & post_expanded  %in% humanGenes$Aliases ) %>%        ## only keep rows where both pre and post_expanded are valid gene alias
    dplyr::mutate(expanded = paste0(pre, " or ", post_expanded))


## create a named vector to use with str_replace_all
replacement_strings <- as.character(replacements$expanded)
names(replacement_strings) <- replacements$verbatim
# replacement_strings

## replace all occurrences of the verbatim string with the expanded string
design_groups$dg_title_description_processed <- design_groups$dg_title_description_processed %>%
  stringr::str_replace_all(pattern = replacement_strings)


 ########################################################################

## do similar for the pattern <GENE NAME>m
replacements2 <- data.frame(verbatim = str_extract_all(string = design_groups$dg_title_description_processed, pattern = "\\b[A-Z|0-9]+m") %>% unlist()) %>%
  dplyr::mutate(stem = verbatim %>% str_sub( end = -2)) %>%
  dplyr::filter(stem %in% humanGenes$Aliases) %>%
  dplyr::mutate(expanded = paste(stem, "mutation", sep = " ")) %>%
  unique()

## create a named vector to use with str_replace_all
replacement_strings2 <- as.character(replacements2$expanded)
names(replacement_strings2) <- replacements2$verbatim
#replacement_strings2

## replace all occurrences of the verbatim string with the expanded string
design_groups$dg_title_description_processed <- design_groups$dg_title_description_processed %>%
  stringr::str_replace_all(pattern = replacement_strings2)


```
  
```{r look for co occurrence of gene name and alteration pattern in processed design group descriptions}

## define size of window (either side) for co occurrence
window_size <- 6

design_groups_alterations_genes <- design_groups %>%
    corpus(docid_field = "dg_id",  text_field = "dg_title_description_processed") %>% 
    tokens() %>%
    kwic(pattern =  alterations_dictionary, window = window_size) %>% 
    as.data.frame() %>%
    dplyr::mutate(window = paste0(pre, " ", keyword, " ", post)) %>% 
    dplyr::mutate(geneSymbol = as.list(tokens_lookup(x=tokens(window), dictionary = humanGenes_dictionary, case_insensitive = FALSE))) %>%
    unnest(cols = "geneSymbol") %>%
    as.data.frame() %>%
    dplyr::select(docname, window, geneSymbol, pattern) %>%
    dplyr::rename("dg_id"="docname") %>%
    dplyr::rename("alteration_type"="pattern") %>%
    dplyr::mutate(gene_alteration_type = paste(na.omit(geneSymbol), na.omit(alteration_type), sep = " ")) %>%
    unique()


design_groups <- design_groups %>%
  merge(by.x = "dg_id", all.x = TRUE, y = design_groups_alterations_genes, by.y = "dg_id") %>%
  #dplyr::mutate(gene_alteration_type = paste(geneSymbol, alteration_type, sep = " ")) %>%
  dplyr::select(nct_id, dg_id, dg_title_description, gene_alteration_type) %>%            ## these are only columns needed for Shiny app
  unique()
  



```

### **Score matches against gene alterations**  
  
#### **Score studies enrolling patients with feature**  
  
* Assign *eligibility_score* +3 if enrolling patients with 1 or more specified alteration  
  
```{r assign eligibility score}

scored_matches <- eligibilities %>%
  dplyr::select(nct_id, gene_alteration_type, criteria) %>%
  dplyr::filter(!is.na(gene_alteration_type)) %>%
  dplyr::group_by(nct_id, gene_alteration_type) %>%
  dplyr::summarise(
    matching_criteria = paste(unique(criteria), collapse = "\n\n")
    ) %>%
  as.data.frame() %>%
  dplyr::mutate(eligibility_rationale = paste0("Enrolling subjects with ", gene_alteration_type)) %>%
  dplyr::mutate(eligibility_score = 3) %>%
  #dplyr::rename("matching_criteria"="criteria") %>%
  unique()




```











  
  
  
  
  














```{r save tables needed for Shiny app to DB}
## by doing this last, if any errors encountered above, Shiny app will use previous version of DB
dbWriteTable(conn = sqlite_con,name = "cancerStudies", cancerStudies , overwrite=TRUE)
dbWriteTable(conn = sqlite_con,name = "interventions", interventions , overwrite=TRUE)

```

```{r disconnect from  database}

# disconnect from clinicaltrials.gov
dbDisconnect(ctgov_con)

# Disconnect from SQLite database
dbDisconnect(sqlite_con)

# disconnect from CHEMBL DB
dbDisconnect(chemblDB_con)
```
  
`r knitr::knit_exit()`  



  












































  




### **Get pathway graph data from KEGG**  
  
* We will get pathway information from KEGG, specifically for the pathway *Pathways In Cancer* (KEGG ID *hsa05200*).  
  
```{r get edge list}

## download KGML file for Pathways In Cancer as KGML file
pathwaysInCancer_KGML <- get_KGML("hsa05200")
#class(pathwaysInCancer_KGML)

## expand mappings
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML, convert_KEGG_IDs = FALSE)
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML)
pathwaysInCancer_edges <- expand_KEGG_edges(pathwaysInCancer_KGML, pathwaysInCancer_mappings)

## create a simple edgelist
edges <- unique(dplyr::select(pathwaysInCancer_edges, "from"="entry1symbol", "to"="entry2symbol", specific_subtype, value))

## note this includes nodes other than genes (e.g. estradiol)

# #Modify existing data sets; specify as nodes and edges
# pathwaysInCancer_node_mapping_info <- node_mapping_info(pathwaysInCancer_mappings)
# 
# pathwaysInCancer_edge_mapping_info <- edge_mapping_info(pathwaysInCancer_edges)
# 
# #Create an igraph object
# pathwaysInCancer.igraph <- get_graph_object(pathwaysInCancer_node_mapping_info, pathwaysInCancer_edge_mapping_info)
# 
# ## get edgelist
# edges <- as_data_frame(pathwaysInCancer.igraph, what = c("edges"))
# 
# ## retain only edges where "from" is a gene
# edges <- unique(dplyr::filter(edges, entry1type=="gene"))
# 
# ## drop unnecessary columns
# # keep edge IDs fur use in graph analysis 
# edges <- unique(dplyr::select(edges, "from"="entry1symbol", "to"="entry2symbol",edgeID, specific_subtype, tooltip))
# 
# 
# ## unnest the from and to columns
# edges$from <- strsplit(edges$from, split = ",")
# edges <- unnest(edges, cols = "from")
# 
# edges$to <- strsplit(edges$to, split = ",")
# edges <- unnest(edges, cols = "to")
# 
# ## convert back to dataframe
# edges <- as.data.frame(edges)

```
  
* These data are saved as a simple edge list in the *edges* table  
 * "-->" denotes *Activation*  
 * "--|" denotes *Inhibition*  
 * "..>" denotes *Indirect effect*  
 * "-+-" denotes *Dissociation*  
 * "---" denotes *Binding*  
 * "-/-" denotes *Missing interaction*  
  

`r formattable(head(edges))`  
  
```{r create table of edges}
## preview
formattable(head(edges))

## create as a table in database
dbWriteTable(conn = sqlite_con,name = "edges", value = edges, overwrite=TRUE)

## check it has saved
# dbListTables(sqlite_con)

```
  
  
### **Create views for trial finder**  
  

    



#### **Scored matches view**  
  
* Studies will be scored as follows:  
  


  * Assign *eligibility_score* +4 if study design group includes patients with 1 or more specified alteration (i.e. stratified on alteration)  

```{r score design group features}
## get matching design groups
scored_matches_dg <- unique(dplyr::filter(population_features, id_type=="design_group"))

## exclude studies not in open_cancerStudies_view
scored_matches_dg <- unique(dplyr::filter(scored_matches_dg, nct_id %in% open_cancerStudies_nct_ids))


## drop rows without a gene match
scored_matches_dg <- dplyr::filter(scored_matches_dg, !is.na(controlled_match))
## drop rows based on prior therapy
scored_matches_dg <- dplyr::filter(scored_matches_dg, feature != "prior therapy")

## concatenate gene name and feature
scored_matches_dg$gene_variant_type <- paste(scored_matches_dg$controlled_match, scored_matches_dg$feature, sep = " ")

## create a string to describe rationale
scored_matches_dg$eligibility_rationale <- paste0("Stratified on ", scored_matches_dg$gene_variant_type)

## select, rename and reorder columns for compatibility with trialMatchDataRefresh.Rmd
scored_matches_dg <- unique(dplyr::select(scored_matches_dg,nct_id,"symbol"="controlled_match",  "variant_type"="feature", eligibility_rationale, "matching_criteria"="text"))
                                          
## where multiple criteria, aggregate
scored_matches_dg <- scored_matches_dg %>%
                                      dplyr::group_by(nct_id, symbol, variant_type, eligibility_rationale) %>%
                                      dplyr::summarise(
                                        matching_criteria = paste(unique(matching_criteria), collapse = "\n\n")
                ) %>%
  as.data.frame()
  
## add a score - we will assign a score of +4 so that this takes precedent over inclusion criteria (where both apply)
scored_matches_dg$eligibility_score <- 4
```
  
```{r combine rationale for eligibility and design groups}
## row bind the two tables
scored_matches_study <- rbind(scored_matches_study, scored_matches_dg)

## based on DG feedback, where there is a match in both eligibility criteria and design group descriptions, we will not add scores
## presumably, we should only show one of the criteria - either eligibility or design groups, not both
## in order to do so, we will only show the row with the highest eligibility_score (i.e. stratification)...  

scored_matches_study <- scored_matches_study %>%
  dplyr::group_by(nct_id, symbol, variant_type) %>%
  dplyr::arrange(desc(eligibility_score)) %>%
  dplyr::summarise(
    eligibility_rationale = eligibility_rationale[1],
    matching_criteria = matching_criteria[1],
    eligibility_score = 3 ## reset so stratification and inclusion are scored identically
  ) %>%
  as.data.frame()

```

  * Assign *intervention_score* +2 if any intervention targets an altered gene directly  

```{r score matches on intervention target}
## start with interventions
scored_matches_interventions <- unique(dplyr::select(interventions, nct_id, intervention_name, TARGET_SYMBOL))

## exclude studies not in open_cancerStudies_view
scored_matches_interventions <- unique(dplyr::filter(scored_matches_interventions, nct_id %in% open_cancerStudies_nct_ids))

## exclude rows where target is NA
scored_matches_interventions <- dplyr::filter(scored_matches_interventions, !is.na(TARGET_SYMBOL))

## add rationale column
scored_matches_interventions$intervention_rationale <- paste0("Study intervention (", scored_matches_interventions$intervention_name, ") targets ", scored_matches_interventions$TARGET_SYMBOL)

## add a score
scored_matches_interventions$intervention_score <- 2
```
  
  * Assign *intervention_score* +1 if any intervention targets a gene immediately downstream of an altered gene  

```{r score matches on pathway neighbour targets}

## start with interventions
scored_matches_interventions_pathways <- unique(dplyr::select(interventions, nct_id, intervention_name, TARGET_SYMBOL))

## exclude studies not in open_cancerStudies_view
scored_matches_interventions_pathways <- unique(dplyr::filter(scored_matches_interventions_pathways, nct_id %in% open_cancerStudies_nct_ids))

## exclude rows where target is NA
scored_matches_interventions_pathways <- dplyr::filter(scored_matches_interventions_pathways, !is.na(TARGET_SYMBOL))

## join to edges, where drugTargetSymbol == to
## i.e. intervention targets the downstream node
scored_matches_interventions_pathways <- merge(x=scored_matches_interventions_pathways, by.x="TARGET_SYMBOL", y=dplyr::select(edges, from, to), by.y="to")

## drop any from values that are not genes
scored_matches_interventions_pathways <- dplyr::filter(scored_matches_interventions_pathways, from %in% humanGenes$Symbol)

## select and rename columns
scored_matches_interventions_pathways <- unique(dplyr::select(scored_matches_interventions_pathways,nct_id, intervention_name, "downstream"="TARGET_SYMBOL","upstream"="from" ))

## where an intervention targets >1 gene, aggregate
scored_matches_interventions_pathways <- as.data.frame(scored_matches_interventions_pathways %>%
                dplyr::group_by(nct_id, intervention_name, upstream) %>%
                dplyr::summarise(
                  downstream = paste(unique(downstream), collapse = ", ")
                ))

## add rationale column
scored_matches_interventions_pathways$intervention_rationale <- paste0("Study drug (", scored_matches_interventions_pathways$intervention_name, ") targets downstream gene(s) (", scored_matches_interventions_pathways$downstream, ")")

## drop downstream column
scored_matches_interventions_pathways <- unique(dplyr::select(scored_matches_interventions_pathways, -c(downstream)))

## rename upstream column to TARGET_SYMBOL to match scored_matches_interventions
#pathwayMatches <- rename(pathwayMatches, "symbol"="upstream")
scored_matches_interventions_pathways$TARGET_SYMBOL <- scored_matches_interventions_pathways$upstream
scored_matches_interventions_pathways <- dplyr::select(scored_matches_interventions_pathways, -upstream)


## add a score
scored_matches_interventions_pathways$intervention_score <- 1

## harmonise columns
scored_matches_interventions_pathways <- unique(dplyr::select(scored_matches_interventions_pathways, names(scored_matches_interventions)))

```
  
    * If an intervention is listed as targeting a gene directly **and** targeting a second gene immediately downstream, we will just take the highest score (i.e. +2)  
    
```{r combine target and pathway matches}
## combine matches on target and pathway
scored_matches_interventions_combined <- rbind(scored_matches_interventions, scored_matches_interventions_pathways)

## where intervention had both direct and pathway matches, just take the highest score
scored_matches_interventions_combined <- scored_matches_interventions_combined %>%
  dplyr::group_by(nct_id, intervention_name, TARGET_SYMBOL) %>%
  dplyr::arrange(desc(intervention_score)) %>%
  dplyr::summarise(
    intervention_rationale = head(intervention_rationale, 1), 
    intervention_score = head(intervention_score, 1)
  )

```

```{r expand intervention matches to apply to all alteration types}
## for genes that don't have a match in eligilityMatches, we want to be able to match on gene alone, regardless of variant_type... 
scored_matches_interventions_combined$variant_type <- list(unique(scored_matches_study$variant_type))

## unnest to multiply rows
scored_matches_interventions_combined <- data.frame(unnest(scored_matches_interventions_combined, cols = "variant_type"))

## select and reorder columns 
scored_matches_interventions_combined <- dplyr::select(scored_matches_interventions_combined, nct_id, "symbol"="TARGET_SYMBOL", variant_type, intervention_rationale, intervention_score)

```
  
* Calculate a *combined_score* = *eligibility_score* + *intervention_score*  
  
```{r calculate combined scores}
## merge matches tables 
scoredMatches_view <- merge(x=scored_matches_study, by.x=c("nct_id", "symbol", "variant_type"), all.x=TRUE, 
      y=scored_matches_interventions_combined, by.y = c("nct_id", "symbol", "variant_type"), all.y=TRUE)

## add a combined score
scoredMatches_view$combined_score <- rowSums(scoredMatches_view[,c("intervention_score", "eligibility_score")], na.rm=TRUE)

## concatenate symbol and variant_type columns to get <gene name> <variant_type>, e.g. "EGFR mutation"
scoredMatches_view$gene_variant_type <- paste(scoredMatches_view$symbol, scoredMatches_view$variant_type, sep=" ")

## select and reorder columns
scoredMatches_view <- unique(dplyr::select(scoredMatches_view, symbol, variant_type,gene_variant_type, nct_id, intervention_rationale, eligibility_rationale, matching_criteria, combined_score))

## order on combined_score descending
scoredMatches_view <- scoredMatches_view[order(scoredMatches_view$combined_score, decreasing = TRUE), ]

```

* Scored matches (studies in open_cancerStudies_view only) are saved in the *scoredMatches_view* table:  








```{r get result groups}
getResultGroupsQ <- paste0("select rg.nct_id, rg.id as rg_id, ctgov_group_code, result_type, rg.title as rg_title, rg.description as rg_description
from result_groups rg 
where rg.nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
result_groups <- dbGetQuery(conn2,getResultGroupsQ)

```
 
```{r get outcome measurements table}

getOutcome_measurements <- paste0("select *
from outcome_measurements 
where nct_id in (",
"", studyIDsForSQL,
")")
# 
## get data from clinicaltrials.gov
outcome_measurements <- dbGetQuery(conn2, getOutcome_measurements)
 


```
  
```{r get reported event counts}

getAEcounts <- paste0("select *
from reported_events 
where nct_id in (",
"", studyIDsForSQL,
")")
# 
## get criteria from clinicaltrials.gov
AE_counts <- dbGetQuery(conn2, getAEcounts)

## order on subjects_affected descending
AE_counts <- AE_counts[order(AE_counts$subjects_affected, decreasing = TRUE), ]

# kbl(head(AE_counts), format = "html",escape = FALSE) %>%
#   kable_styling(fixed_thead = T, bootstrap_options = c("striped", "hover", "condensed")) %>%
#   scroll_box(width = "125%", height = "200px")
```
 
```{r get event totals}

getAEtotals <- paste0("select *
from reported_event_totals 
where nct_id in (",
"", studyIDsForSQL,
")")
# 
## get criteria from clinicaltrials.gov
AE_totals <- dbGetQuery(conn2, getAEtotals)

```


### **Get result groups**  
  
#### **Get result groups**  
   
```{r concatenate titles and descriptions for result groups}

result_groups$rg_title_description <- paste(result_groups$rg_title, result_groups$rg_description, sep = ": ")

## replace mu (micro) symbols with u as this causes mapping function to barf
result_groups$rg_title_description <- gsub(pattern = "\U00B5|\U03BC", replacement = "u", x=result_groups$rg_title_description)

```
 
```{r filter result groups and retain only outcomes and events}
## NOTE SOME RESULT GROUPS ARE "TOTAL" i.e. total values for all groups
## these will not be specified as design groups
## if we try to map these onto a design group, the mapping is likely to barf
## WE WILL EXCLUDE THESE GROUPS AT THIS POINT by filtering result groups and retaining only those where result_type = "Outcome" or "Reported Event"... 

result_groups <- unique(dplyr::filter(result_groups, result_type %in% c("Outcome", "Reported Event")))

## update list of unmapped result groups ids
# unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=predictions$rg_id)
```

### **Map result groups to design groups**  
  
Interventions are linked to design groups (study arms).   
  
Results are reported for result groups, but these are not explicitly mapped to design groups. In order to know how outcomes relate to treatment, we need to map from result groups to design groups.  
  
This is not always obvious...  
  
* Where a study has only a single design group, we will map all result groups for that study to that design group.  
* If a result group title exactly matches a design group title, we will associate interventions based on the design group interventions.  
* For remaining studies, we will predict which design group each result group belongs to based on comparison of the titles and descriptions for design and result groups.    

```{r create empty dataframe that will hold predicted mappings}

predictions <- data.frame(nct_id = character(0),
                          rg_id = character(0), 
                          predicted_design_group = character(0)
                          )

```

```{r create a variable that will hold unmapped result groups}

unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=predictions$rg_id)


```

#### **Map result groups for single arm studies**  
  
For studies with only a single design group, all result groups will be mapped to that design group.  
  
```{r studies with 1 design group}
## start timer 
tic("studies with 1 design group")

single_dg_studies <- design_groups %>%
  group_by(nct_id) %>%
  summarise(
    number_dgs = length(unique(dg_id)), 
    predicted_design_group = paste(unique(dg_id), collapse = "; ")
  ) %>% 
  filter(number_dgs == 1) %>%
  as.data.frame()


## join to result groups on nct_id... 
## this means all result groups for that study will be mapped to the single design group
single_dg_studies <- merge(x=single_dg_studies, by.x="nct_id", y=result_groups, by.y = "nct_id")

## just select the columns (and order) needed to bind to predictions
single_dg_studies <- unique(dplyr::select(single_dg_studies,names(predictions)))

## rowbind onto predictions table
predictions <- unique(rbind(predictions, single_dg_studies))

## update list of unmapped result groups ids
unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=predictions$rg_id)

toc()
```

#### **Map result groups based on exact match between group titles**  
  
For result groups that have a title that exactly matches a design group title for that study, those result groups will be mapped to those design groups.  
  
```{r studies with matching design and result group titles}

matched_group_titles <- unique(dplyr::select(design_groups, nct_id, "predicted_design_group" = "dg_id", dg_title))

## convert title to lowercase
matched_group_titles$dg_title <- tolower(matched_group_titles$dg_title)

## map result group title to lowercase
result_groups$rg_title_lower <- tolower(result_groups$rg_title)

## merge
matched_group_titles <- unique(merge(x=matched_group_titles, by.x = c("nct_id", "dg_title"), y=dplyr::select(result_groups, nct_id, rg_id, rg_title_lower), by.y = c("nct_id", "rg_title_lower")))

## make names match predictions
matched_group_titles <- unique(dplyr::select(matched_group_titles, names(predictions)))

## rowbind onto predictions
predictions <- unique(rbind(predictions, matched_group_titles))

## update list of unmapped result groups ids
unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=predictions$rg_id)
```
  
#### **Assign interventions based on similarity between design, result group descriptions**   
  
For result groups that remain unmapped after the above, we will map them to the design group for that study that has the most similar title and/or description.  
  


For each unmapped design group, we will create a document-term matrix from design group title and description, then use this to generate a classification tree model to predict design group ids for document-term matrices based on result group titles and descriptions.  
  
We will specify design group titles and interventions as custom tokens when tokenising.  

```{r define function to create document term matrix}

## define a function that will... 
# accept custom tokens to be included in tokenisation
# create document-term matrix

create_dtm <- function(dataframe, text_column, id_column, custom_tokens) {
  ## get the text column to be used
  text_column_num <- which(names(dataframe)==text_column)
  text <- dataframe[ , text_column_num]
  ## remove anything that is not a number or letter...
  text <- str_squish(str_replace_all(string = text, "[^a-zA-Z0-9]", replacement = " "))
  ## overwrite the text column  
  dataframe[ , text_column_num] <- text

  
  ## 1. TOKENISE THE TEXT COLUMN
  ## need to tokenise using corpus function, as this allows drug synonyms, inc multi word synonyms, to be specified upfront as tokens so they don't get split
  dataframe$word <- as.list(corpus::text_tokens(x=dataframe[ , text_column_num], filter= corpus::text_filter(combine = custom_tokens, map_case=TRUE, connector="_", drop_punct=TRUE )))
  ## unnest
  dataframe <- as.data.frame(unnest(data = dataframe, word)) 
  ## this function does insist on replacing whitespace with a character (here, underscore), so need to swap that back to whitespace
  # dataframe$word <- gsub(pattern = "_", replacement = " ", x=dataframe$word)
  ## remove stopwords
  # dataframe <- anti_join(x=dataframe, y=stopwords)
  
  ## 2. CREATE DOCUMENT-TERM MATRIX
  ## count each word in each description
  dataframe <- dataframe %>% 
    group_by_at(id_column) %>%
    count(word, sort=FALSE) %>%
    ungroup() %>%
    as.data.frame()
  ## use reshape2::dcast so get a dataframe as a result
  dataframe <- reshape2::dcast(data=dataframe, formula = as.formula(paste(id_column, "~ word")), value.var = "n")
  ## convert NA to zero
  dataframe <- dataframe %>% mutate_all(~replace(., is.na(.), 0))
  ## convert id to factor
  dataframe[ , which(names(dataframe)==id_column)] <- as.factor(dataframe[ , which(names(dataframe)==id_column)])
  
  ## 3. RETURN DOCUMENT-TERM MATRIX
  return(dataframe)
}

```

```{r loop through remaining unmapped result groups}
## start timer
tic("loop through remaining unmapped result groups")


## we will perform mapping per-study, not per result group... 

## get a list of studies with unmapped result groups
unmapped_study_ids <- unique(result_groups$nct_id[result_groups$rg_id %in% unmapped_result_group_ids])


for(i in 1:length(unmapped_study_ids)) {
  #print(paste0(i, "/", length(unmapped_study_ids)))
  study_id <- unmapped_study_ids[i]
  
  #study_id <- unique(unmapped_design_groups$nct_id)[i]
  #print(study_id)
  
  temp_unmapped_dgs <- unique(dplyr::filter(design_groups, nct_id == study_id))
  ## if no design groups, skip to next study
  if(nrow(temp_unmapped_dgs)==0) next
  
  ## drop unnecessary columns
  temp_unmapped_dgs <- unique(dplyr::select(temp_unmapped_dgs, nct_id, dg_id,dg_title, dg_title_description))
  
  ## get study interventions (verbatim) to use as custom tokens
  study_interventions_verbatim <- unique(interventions$intervention_name[interventions$nct_id==study_id])
  #print(study_interventions_verbatim)
  
  ## get synonyms for study interventions to use as custom tokens
  study_interventions_NCItID <- unique(na.omit(interventions$NCIt_ID[interventions$nct_id==study_id]))
  #print(study_interventions_NCItID)
  
  study_interventions_synonyms <- unique( NCIt_Pharmacologics$Synonyms[NCIt_Pharmacologics$ID %in% study_interventions_NCItID])
  #print(study_interventions_synonyms)
  
  ## get design group titles to use as custom tokens
  design_group_titles <- temp_unmapped_dgs$dg_title 
  #print(design_group_titles)
  
  tokens <- unique(c(study_interventions_synonyms, design_group_titles,study_interventions_verbatim))
  
  ## create document term matrix
  unmapped_dgs_dtm <- create_dtm(dataframe = temp_unmapped_dgs, text_column = "dg_title_description", id_column = "dg_id", custom_tokens = tokens)
  #print(unmapped_dgs_dtm)
  
  temp_unmapped_rgs <- unique(dplyr::filter(result_groups, nct_id == study_id))
  ## drop unnecessary columns
  temp_unmapped_rgs <- unique(dplyr::select(temp_unmapped_rgs, nct_id, rg_id,rg_title, rg_title_description))
  
  ## create DTM for result group descriptions
  unmapped_rgs_dtm <- create_dtm(dataframe = temp_unmapped_rgs, text_column = "rg_title_description", id_column = "rg_id", custom_tokens = tokens)
  #print(unmapped_rgs_dtm)
  ## make names valid, otherwise rpart will barf...
  names(unmapped_dgs_dtm) <- gsub(" ", "_", names(unmapped_dgs_dtm))
  names(unmapped_rgs_dtm) <- gsub(" ", "_", names(unmapped_rgs_dtm))
  
  ## get those column names that are common to both dtms
  common_terms <- intersect(names(unmapped_dgs_dtm), names(unmapped_rgs_dtm))
  
  ## drop any common_terms that are numbers
  common_terms <- common_terms[is.na(as.numeric(common_terms))]
  
  ## drop any common terms that are stopwords
  common_terms <- common_terms[!(common_terms %in% stopwords$word)]
  
  ## if no common terms, skip to next study
  if(length(common_terms)==0) next
  
  ## drop non-overlapping columns from DGs_dtm
  unmapped_dgs_dtm <- dplyr::select(unmapped_dgs_dtm, dg_id, all_of(common_terms))
  #print(unmapped_dgs_dtm)
  
  tryCatch({
            ## create decision tree model
            modFit <- rpart::rpart(formula = dg_id ~., method = "class", data = unmapped_dgs_dtm, control =rpart.control(minsplit = 1,minbucket=1, cp=0))
            ## (optional) print tree
            #rpart.plot(modFit)
            ## predict design group for each result group
            study_predictions <- data.frame(nct_id = as.character(study_id),
                          rg_id = as.character(unmapped_rgs_dtm$rg_id), 
                          predicted_design_group = as.character(predict(object = modFit, unmapped_rgs_dtm, type = "class"))
                          )
            #print(study_predictions)
            
            }, error=function(cond) {
              return(study_predictions <- data.frame(nct_id = study_id,
                                                     result_group_id = unmapped_rgs_dtm$rg_id,
                                                     predicted_design_group = NA
                          ))})
  
  ## row bind study predictions onto predictions table
  predictions <- unique(rbind(predictions, study_predictions))
  
  
}



## update list of unmapped result groups ids
unmapped_result_group_ids <- setdiff(x=result_groups$rg_id, y=predictions$rg_id)

toc()
```

```{r join descriptions to sanity check}
predictions$nct_id <- as.character(predictions$nct_id)
predictions$rg_id <- as.character(predictions$rg_id)
predictions$predicted_design_group <- as.character(predictions$predicted_design_group)

## join result group titles and descriptons
predictions <- merge(x=predictions, by.x=c("nct_id", "rg_id"), y=dplyr::select(result_groups, nct_id, rg_id, rg_title_description), by.y=c("nct_id", "rg_id"))

## join design group titles and descriptions
predictions <- merge(x=predictions, by.x=c("nct_id", "predicted_design_group"), y=dplyr::select(design_groups, nct_id, dg_id, dg_title_description), by.y=c("nct_id", "dg_id"))

```
  

  
Predicted mappings from result groups to design groups are stored in the *predictions* table:  
  

  
```{r write predictions to database}
## create as a table in database
# dbWriteTable(conn = sqlite_con,name = "predictions", value = predictions, overwrite=TRUE)
# 
# ## check it has saved
# # dbListTables(con)
# 
# ## delete unmapped study ids
# rm(unmapped_study_ids)

```

### **Get outcome data**  
  

#### **Overall survival**  
  
* First, filter the outcome measurements table and retain rows where the outcome measurement title contains the pattern "*\\bOS\\b|\\boverall survival\\b*"  
  * ("\\b" enforces whole-word match)  
* Second, filter and retain rows where units contain the pattern "*days|weeks|months|years*"  
* Third, convert units to months (rounded to 1 decimal place):  
  * Where units = days, divide parameter values and confidence limits by 28  
  * Where units = weeks, divide parameter values and confidence limits by 4  
  * Where units = years, multiply parameter values and confidence limits by 12  
  
* **Note we have not filtered according to *parameter type*, and so values may be median (most common), mean, min, max or any other summary statistic.**  
  
  
```{r filter and return only OS data}

## first filter on on presence of OS pattern
# OS_pattern <- "\\bOS\\b|\\boverall survival\\b"
# overall_survival <- outcome_measurements[grep(pattern = OS_pattern, x=outcome_measurements$title, ignore.case = TRUE), ]
# 
# ## second, filter on units
# # overall_survival <- overall_survival[grep(pattern = "days|weeks|months|years", x=overall_survival$units, ignore.case = TRUE), ]
# overall_survival$units <- tolower(overall_survival$units)
# overall_survival <- unique(dplyr::filter(overall_survival, units %in% c("days", "weeks", "months", "years")))
# 
# ## remove the param_value column
# overall_survival <- dplyr::select(overall_survival, -c(param_value))
# 
# ## convert days to months
# ## ASSUME 28 DAYS IN A MONTH
# # convert point estimates
# overall_survival$param_value_num[grep(pattern = "days", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$param_value_num[grep(pattern = "days", x=overall_survival$units, ignore.case = TRUE)]/28, digits = 1)
# # convert LL
# overall_survival$dispersion_lower_limit[grep(pattern = "days", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$dispersion_lower_limit[grep(pattern = "days", x=overall_survival$units, ignore.case = TRUE)]/28, digits = 1)
# # convert UL
# overall_survival$dispersion_upper_limit[grep(pattern = "days", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$dispersion_upper_limit[grep(pattern = "days", x=overall_survival$units, ignore.case = TRUE)]/28, digits = 1)
# # reset units 
# overall_survival$units[grep(pattern = "days", x=overall_survival$units, ignore.case = TRUE)] <- "months"
# 


## convert weeks to months
## ASSUME 4 WEEKS IN A MONTH
# convert point estimates
# overall_survival$param_value_num[grep(pattern = "weeks", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$param_value_num[grep(pattern = "weeks", x=overall_survival$units, ignore.case = TRUE)]/4, digits = 1)
# # convert LL
# overall_survival$dispersion_lower_limit[grep(pattern = "weeks", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$dispersion_lower_limit[grep(pattern = "weeks", x=overall_survival$units, ignore.case = TRUE)]/4, digits = 1)
# # convert UL
# overall_survival$dispersion_upper_limit[grep(pattern = "weeks", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$dispersion_upper_limit[grep(pattern = "weeks", x=overall_survival$units, ignore.case = TRUE)]/4, digits = 1)
# # reset units 
# overall_survival$units[grep(pattern = "weeks", x=overall_survival$units, ignore.case = TRUE)] <- "months"



## convert years to months
## ASSUME 12 MONTHS IN A YEAR
# convert point estimates
# overall_survival$param_value_num[grep(pattern = "years", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$param_value_num[grep(pattern = "years", x=overall_survival$units, ignore.case = TRUE)]*12, digits = 1)
# # convert LL
# overall_survival$dispersion_lower_limit[grep(pattern = "years", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$dispersion_lower_limit[grep(pattern = "years", x=overall_survival$units, ignore.case = TRUE)]*12, digits = 1)
# # convert UL
# overall_survival$dispersion_upper_limit[grep(pattern = "years", x=overall_survival$units, ignore.case = TRUE)] <- round(overall_survival$dispersion_upper_limit[grep(pattern = "years", x=overall_survival$units, ignore.case = TRUE)]*12, digits = 1)
# # reset units 
# overall_survival$units[grep(pattern = "years", x=overall_survival$units, ignore.case = TRUE)] <- "months"
# 
# 
# ## add a column to indicate these are all OS data
# overall_survival$outcome_controlled <- "Overall survival"
```
  
* Overall survival measurements have been written to the *overall_survival* table:  
  

  
```{r write OS table to DB}
## create as a table in database
# dbWriteTable(conn = con,name = "overall_survival", value = overall_survival, overwrite=TRUE)

## check it has saved
# dbListTables(con)

```


  
#### **Get progression-free survival data**  
     
* Filter and retain outcome measurements where outcome title includes the pattern "*PFS|progression-free survival|progression free survival*".  
* Filter and retain rows where units include the pattern "*days|weeks|months|years*"  
* Convert units to months (as for OS, above)  
  
  
```{r filter and return only PFS data}

# ## first filter on on presence of OS pattern
# PFS_pattern <- "PFS|progression-free survival|progression free survival"
# PFS <- outcome_measurements[grep(pattern = PFS_pattern, x=outcome_measurements$title, ignore.case = TRUE), ]
# 
# ## second, filter on units
# # PFS <- PFS[grep(pattern = "days|weeks|months|years", x=PFS$units, ignore.case = TRUE), ]
# PFS$units <- tolower(PFS$units)
# PFS <- unique(dplyr::filter(PFS, units %in% c("days", "weeks", "months", "years")))
# 
# 
# ## remove the param_value column
# PFS <- dplyr::select(PFS, -c(param_value))
# 
# ## convert days to months
# ## ASSUME 28 DAYS IN A MONTH
# # convert point estimates
# PFS$param_value_num[grep(pattern = "days", x=PFS$units, ignore.case = TRUE)] <- round(PFS$param_value_num[grep(pattern = "days", x=PFS$units, ignore.case = TRUE)]/28, digits = 1)
# # convert LL
# PFS$dispersion_lower_limit[grep(pattern = "days", x=PFS$units, ignore.case = TRUE)] <- round(PFS$dispersion_lower_limit[grep(pattern = "days", x=PFS$units, ignore.case = TRUE)]/28, digits = 1)
# # convert UL
# PFS$dispersion_upper_limit[grep(pattern = "days", x=PFS$units, ignore.case = TRUE)] <- round(PFS$dispersion_upper_limit[grep(pattern = "days", x=PFS$units, ignore.case = TRUE)]/28, digits = 1)
# # reset units 
# PFS$units[grep(pattern = "days", x=PFS$units, ignore.case = TRUE)] <- "months"



## convert weeks to months
## ASSUME 4 WEEKS IN A MONTH
# convert point estimates
# PFS$param_value_num[grep(pattern = "weeks", x=PFS$units, ignore.case = TRUE)] <- round(PFS$param_value_num[grep(pattern = "weeks", x=PFS$units, ignore.case = TRUE)]/4, digits = 1)
# # convert LL
# PFS$dispersion_lower_limit[grep(pattern = "weeks", x=PFS$units, ignore.case = TRUE)] <- round(PFS$dispersion_lower_limit[grep(pattern = "weeks", x=PFS$units, ignore.case = TRUE)]/4, digits = 1)
# # convert UL
# PFS$dispersion_upper_limit[grep(pattern = "weeks", x=PFS$units, ignore.case = TRUE)] <- round(PFS$dispersion_upper_limit[grep(pattern = "weeks", x=PFS$units, ignore.case = TRUE)]/4, digits = 1)
# # reset units 
# PFS$units[grep(pattern = "weeks", x=PFS$units, ignore.case = TRUE)] <- "months"



## convert years to months
## ASSUME 12 MONTHS IN A YEAR
# convert point estimates
# PFS$param_value_num[grep(pattern = "years", x=PFS$units, ignore.case = TRUE)] <- round(PFS$param_value_num[grep(pattern = "years", x=PFS$units, ignore.case = TRUE)]*12, digits = 1)
# # convert LL
# PFS$dispersion_lower_limit[grep(pattern = "years", x=PFS$units, ignore.case = TRUE)] <- round(PFS$dispersion_lower_limit[grep(pattern = "years", x=PFS$units, ignore.case = TRUE)]*12, digits = 1)
# # convert UL
# PFS$dispersion_upper_limit[grep(pattern = "years", x=PFS$units, ignore.case = TRUE)] <- round(PFS$dispersion_upper_limit[grep(pattern = "years", x=PFS$units, ignore.case = TRUE)]*12, digits = 1)
# # reset units 
# PFS$units[grep(pattern = "years", x=PFS$units, ignore.case = TRUE)] <- "months"
# 
# ## add a column to indicate these are all PFS data
# PFS$outcome_controlled <- "Progression free survival"
```
  
    
* Progression-free survival measurements have been written to the *PFS* table:  
  


```{r write PFS table to DB}
## create as a table in database
# dbWriteTable(conn = con,name = "PFS", value = PFS, overwrite=TRUE)

## check it has saved
# dbListTables(con)

```


### **Get adverse event data**  
  
#### **Specific adverse event counts**  
  
* Data for specific adverse events are stored in the *reported_events* table.  
  

  
* Details include number of subjects affected and number of subjects at risk.  
  
* We can derive *percent_affected* based on subjects_affected / subjects_at_risk...  

```{r derive AE rates}
# AE_counts$percent_affected <- round(((AE_counts$subjects_affected * 100)/ AE_counts$subjects_at_risk), digits = 1)
# 
# 
# kbl(head(AE_counts), format = "html",escape = FALSE) %>%
#   kable_styling(fixed_thead = T, bootstrap_options = c("striped", "hover", "condensed")) %>%
#   scroll_box(width = "125%", height = "200px")


```
  
```{r write AE counts table to DB}
## create as a table in database
# dbWriteTable(conn = con,name = "AE_counts", value = AE_counts, overwrite=TRUE)

## check it has saved
# dbListTables(con)

```

#### **General adverse event counts (e.g. total, any adverse event)**  
  
  
* Total event counts are also stored in the *reported_event_totals* table.  
  
* These data include summary counts such as *Total, serious adverse events*, *Total, other adverse events* etc.  
  

* Number of subjects at risk and affected are also included, so we can derive *percent_affected*.  
  
```{r derive percent affected}

## derive percent affected
# AE_totals$percent_affected <- round((AE_totals$subjects_affected * 100)/ AE_totals$subjects_at_risk, digits = 1)
# 
# kbl(head(AE_totals), format = "html",escape = FALSE) %>%
#   kable_styling(fixed_thead = T, bootstrap_options = c("striped", "hover", "condensed")) %>%
#   scroll_box(width = "125%", height = "200px")
```


```{r write AE totals table to DB}
## create as a table in database
# dbWriteTable(conn = con,name = "AE_totals", value = AE_totals, overwrite=TRUE)

## check it has saved
# dbListTables(con)

```

