---
title: "Index clinicaltrials.gov data"
author: "digital ECMT"
date: "19/11/2021"
output: html_document
---


```{r copyright notice}
 # 
 # This file is part of the cancer-trial-match distribution (https://github.com/digital-ECMT/cancer-trial-match).
 # Copyright (C) 2021 digital ECMT
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3 or later.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #


```




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
##NOTE: the following packages are required to run this script, but should be installed (e.g. using code snippets below) before runnning the script, NOT as part of the script itself
# options(repos = "http://cran.us.r-project.org")
# install.packages("BiocManager")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("KEGGREST")
# BiocManager::install("KEGGlincs")
# BiocManager::install("hgu133a.db")
require(KEGGlincs)        ## GPL-3
require(KEGGgraph)        ## GPL >= 2
require(org.Hs.eg.db)     ## Artistic-2.0
require(KEGGREST)         ## Artistic 2.0
require(DBI)              ## LGPL-2.1 | LGPL-3 
require(RODBC)            ## GPL-2 | GPL-3
require(RPostgres)        ## GPL-3
require(RSQLite)          ## LGPL-2.1 | LGPL-3
require(jsonlite)         ## MIT
require(dplyr)            ## MIT
require(tidyr)            ## MIT
require(formattable)      ## MIT
require(kableExtra)       ## MIT
require(stringr)          ## MIT
require(splitstackshape)  ## GPL-3
require(reshape2)         ## MIT
require(tictoc)           ## Apache License (== 2.0
require(leaflet)          ## GPL-3
require(PostcodesioR)     ## GPL-3
require(igraph)           ## GPL-2 | GPL-3
require(tidygeocoder)     ## MIT

## clean up first
rm(list=ls())

##get today's date
today <- format(Sys.Date(), format = "%d %B %Y")
```


**Date of data refresh: `r today`**  
  
  
```{r connect to SQLite DB} 
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "indexedTrialData.sqlite")

dbListTables(con)

```
  
#### **Download and save a table of human genes and synonyms**  
  
  
```{r download and process a list of all human genes and their synonyms}

## start timer
tic("download a list of all human genes and their synonyms")


humanGenes <- read.table(file = "humanGenes.tsv", header = TRUE, quote = "", sep = "\t", fill = TRUE, stringsAsFactors = FALSE)

humanGenes <- dplyr::select(humanGenes, Symbol, Aliases)## drop everything except Symbol and Aliases columns


humanGenes$Aliases <- strsplit(x=humanGenes$Aliases, split = ",")## split the aliases on comma 
humanGenes <- unnest(data = humanGenes, cols = Aliases, keep_empty = TRUE) ## unnest to multiply rows, keep any rows with no aliases
humanGenes <- as.data.frame(humanGenes) ## convert to data frame

humanGenes$Aliases <- str_squish(string = humanGenes$Aliases) ## trim excess whitespace from Aliases values

## Symbol values are not represented among Aliases
# create a data frame with unique Symbol values
symbols <- data.frame("Symbol"=unique(humanGenes$Symbol), "Aliases"=unique(humanGenes$Symbol))
# bind this onto bottom of humanGenes data frame
humanGenes <- rbind(humanGenes,symbols)
# remove duplicated values, if any
humanGenes <- unique(humanGenes)
# sort on Symbol values
humanGenes <- humanGenes[order(humanGenes$Symbol), ] 

# drop any rows where Aliases is NA
humanGenes <- humanGenes[!is.na(humanGenes$Aliases), ]

## drop any rows where Aliases value is only a single character

## NOW humanGenes TABLE CONTAINS ALL HUMAN GENES AND THEIR SYNONYMS
## (61,593 unique symbols, 130,989 rows)

## stop timer
toc()
```
  
```{r create table of human genes}
## preview
# formattable(head(humanGenes))

## create as a table in database
dbWriteTable(conn = con,name = "humanGenes", value = humanGenes, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
    
#### **Download and save NCI thesaurus**  
  

```{r download and create NCIthesaurus table}

## specify URL for NCI thesaurus - this should always be the most recent? 
NCItURL <- "https://evs.nci.nih.gov/ftp1/NCI_Thesaurus/Thesaurus.FLAT.zip"

destFlatFilename <- "NCIt_FLAT.zip"
download.file(url=NCItURL,destfile = destFlatFilename)
unzip(zipfile = paste0(getwd(),"/",destFlatFilename))

NCIt <- read.table("Thesaurus.txt",header = FALSE, sep = "\t", comment.char = "", fill = TRUE, stringsAsFactors = FALSE, quote = "")
names(NCIt) <- c("ID","URL","ParentID","Synonyms","Description","PreferredTerm","Type","Class")

## an entity may have more than one class, so need to multiply rows
## split and unnest the Class column of NCIt
NCIt$Class <- strsplit(NCIt$Class, split = "\\|")
NCIt <- unnest(data = NCIt, Class)

## do the same for Parent column
## split ParentID column on pipe symbol
NCIt$ParentID <- strsplit(NCIt$ParentID, split = "\\|")
## unnest the ID column to multiply rows
NCIt <- unnest(data=NCIt,ParentID)

## drop unnecessary rows
NCIt <- unique(dplyr::select(NCIt, ID, ParentID, Synonyms, PreferredTerm, Class))

## join parent column back
## first, get the synonyms and IDs for parents
NCItParents <- NCIt[which(NCIt$ID %in% NCIt$ParentID), ]

## each parent term may have more than one synonym
## for simplicity, we will retain only the first synonym for each parent term
NCItParents$Synonyms <- gsub("\\|.*","",NCItParents$Synonyms)

NCItParents <- unique(dplyr::select(NCItParents, "ParentID"="ID", "Parent_synonym"="Synonyms"))

## merge parents on entity ID = parent ID
NCIt <- merge(x=NCIt,y=NCItParents,by.x="ParentID",by.y="ParentID",all.x=TRUE)

## split and unnest the Synonyms column
NCIt$Synonyms <- strsplit(NCIt$Synonyms, split = "\\|")
NCIt <- unnest(data = NCIt, Synonyms)

NCIt <- as.data.frame(NCIt)

## add a column to indicate date downloaded
NCIt$downloaded <- Sys.Date()

## drop redundant rows, if any
NCIt <- unique(NCIt)

## create as a table in database
dbWriteTable(conn = con,name = "NCIt", value = NCIt, overwrite=TRUE)

```
  
#### **Map NCIt drugs to targets via KEGG**  

    
```{r subset NCIt for Pharmacologic Substance}


NCIt_Pharmacologics <- unique(dplyr::filter(NCIt, Class=="Pharmacologic Substance"))


```


```{r define function to map drug names to KEGG drug IDs}

# test using "1-methyl-D-tryptophan", aka "Indoximod"

getDrugID <- function(drugName){
  if(is.na(drugName)) return(NA)
  ## get drug ID
  drugid <- tryCatch({names(keggFind(database = "drug", query = drugName))},
             error=function(cond) {return(NA)})
  if(is.null(drugid)) return(NA)
  if(is.na(drugid)) return(NA)
  drugid <- as.list(drugid)
  return(drugid)
}

```


```{r map NCIt drug names to KEGG drug IDs}
NCIt_Pharmacologics$kegg_drug_id <- NA

tic("index NCIt pharmacologics with kegg drug id")
for(i in 1:length(unique(NCIt_Pharmacologics$ID))) {
  print(paste0("i:", i))
  id <- unique(NCIt_Pharmacologics$ID)[i]
  print(paste0("ID:", id))
  synonyms <- unique(NCIt_Pharmacologics$Synonyms[NCIt_Pharmacologics$ID == id])
  print(paste(synonyms, collapse = ", "))
  kegg_drugid <- NA
  ## loop through synonyms and call KEGG API
  for(j in 1:length(synonyms)) {
    kegg_drugid <- getDrugID(synonyms[j])
    if(!is.na(kegg_drugid)) break
  }
  print(paste0("kegg drug id:", kegg_drugid))
  NCIt_Pharmacologics$kegg_drug_id[NCIt_Pharmacologics$ID == id] <- kegg_drugid
}
toc()


```




















#### **Download and save lat, long values of cities**  
  

```{r get lat long values from city name using tidygeocoder}

# # remove any commas and anything after a comma
# cancerStudies$locations <- gsub(pattern = ",.*", replacement = "", x=cancerStudies$locations)
# 
# ## use tidygeocoder (MIT licence)
# ## need append country from config file after city name...
# cities <- as.data.frame(tidygeocoder::geo(address = unique(paste0(cancerStudies$locations, ", ", configuration$country)), method = 'osm'))
#   
# ## trim off the suffix
# cities$address <- gsub(pattern=paste0(", ", configuration$country), replacement = "", x=cities$address)
# 
# ## join back on study location == address
# cancerStudies <- merge(x=cancerStudies, by.x="locations", all.x=TRUE, y=dplyr::select(cities, address, lat, long), by.y="address")




```

  









`r knitr::knit_exit()`    












#### **Get controlled terms and synonyms for cancer types**  
  
      
```{r read cancer type synonyms into memory}

conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")


```

#### **Get human gene names and synonyms**  
  
```{r read human genes table into memory}

humanGenes <- dbGetQuery(con, "SELECT * FROM genes")


```

  
#### **Get NCI thesaurus**  
  
```{r read NCIt into memory}

NCIthesaurus <- dbGetQuery(con, "SELECT * FROM NCIt")


```

  
#### **Connect to clinicaltrials.gov**  
  
  
```{r connect to clinicaltrialsgov}  
## specify user name and password for AACT account
## see https://aact.ctti-clinicaltrials.org/ for how to create an account

## load configuration data from JSON file
## configuration <- rjson::fromJSON(file = "trialMatchConfiguration.json")

## jsonlite is MIT
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password


## connect via RPostgres (GPL-3 licence)
drv = RPostgres::Postgres()
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
```
 
  
#### **Get cancer studies with results**  
  
 
```{r get study data}

## get data for all cancer studies that have reported results
cancerStudiesResults_query <- "SELECT s.nct_id, s.brief_title, c.name AS condition, i.name AS interventions 
FROM studies s
INNER JOIN conditions c ON c.nct_id = s.nct_id
INNER JOIN interventions i ON i.nct_id = s.nct_id
inner join calculated_values cv on cv.nct_id = s.nct_id
WHERE s.study_type LIKE ('Interventional')
and (c.downcase_name like '%cancer%'
or c.downcase_name like '%neoplasm%'
or c.downcase_name like '%carcinoma%'
or c.downcase_name like '%tumo%')"



## get data from clinicaltrials.gov
cancerStudiesResults <- dbGetQuery(conn2,cancerStudiesResults_query)

## add a column to indicate refresh date
cancerStudiesResults$Refresh.date <- today

```
 
#### **Map verbatim condition names to controlled set of cancer types**  
  
  
```{r tokenise and join to condition synonyms}
## we can't just join to condition synonyms as condition may include extra words
## such as "Stage IV Lung Cancer AJCC v8" and "Metastatic Lung Non-Small Cell Carcinoma"

## we will provide condition synonyms as custom tokens, then tokenise, unnest and perform the join
custom_tokens <- unique(conditionSynonyms$condition.synonyms)

cancerStudiesResults$word <- as.list(corpus::text_tokens(x=cancerStudiesResults$condition,                                                filter= corpus::text_filter(combine = custom_tokens, map_case=TRUE, connector="_", drop_punct=TRUE )))


## unnest
cancerStudiesResults <- as.data.frame(unnest(data = cancerStudiesResults, word)) 
## this function does insist on replacing whitespace with a character (here, underscore), so need to swap that back to whitespace
cancerStudiesResults$word <- gsub(pattern = "_", replacement = " ", x=cancerStudiesResults$word)


## join on cancerStudiesResults$word = conditionSynonyms$condition.synonyms
cancerStudiesResults <- unique(merge(x=cancerStudiesResults, by.x = "word", y=conditionSynonyms, by.y="condition.synonyms"))

## drop the word column
cancerStudiesResults <- unique(dplyr::select(cancerStudiesResults, -c(word)))


```
  
  
#### **Map interventions to molecular targets**  
  

```{r get molecular targets for cancerStudies interventions}
## first, get all interventions (note that there will be some redundancy due to case)
drugs.targets <- unique(dplyr::select(cancerStudiesResults,nct_id,interventions))

## keep interventions column as verbatim so can join later
## make a duplicate column
drugs.targets$interventions.processed <- drugs.targets$interventions


## split and unnest on " + "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\+ ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " plus "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " plus ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " and "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " and ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " & "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\& ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " or "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " or ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " (+) "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(\\+\\) ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " with "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " with ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

## also split on brackets
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# remove closing bracket
drugs.targets$interventions.processed <- gsub(pattern = "\\)", replacement = "", x=drugs.targets$interventions.processed)


## trim off anything related to dose
# pattern is (a number, with or without a decimal point) with/without a space, followed by "mg", anything after "mg is removed
drugs.targets$interventions.processed <- gsub(pattern = " \\d+\\.?\\d+ ?mg.*", replacement = "", x=drugs.targets$interventions.processed, ignore.case = T)

## convert to lowercase
drugs.targets$interventions.processed <- tolower(drugs.targets$interventions.processed)

drugs.targets <- as.data.frame(drugs.targets)



## join to NCIthesaurus 
## drop rows without a match 
drugs.targets <- merge(x=drugs.targets, 
      by.x = "interventions.processed", 
      all.x = FALSE,
      y= unique(dplyr::select(NCIthesaurus, "NCI_ID"="ID", SynonymsLower, PreferredTerm, ParentTerm)), 
      by.y = "SynonymsLower")



# convert empty cells to NA
drugs.targets$PreferredTerm[drugs.targets$PreferredTerm==""] <- NA

## drop the interventions processed column
drugs.targets <- unique(dplyr::select(drugs.targets, -c(interventions.processed)))

## drop any rows that don't have a preferred term
#drugs.targets <- unique(drugs.targets[!is.na(drugs.targets$PreferredTerm), ])


## reduce number of rows
drugs.targets <-unique(dplyr::select(drugs.targets, interventions, PreferredTerm,NCI_ID))

## map preferred terms to drug IDs in KEGG
# drugs.targets.preferred <- unique(dplyr::select(drugs.targets, PreferredTerm))
```


```{r get drug ids based on intervention name}
## add an empty column to hold drug ID
drugs.targets$drugID <- NA

tic("get drug IDs based on intervention name")
for(i in 1:nrow(drugs.targets)) {
  print(i)
  drugName <- drugs.targets$interventions[i]
  preferred <- drugs.targets$PreferredTerm[i]
  print(drugName)
  drugID <- getDrugID(drugName)
  if(is.na(drugID)) {
    drugID <- getDrugID(preferred)
  }
  
  drugs.targets$drugID[i] <- drugID
  print(drugs.targets$drugID[i])
}  
toc()

## unnest
drugs.targets <- as.data.frame(unnest(data = drugs.targets, drugID, keep_empty = TRUE))


```

```{r define function to get drug target IDs from KEGG}

getDrugTargetID <- function(drugID){
  if(is.na(drugID)) return(NA)
  geneid <- tryCatch({keggGet(drugID)[[1]]$TARGET$TARGET},
             error=function(cond) {return(NA)})
  if(is.null(geneid)) return(NA)
  if(is.na(geneid)) return(NA)
  ## parse the drugTargetID values - trim off extra characters and unnest where multiple targets per drug
  #trim everything up to "HSA:"
  geneid <- gsub(pattern = ".*\\HSA:", replacement = "", x=geneid) 
  # trim everything after square bracket
  geneid <- gsub(pattern = "\\].*", replacement = "", x=geneid) 
  # split on space into individual ids, where applicable
  geneid <- strsplit(geneid, split = " ")
  # unlist
  geneid <- unlist(geneid)
  # paste on a "hsa:"
  geneid <- paste0("hsa:",geneid)
  geneid <- as.list(geneid)
  return(geneid)
}



```



```{r map each drug ID to a target gene ID}
# drugs.targets$target_id <- NA

# drugs.targets$PreferredTerm[drugs.targets$drugID=="dr:D10231"]

temp_table <- data.frame(drugID= unique(na.omit(drugs.targets$drugID)), 
                         target_id = NA)


for(i in 1:nrow(temp_table)) {
  print(i)
  drugid <- as.character(temp_table$drugID[i])
  print(drugid)
  target_id <- getDrugTargetID(drugid)
  print(target_id)
  temp_table$target_id[i] <- list(target_id)
}


## unnest
temp_table <- as.data.frame(unnest(data = temp_table, target_id, keep_empty = FALSE))
temp_table$target_id <- as.character(temp_table$target_id)
## drop any null rows
temp_table <- temp_table[temp_table$target_id != "NULL", ]
```





```{r define function to get drug target symbols from KEGG via API}}
# keggGet("hsa:3620")[[1]]$SYMBOL[1]


getDrugTargetSymbol <- function(targetID){
  if(is.na(targetID)) return(NA)
  geneSymbol <- tryCatch({
    keggGet(targetID)[[1]]$SYMBOL[1]
    }, error=function(cond) {return(NA)})
  if(is.null(geneSymbol)) return(NA)
  if(is.na(geneSymbol)) return(NA)
  ## parse value
  ## multiple symbols separated by comma, we want the first one...
  geneSymbol <- gsub(pattern = ",.*", replacement = "", x=geneSymbol)
  
  return(geneSymbol)
}
```



```{r get drug symbols using function}
temp_table$target_symbol <- NA

tic("get drug target symbols")
for(i in 1:nrow(temp_table)) {
  print(i)
  targetID <- temp_table$target_id[i]
  print(targetID)
  temp_table$target_symbol[i] <- getDrugTargetSymbol(targetID)
  print(temp_table$target_symbol[i])
}
toc()


# temp_table[temp_table$target_symbol != "NA", ]
temp_table <- temp_table[complete.cases(temp_table), ]


# 
# ## reorder columns
# drugs.targets <- unique(dplyr::select(drugs.targets,"interventions.verbatim"= "interventions", interventions.processed, Description, ParentTerm, drugTargetSymbol))
```
  


```{r join target name to interventions}
drugs.targets <- unique(merge(x=drugs.targets, by.x="drugID", all.x=TRUE, y=temp_table, by.y = "drugID"))



```

```{r join mechanisms from NCIt}
drugs.targets <- unique(merge(x=drugs.targets, by.x="NCI_ID", all.x=TRUE, y=unique(dplyr::select(NCIthesaurus, ID, Class, ParentTerm)), by.y = "ID"))



## write to database

```

```{r join drugs targets back to nct_id}

cancerStudiesResults_interventions <- unique(merge(x=unique(dplyr::select(cancerStudiesResults, nct_id, interventions)), by.x = "interventions", y=drugs.targets, by.y="interventions"))



cancerStudiesResults
```


```{r write tables to database}
## write tables to database
dbWriteTable(conn = con,name = "drugs.targets", value = drugs.targets, overwrite=TRUE)




dbWriteTable(conn = con,name = "cancerStudiesResults_interventions", value = cancerStudiesResults_interventions, overwrite=TRUE)



dbListTables(con)


```


```{r disconnect from  database}

# disconnect from clincialtrials.gov
dbDisconnect(conn2)

# Disconnect from SQLite database
dbDisconnect(con)


```
  

  
   
   