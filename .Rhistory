criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - wordRange
ends <- indices + wordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) table$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
table <- table[!is.na(table$match), ]
## unnest
table <- as.data.frame(unnest(table, cols = "match"))
## join to Entrez symbols from humanGenes
table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
## rename Symbol to "controlled.match"
# using rename gives unreliable results (?!)
# see https://stackoverflow.com/questions/26371279/dplyr-0-3-0-2-rename-idiom-unstable-when-reshape-package-is-loaded
#table <- rename(table, "controlled.match"="Symbol")
table$controlled.match <- table$Symbol
table <- dplyr::select(table, -Symbol)
## drop redundant rows
table <- unique(table)
## return table
return(table)
}
## call indexing function
## exclude matches containing "positive" as these tend to be IHC, not mutation
## also exclude "loss" as this is included in rearrangementPattern
mutation.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function", wordRange = 6, featureLabel = "mutation")
## preview
formattable(head(mutation.eligibilities))
## NOT USED BECAUSE SUPERCEDED BY INDEX ON REARRANGEMENTS
fusion.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement", wordRange = 7, featureLabel = "fusion")
## preview
formattable(head(fusion.eligibilities))
rearrangement.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement|truncation|truncated|deletion|deleted|lost|duplication|duplicated", wordRange = 6, featureLabel = "rearrangement")
## preview
formattable(head(rearrangement.eligibilities))
## NOTE USE WORD RANGE OF 2 FOR LOSS, OTHERWISE GET TOO MANY FALSE HITS (including "loss of function" etc, which is indexed as a mutation)
loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 2, featureLabel = "loss")
## preview
formattable(head(loss.eligibilities))
amplification.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " amplification|overexpression", wordRange = 5, featureLabel = "amplification")
## preview
formattable(head(amplification.eligibilities))
## create a copy of eligibilities
therapy.eligibilities <- eligibilities
## filter to retain criteria with mention of "previous|prior"
# define pattern
therapyFilter <- "previous therapy|prior therapy|previous treatment|prior treatment"
# filter
therapy.eligibilities <- therapy.eligibilities[grep(pattern = therapyFilter, ignore.case = TRUE, x=therapy.eligibilities$criteria), ]
# set value for feature
therapy.eligibilities$feature <- "PRIOR_THERAPY"
## drop redundant rows, if any
therapy.eligibilities <- unique(therapy.eligibilities)
## since prior therapies tend to be a mixture of 2-word synonyms, 3-word synonyms etc, plus parent terms, best approach for now is to not try and match against a therapy
# add a controlled.match column for row binding only
therapy.eligibilities$controlled.match <- NA
## instead, in the UI, just show inclusion and exclusion criteria (separately) related to prior therapies
formattable(head(therapy.eligibilities))
# indexed.eligibilities <- unique(rbind(mutation.eligibilities, fusion.eligibilities,  amplification.eligibilities, therapy.eligibilities))
indexed.eligibilities <- unique(rbind(mutation.eligibilities, rearrangement.eligibilities, loss.eligibilities, amplification.eligibilities, therapy.eligibilities))
## preview
#formattable(head(indexed.eligibilities))
## create as a table in database
dbWriteTable(conn = con,name = "indexedEligibility", value = indexed.eligibilities, overwrite=TRUE)
## check it has saved
dbListTables(con)
## download KGML file for Pathways In Cancer as KGML file
pathwaysInCancer_KGML <- get_KGML("hsa05200")
#class(pathwaysInCancer_KGML)
## expand mappings
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML, convert_KEGG_IDs = FALSE)
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML)
pathwaysInCancer_edges <- expand_KEGG_edges(pathwaysInCancer_KGML, pathwaysInCancer_mappings)
## create a simple edgelist
edgelist <- unique(dplyr::select(pathwaysInCancer_edges, "from"="entry1symbol", "to"="entry2symbol", specific_subtype, value))
#Modify existing data sets; specify as nodes and edges
pathwaysInCancer_node_mapping_info <- node_mapping_info(pathwaysInCancer_mappings)
pathwaysInCancer_edge_mapping_info <- edge_mapping_info(pathwaysInCancer_edges)
#Create an igraph object
pathwaysInCancer.igraph <- get_graph_object(pathwaysInCancer_node_mapping_info, pathwaysInCancer_edge_mapping_info)
## get edgelist
edges <- as_data_frame(pathwaysInCancer.igraph, what = c("edges"))
## retain only edges where "from" is a gene
edges <- unique(dplyr::filter(edges, entry1type=="gene"))
## drop unnecessary columns
# keep edge IDs fur use in graph analysis
edges <- unique(dplyr::select(edges, "from"="entry1symbol", "to"="entry2symbol",edgeID, specific_subtype, tooltip))
## unnest the from and to columns
edges$from <- strsplit(edges$from, split = ",")
edges <- unnest(edges, cols = "from")
edges$to <- strsplit(edges$to, split = ",")
edges <- unnest(edges, cols = "to")
## convert back to dataframe
edges <- as.data.frame(edges)
## preview
formattable(head(edges))
## create as a table in database
dbWriteTable(conn = con,name = "edges", value = edges, overwrite=TRUE)
## check it has saved
dbListTables(con)
## start with studies and their interventions
targetMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
## join to drugs.targets on intervention name (verbatim)
targetMatches <- merge(x=targetMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
## drop rows where drugTargetSymbol is NA
targetMatches <- targetMatches[!is.na(targetMatches$drugTargetSymbol), ]
## drop unnecessary columns
targetMatches <- unique(dplyr::select(targetMatches, nct_id, interventions.processed, drugTargetSymbol))
## add rationale column
targetMatches$intervention_rationale <- paste0("Study drug (", targetMatches$interventions.processed, ") targets ", targetMatches$drugTargetSymbol)
## drop intervention column
targetMatches <- unique(dplyr::select(targetMatches, -interventions.processed))
## rename drugTargetSymbol column
#targetMatches <- rename(targetMatches,"symbol"= "drugTargetSymbol")
targetMatches$symbol <- targetMatches$drugTargetSymbol
targetMatches <- dplyr::select(targetMatches, -drugTargetSymbol)
## add a score
targetMatches$intervention_score <- 2
## start with studies and their interventions
pathwayMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
## join to drugs.targets on intervention name (verbatim)
pathwayMatches <- merge(x=pathwayMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
## drop rows where drugTargetSymbol is NA
pathwayMatches <- pathwayMatches[!is.na(pathwayMatches$drugTargetSymbol), ]
## drop unnecessary columns
pathwayMatches <- unique(dplyr::select(pathwayMatches, nct_id, interventions.processed, drugTargetSymbol))
## join to edges, where drugTargetSymbol == to
## i.e. intervention targets the downstream node
pathwayMatches <- merge(x=pathwayMatches, by.x="drugTargetSymbol", y=edges, by.y="to")
## select and rename columns
pathwayMatches <- unique(dplyr::select(pathwayMatches,nct_id, interventions.processed, "downstream"="drugTargetSymbol","upstream"="from" ))
## where an intervention targets >1 gene, aggregate
pathwayMatches <- as.data.frame(pathwayMatches %>%
group_by(nct_id, interventions.processed, upstream) %>%
summarise(
downstream = paste(unique(downstream), collapse = ", ")
))
## add rationale column
pathwayMatches$intervention_rationale <- paste0("Study drug (", pathwayMatches$interventions.processed, ") targets downstream gene(s) (", pathwayMatches$downstream, ")")
## drop intervention column
pathwayMatches <- unique(dplyr::select(pathwayMatches, -c(interventions.processed, downstream)))
## rename upstream column to drugTargetSymbol to match targetMatches
#pathwayMatches <- rename(pathwayMatches, "symbol"="upstream")
pathwayMatches$symbol <- pathwayMatches$upstream
pathwayMatches <- dplyr::select(pathwayMatches, -upstream)
## add a score
pathwayMatches$intervention_score <- 1
scoredMatches <- rbind(targetMatches, pathwayMatches)
## for genes that don't have a match in eligilityMatches, we want to be able to match on gene alone, regardless of variant_type...
scoredMatches$variant_type <- list(c("mutation", "rearrangement", "loss", "amplification"))
## unnest to multiply rows
scoredMatches <- data.frame(unnest(scoredMatches, cols = "variant_type"))
## start with indexed eligibilities
eligibilityMatches <- unique(dplyr::select(indexed.eligibilities, nct_id,"gene"="controlled.match",criterion.type, feature, criteria ))
## filter out matches against exclusion criteria
eligibilityMatches <- filter(eligibilityMatches, criterion.type=="INCLUSION")
## filter out matches against prior therapy
eligibilityMatches <- filter(eligibilityMatches, feature!="PRIOR_THERAPY")
## concatenate gene and feature
# eligibilityMatches$gene <- paste(eligibilityMatches$gene, eligibilityMatches$feature, sep = " ")
## add rationale column
eligibilityMatches$eligibility_rationale <- paste0("Enrolling subjects with ", eligibilityMatches$gene, " ", eligibilityMatches$feature)
## add a score
eligibilityMatches$eligibility_score <- 3
## where multiple criteria, aggregate
eligibilityMatches <- as.data.frame(eligibilityMatches %>%
group_by(nct_id, gene, criterion.type, feature, eligibility_rationale, eligibility_score) %>%
summarise(
criteria = paste(unique(criteria), collapse = "\n\n")
))
## select and rename columns to match targetMatches and pathwayMatches
eligibilityMatches <- unique(dplyr::select(eligibilityMatches, nct_id, "symbol"="gene", "variant_type" = "feature", eligibility_rationale, "matching_criteria"="criteria", eligibility_score))
scoredMatches <- merge(x=scoredMatches, by.x=c("nct_id", "symbol", "variant_type"), all.x=TRUE,
y=eligibilityMatches, by.y = c("nct_id", "symbol", "variant_type"), all.y=TRUE)
## add a combined score
scoredMatches$combined_score <- rowSums(scoredMatches[,c("intervention_score", "eligibility_score")], na.rm=TRUE)
## conatenate symbol and variant_type columns to get <gene name> <variant_type>, e.g. "EGFR mutation"
scoredMatches$gene_variant_type <- paste(scoredMatches$symbol, scoredMatches$variant_type, sep=" ")
## select and reorder columns
scoredMatches <- unique(dplyr::select(scoredMatches, symbol, variant_type,gene_variant_type, nct_id, intervention_rationale, eligibility_rationale, matching_criteria, combined_score))
## order on combined_score descending
scoredMatches <- scoredMatches[order(scoredMatches$combined_score, decreasing = TRUE), ]
## preview
formattable(head(scoredMatches,10))
## create as a table in database
dbWriteTable(conn = con,name = "scoredMatches", value = scoredMatches, overwrite=TRUE)
## check it has saved
dbListTables(con)
## start with evidence data
variantMatches <- unique(dplyr::select(evidence, variant_id, drugs, evidence_type, evidence_direction, clinical_significance))
## join variant info
variantMatches <- merge(x=variantMatches, by.x="variant_id", y=dplyr::select(variants, variant_id, gene, variant), by.y="variant_id")
## drop rows where drugs == NA
variantMatches <- variantMatches[!is.na(variantMatches$drugs), ]
## drop rows where evidence_direction does not support
variantMatches <- variantMatches[variantMatches$evidence_direction=="Supports", ]
## drop unnecessary columns
variantMatches <- unique(dplyr::select(variantMatches, gene, variant, clinical_significance, drugs))
## apply underscore consistently for mutations, amplifications, fusions
variantMatches$variant[grep(pattern = "mutation", x=variantMatches$variant, ignore.case = T)] <- "mutation"
variantMatches$variant[grep(pattern = "amplification", x=variantMatches$variant, ignore.case = T)] <- "amplification"
variantMatches$variant[grep(pattern = "fusion", x=variantMatches$variant, ignore.case = T)] <- "fusion"
## if more than one interpretation for a gene-variant-drug combination, aggregate
variantMatches <- as.data.frame(variantMatches %>%
group_by(gene,variant, drugs) %>%
summarise(
clinical_significance = paste(unique(clinical_significance), collapse = ", ")
))
# drop those rows that have >1 interpretation (based on presence of comma)
variantMatches <- variantMatches[-grep(pattern = ",", x=variantMatches$clinical_significance), ]
## join to intervention names as per clinicaltrials.gov
variantMatches <- merge(x=variantMatches, by.x="drugs", y=unique(dplyr::select(drugs.targets, interventions.verbatim, interventions.processed)), by.y="interventions.processed")
## add rationale column
variantMatches$rationale <- paste0(variantMatches$gene, " ", variantMatches$variant, " predicts ", variantMatches$clinical_significance, " to study intervention (", variantMatches$drugs, ")")
## add score column
variantMatches$score <- ifelse(variantMatches$clinical_significance=="Sensitivity/Response", yes=3, no=-3)
## join to cancerStudies
variantMatches <- merge(x=variantMatches,
by.x="interventions.verbatim",
y=unique(dplyr::select(cancerStudies, nct_id, interventions)),
by.y="interventions")
## create gene_variant values
variantMatches$gene_variant <- paste(variantMatches$gene, variantMatches$variant, sep = " ")
## select and rename columns to match targetMatches etc
variantMatches <- unique(dplyr::select(variantMatches, nct_id, "symbol"="gene_variant", rationale, score))
# scoredMatches <- rbind(eligibilityMatches, targetMatches, pathwayMatches)
#
# ## aggregate where mutliple lines of rationale per gene-study
# scoredMatches <- as.data.frame(scoredMatches %>%
#                 group_by(nct_id, symbol) %>%
#                 summarise(
#                   rationale = paste(unique(rationale), collapse = ", "),
#                   score = sum(score)
#                 ))
# disconnect from clincialtrials.gov
dbDisconnect(conn2)
# Disconnect from SQLite database
dbDisconnect(con)
## fourth, plot graph...
graph <- graph_from_data_frame(d=edges, directed=T)
## look at the nodes
#V(graph)
## look at the edges
#E(graph)
#plot(graph, layout=layout_as_tree(graph))
## get a list of nodes that represent the roots (i.e. the most upstream nodes)
## i.e. nodes that are source nodes (in edges$from) but not target nodes (not in edges$to)
rootNodes <- unique(setdiff(edges$from, edges$to))
# rootNodes
# plot(graph, layout=layout_as_tree(graph, root=rootNodes,mode="out"))
## get degrees of nodes
deg <- degree(graph, mode="all")
# plot(graph, layout=layout_as_tree(graph, root=rootNodes,mode="out"),edge.arrow.size=0.2, vertex.label.cex=0.5, vertex.size=deg*3)
##As a test, get a list of all vertices (nodes) downstream of KRAS
KRASdownstreamNodes <- subcomponent(graph, "KRAS", mode = c("out"))
## get all downstream nodes as a vector
KRASdownstreamNodes$name
##create a subgraph of a graph, containing only the specified vertices and all the edges among them
KRASdownstreamGraph <- induced_subgraph(graph=graph, vids = KRASdownstreamNodes, impl = "auto")
## find paths e.g. from KRAS to CCND1
#all_simple_paths(graph, "KRAS", "CCND1")
## find single shortest path from KRAS to AKT1
shortest.KRAS.AKT1.path <- shortest_paths(graph=KRASdownstreamGraph, from="KRAS", to = "AKT1", mode = c("out"), weights = NULL, output = "both",
predecessors = FALSE, inbound.edges = FALSE)
View(cancerStudies)
names(cancerStudies)
rm(list=ls())
require(flexdashboard)
require(dplyr)
require(tidyr)
require(kableExtra)
require(shinyWidgets)
require(leaflet)
require(htmltools)
require(rjson)
require(RSQLite)
require(DT)
#require(DT)
## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")
## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)
## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
# [1] "interventions"      "locations"          "postcode"
#  [4] "nct_id"             "brief_title"        "overall_status"
#  [7] "condition"          "site_name"          "site_status"
# [10] "investigators"      "contacts"           "Refresh.date"
# [13] "matching.condition" "TARGET.condition"   "Link"
# [16] "postcode.lat"       "postcode.long"      "lat"
# [19] "long"               "ParentTerm"
# no columns are aggregated
## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")
## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))
## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")
## read conditions and synonyms into memory
conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
## aggregating interventions was causing some study:intervention combinations to be missed out
cancerStudies <- cancerStudies %>%
group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts, lat, long, Refresh.date))) %>%
summarize(locations = toString(sort(unique(na.omit(locations)))),
sites = toString(sort(unique(na.omit(site_name)))),
conditions = toString(sort(unique(na.omit(condition)))),
investigators = toString(sort(unique(na.omit(investigators)))),
contacts = toString(sort(unique(na.omit(contacts))))) %>%
as.data.frame()
## read indexed eligibilities table into memory
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")
## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")
## filter for prior therapy
excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")
## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))
## aggregate into single row per study
excludedTX <- excludedTX %>%
group_by(nct_id) %>%
summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
as.data.frame()
## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")
## read cancerStudies table into memory
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")
## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest
## column names are
# [1] "symbol"                 "variant_type"           "nct_id"
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"
# [7] "combined_score"
View(cancerStudies)
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")
## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)
names(cancerStudies)
rm(list=ls())
require(flexdashboard)
require(dplyr)
require(tidyr)
require(kableExtra)
require(shinyWidgets)
require(leaflet)
require(htmltools)
require(rjson)
require(RSQLite)
require(DT)
#require(DT)
## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")
## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)
## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
#  [1] "interventions"      "locations"          "postcode"           "nct_id"
#  [5] "brief_title"        "overall_status"     "condition"          "site_name"
#  [9] "site_status"        "investigators"      "contacts"           "central_contacts"
# [13] "Refresh.date"       "matching.condition" "TARGET.condition"   "Link"
# [17] "postcode.lat"       "postcode.long"      "lat"                "long"
# [21] "ParentTerm"
# no columns are aggregated
## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")
## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))
## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")
## read conditions and synonyms into memory
conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
## aggregating interventions was causing some study:intervention combinations to be missed out
cancerStudies <- cancerStudies %>%
group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts,central_contacts, lat, long, Refresh.date))) %>%
summarize(locations = toString(sort(unique(na.omit(locations)))),
sites = toString(sort(unique(na.omit(site_name)))),
conditions = toString(sort(unique(na.omit(condition)))),
investigators = toString(sort(unique(na.omit(investigators)))),
central_contacts = toString(sort(unique(na.omit(central_contacts)))),
contacts = toString(sort(unique(na.omit(contacts))))) %>%
as.data.frame()
## read indexed eligibilities table into memory
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")
## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")
## filter for prior therapy
excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")
## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))
## aggregate into single row per study
excludedTX <- excludedTX %>%
group_by(nct_id) %>%
summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
as.data.frame()
## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")
## read cancerStudies table into memory
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")
## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest
## column names are
# [1] "symbol"                 "variant_type"           "nct_id"
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"
# [7] "combined_score"
View(cancerStudies)
names(cancerStudies)
names(merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredmatches, by.y=c("nct_id")))
names(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
dbListTables(con)
dbRemoveTable(con, "shortlisted")
dbRemoveTable(con, "fullresults")
dbRemoveTable(con, "allDownloaded")
dbListTables(con)
dbListTables(con)
head(cancerStudies)
paste(cancerStudies$central_contacts, cancerStudies$contacts, sep = ", ")
nrow(cancerStudies)
paste(na.omit(cancerStudies$central_contacts), na.omit(cancerStudies$contacts), sep = ", ")
paste(cancerStudies$central_contacts, cancerStudies$contacts, sep = ", ")
paste(cancerStudies$central_contacts, cancerStudies$contacts, sep = ", ", na.action="pass")
paste(na.omit(cancerStudies$central_contacts), na.omit(cancerStudies$contacts), sep = ", ")
paste(na.omit(cancerStudies$central_contacts), na.omit(cancerStudies$contacts))
dbListTables(con)
dbRemoveTable(con,c("allDownloaded" , "shortlisted", "fullresults") )
dbRemoveTable(con,"allDownloaded" )
dbRemoveTable(con,"fullresults" )
dbRemoveTable(con,"shortlisted" )
nrow(dbGetQuery(con, "SELECT * FROM shortlisted"))
nrow(dbGetQuery(con, "SELECT * FROM shortlisted"))
nrow(dbGetQuery(con, "SELECT * FROM shortlisted"))
nrow(dbGetQuery(con, "SELECT * FROM fullresults"))
nrow(dbGetQuery(con, "SELECT * FROM fullresults"))
head(dbGetQuery(con, "SELECT * FROM fullresults"))
head(dbGetQuery(con, "SELECT * FROM shortlisted"))
fullresultsHead <- head(dbGetQuery(con, "SELECT * FROM fullresults"))
names(fullresultsHead)
aggregate(interventions ~ ., data = fullresultsHead, function(x) paste(unique(x)))
aggregate(interventions ~ nct_id, data = fullresultsHead, function(x) paste(unique(x)))
aggregate(. ~ nct_id, data = fullresultsHead, function(x) paste(unique(x)))
aggregate(interventions ~ , data = fullresultsHead, function(x) paste(unique(x)))
(names(fullresultsHead)-"interventions")
aggregate(fullresultsHead, by=list((names(fullresultsHead))-"interventions") FUN=function(x) paste(unique(x)))
list(names(fullresultsHead))
list(names(fullresultsHead) - "interventions")
!names(fullresultsHead) %in% c("interventions")
names(fullresultsHead)[!names(fullresultsHead) %in% c("interventions")]
aggregate(interventions ~ names(fullresultsHead)[!names(fullresultsHead) %in% c("interventions")], data = fullresultsHead, function(x) paste(unique(x)))
aggregate(interventions ~ list(names(fullresultsHead)[!names(fullresultsHead) %in% c("interventions")]), data = fullresultsHead, function(x) paste(unique(x)))
aggregate(fullresultsHead, by=list(names(fullresultsHead)[!names(fullresultsHead) %in% c("interventions")]), FUN=function(x) paste(unique(x)))
aggregate(interventions ~. , data = fullresultsHead, function(x) paste(unique(x)))
names(fullresultsHead)
fullresultsHead %>%
across(.cols = "interventions", .fns = function(x) {paste(unique(na.omit(x)))})
fullresultsHead %>%
mutate(across(.cols = "interventions", .fns = function(x) {paste(unique(na.omit(x)))}))
fullresultsHead %>%
group_by(across(c(-interventions))) %>%
summarise("interventions" = paste(na.omit(unique(interventions))))
fullresultsHead %>%
group_by(across(c(-interventions))) %>%
summarise("interventions" = paste(na.omit(unique(interventions)))) %>%
as.data.frame()
fullresultsHead %>%
group_by(across(c(-interventions))) %>%
summarise("interventions" = paste(na.omit(unique(interventions))), collapse = ", ") %>%
as.data.frame()
fullresultsHead %>%
group_by(across(c(-interventions))) %>%
summarise("interventions" = paste(na.omit(unique(interventions)), collapse = ", ")) %>%
as.data.frame()
nrow(dbGetQuery(con, "SELECT * FROM fullresults"))
nrow(dbGetQuery(con, "SELECT * FROM fullresults"))
nrow(dbGetQuery(con, "SELECT * FROM fullresults"))
tail(dbGetQuery(con, "SELECT * FROM fullresults"))
