## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
criterion
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
criterion
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
}
criterion
range <- unique(range)
criterion <- criterion[range]
criterion
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
criterion <- fusion.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
criterion
criterion[criterion!=""]
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion
criterion[criterion!=""]
criterion <- criterion[criterion!=""]
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
## define fusion pattern
fusionPattern <- " fusion|rearrangement"
## specify word range - fusionPattern must occur within this many words of a gene name
fusionWordRange <- 7
criterion <- criterion[criterion!=""]
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
criterion
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
rmarkdown::render("trialMatchDataRefresh.Rmd")
?selectInput
library(shiny)
?selectInput
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
View(cancerStudies)
unique(cancerStudies$Refresh.date)
class(unique(cancerStudies$Refresh.date))
parseQueryString("http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation")
rearrangement.eligibilities <- eligibilities
rearrangementPattern <- " fusion|rearrangement|truncation|truncated|deletion|loss|deleted|lost|duplication|duplicated"
rearrangementRange <- 6
View(rearrangement.eligibilities)
rearrangementIndices <- grep(pattern = rearrangementPattern, x=rearrangement.eligibilities$criteria, ignore.case = T)
# subset table
rearrangement.eligibilities <- rearrangement.eligibilities[rearrangementIndices, ]
# label nature of change
rearrangement.eligibilities$feature <- "rearrangement"
dim(rearrangement.eligibilities)
for(i in 1:nrow(rearrangement.eligibilities)) {
criterion <- rearrangement.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(rearrangementPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - rearrangementRange
ends <- indices + rearrangementRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) rearrangement.eligibilities$match[i] <- list(criterion)
}
dim(rearrangement.eligibilities)
## drop rows not indexed against a gene
rearrangement.eligibilities <- rearrangement.eligibilities[!is.na(rearrangement.eligibilities$match), ]
## unnest
rearrangement.eligibilities <- as.data.frame(unnest(rearrangement.eligibilities, cols = "match"))
dim(rearrangement.eligibilities)
rearrangementPattern
## create a copy of eligibilities table
mutation.eligibilities <- eligibilities
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss|loss of function|loss-of-function"
## specify word range - mutantPattern must occur within this many words of a gene name
mutantWordRange <- 6
## define which rows contain a match for mutantPattern
mutantIndices <- grep(pattern = mutantPattern, x=mutation.eligibilities$criteria, ignore.case = T)
# subset table
mutation.eligibilities <- mutation.eligibilities[mutantIndices, ]
# label nature of change
mutation.eligibilities$feature <- "mutation"
## loop through each criterion that contains mutant pattern
for(i in 1:nrow(mutation.eligibilities)) {
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## get indices of match(es) against mutantPattern
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) mutation.eligibilities$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
mutation.eligibilities <- mutation.eligibilities[!is.na(mutation.eligibilities$match), ]
## unnest
mutation.eligibilities <- as.data.frame(unnest(mutation.eligibilities, cols = "match"))
## join to Entrez symbols from humanGenes
mutation.eligibilities <- merge(x=mutation.eligibilities, by.x="match", y=humanGenes, by.y = "Aliases")
## rename Symbol to "controlled.match"
mutation.eligibilities <- rename(mutation.eligibilities, "controlled.match"="Symbol")
View(mutation.eligibilities)
indexOnPattern <- function(eligibilities, pattern, wordRange, featureLabel) {
table <- eligibilities
pattern <- pattern
wordRange <- wordRange
featureLabel <- featureLabel
## get indices containing specified pattern
indices <- grep(pattern = pattern, x=table$criteria, ignore.case = T)
# subset table
table <- table[indices, ]
# label nature of change
table$feature <- featureLabel
## loop through each criterion that contains pattern
for(i in 1:nrow(table)) {
criterion <- table$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - wordRange
ends <- indices + wordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) table$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
table <- table[!is.na(table$match), ]
## unnest
table <- as.data.frame(unnest(table, cols = "match"))
## join to Entrez symbols from humanGenes
table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
## rename Symbol to "controlled.match"
table <- rename(table, "controlled.match"="Symbol")
return(table)
}
indexOnPattern(eligibilities = eligibilities, pattern = rearrangementPattern, wordRange = rearrangementRange, featureLabel = "rearrangement")
testrun <- indexOnPattern(eligibilities = eligibilities, pattern = rearrangementPattern, wordRange = rearrangementRange, featureLabel = "rearrangement")
View(testrun)
library(arsenal)
comparedf(x=rearrangement.eligibilities,y=testrun)
rm(list=ls())
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
indexOnPattern(eligibilities = eligibilities, pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function", wordRange = 6, featureLabel = "mutation")
View(eligibilities)
indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 5, featureLabel = "loss")
loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 5, featureLabel = "loss")
View(loss.eligibilities)
loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 2, featureLabel = "loss")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
names( merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredmatches, by.y=c("nct_id")))
names( merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
cancerStudies[0,]
class(cancerStudies[0,])
names( merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
paste(names( merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id"))), collapse = ",")
paste(names( merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id"))), collapse = "\",\")
paste(names( merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id"))), collapse = "\",\"")
detailedShortlistNames <- c("nct_id","interventions","locations","postcode","brief_title","overall_status","condition","site_name","site_status","investigators","contacts","Refresh.date","matching.condition","TARGET.condition","Link","postcode.lat","postcode.long","lat","long","ParentTerm","symbol","variant_type","gene_variant_type","intervention_rationale","eligibility_rationale","matching_criteria","combined_score")
data.frame(matrix(ncol=length(detailedShortlistNames),nrow=0, dimnames=list(NULL, shortlistNames)))
shortlistNames <- c("Matching cancer type(s)","Matching alteration(s)","Drug rationale","Eligibility","Brief title","Locations","Contacts","ID")
data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=list(NULL, shortlistNames)))
shortlistNames
shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0))
shortlist
names(shortlist) <- shortlistNames
shortlist
head(cancerStudies)
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")
## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)
## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
# [1] "interventions"      "locations"          "postcode"
#  [4] "nct_id"             "brief_title"        "overall_status"
#  [7] "condition"          "site_name"          "site_status"
# [10] "investigators"      "contacts"           "Refresh.date"
# [13] "matching.condition" "TARGET.condition"   "Link"
# [16] "postcode.lat"       "postcode.long"      "lat"
# [19] "long"               "ParentTerm"
# no columns are aggregated
## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")
## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))
## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")
## read conditions and synonyms into memory
conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")
## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)
## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
# [1] "interventions"      "locations"          "postcode"
#  [4] "nct_id"             "brief_title"        "overall_status"
#  [7] "condition"          "site_name"          "site_status"
# [10] "investigators"      "contacts"           "Refresh.date"
# [13] "matching.condition" "TARGET.condition"   "Link"
# [16] "postcode.lat"       "postcode.long"      "lat"
# [19] "long"               "ParentTerm"
# no columns are aggregated
## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")
## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))
## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")
## read conditions and synonyms into memory
conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
## aggregating interventions was causing some study:intervention combinations to be missed out
cancerStudies <- cancerStudies %>%
group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts, lat, long, Refresh.date))) %>%
summarize(locations = toString(sort(unique(na.omit(locations)))),
sites = toString(sort(unique(na.omit(site_name)))),
conditions = toString(sort(unique(na.omit(condition)))),
investigators = toString(sort(unique(na.omit(investigators)))),
contacts = toString(sort(unique(na.omit(contacts))))) %>%
as.data.frame()
head(cancerStudies)
## read indexed eligibilities table into memory
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")
## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")
## filter for prior therapy
excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")
## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))
## aggregate into single row per study
excludedTX <- excludedTX %>%
group_by(nct_id) %>%
summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
as.data.frame()
## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")
head(cancerStudies)
## read cancerStudies table into memory
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")
## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest
## column names are
# [1] "symbol"                 "variant_type"           "nct_id"
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"
# [7] "combined_score"
names(cancerStudies)
names(scoredMatches)
names(merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredmatches, by.y=c("nct_id")))
names(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
head(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
table <- head(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
table
table <- aggregate(table, by=table['nct_id'], function(x) {paste(unique(x), collapse = ";\n")})
View(table)
table <- head(merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredmatches, by.y=c("nct_id")))
table <- head(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
View(table)
table <- head(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")), 30)
View(table)
table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
selectedStudyIDS <- character(0)
selectedStudyIDS
?selectRows
library(shiny)
?selectRows
library(DT)
?selectRows
names(merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredmatches, by.y=c("nct_id")))
names(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
y=scoredMatches, by.y=c("nct_id")))
?rename
head(table)
rename(table, studyid = nct_id)
names(table)
names(cancerStudies)
head(dplyr::select(cancerStudies))
head(dplyr::select(cancerStudies, c("nct_id", "interventions")))
head(dplyr::select(cancerStudies, -c("nct_id", "interventions")))
gsub(pattern = "<.*>", replacement = "", x="<a href="https://clinicaltrials.gov/ct2/show/NCT03395899" target="_blank">Pre-operative Immunotherapy Combination Strategies in Breast Cancer </a>")
gsub(pattern = "<.*>", replacement = "", x="<a href=\"https://clinicaltrials.gov/ct2/show/NCT03395899\" target=\"_blank\">Pre-operative Immunotherapy Combination Strategies in Breast Cancer </a>")
?DT::renderDT
packageDescription("ggplot2", fields="License")
lisc <- installed.packages(fields = "License")
lisc
View(lisc)
packageDescription("ggplot2", fields="License")
View(lisc)
packageDescription("ggplot2")
packageDescription("RPostgreSQL", fields=c("License", "URL"))
packageDescription("stringr", fields=c("License", "URL"))
packageDescription("stringi", fields=c("License", "URL"))
packageDescription("maps", fields=c("License", "URL"))
packageDescription("rjson", fields=c("License", "URL"))
