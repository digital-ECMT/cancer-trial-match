## create an empty version to which matching rows will be added after looping through condition synonyms
cancerStudies <- openStudies[0, ]
# loop through condition synonyms
for(i in 1:nrow(conditionSynonyms)) {
synonym <- as.character(conditionSynonyms$condition.synonyms[i])
targetCondition <- as.character(conditionSynonyms$controlled.cancer.type[i])
## look for a match in condition name
matching.rows <- grep(pattern = synonym, x=openStudies$condition, ignore.case = TRUE)
## create a temporary data frame to hold matches
temp <- openStudies[matching.rows, ]
if(nrow(temp)>0) {
temp$matching.condition <- synonym
temp$TARGET.condition <- targetCondition
cancerStudies <- rbind(cancerStudies, temp)
}
}
## overwrite openStudies with openStudies2
#openStudies <- openStudies2
## delete copy of openStudies to save memory
rm(openStudies)
## remove redundant rows, if any
cancerStudies <- unique(cancerStudies)
## add a column to hold link
cancerStudies$Link <- paste0("https://clinicaltrials.gov/ct2/show/", cancerStudies$nct_id)
## get eligibility criteria (before connection times out)
studyIDs <- unique(cancerStudies$nct_id)
## form SQL query
studyIDsForSQL <- paste0("\'",paste(studyIDs, collapse = "\',\'"), "\'")
getEligibilities <- paste0("select e.nct_id, e.criteria
from eligibilities e
where e.nct_id in (",
"", studyIDsForSQL,
")")
## get criteria from clinicaltrials.gov
eligibilities <- dbGetQuery(conn2,getEligibilities)
## get lat and long for UK cities
## use postcodes where available
locations <- unique(dplyr::select(cancerStudies, postcode))
locations$postcode.lat <- NA
locations$postcode.long <- NA
for(i in 1:nrow(locations)) {
postcode <- locations$postcode[i]
tryCatch({
lat = postcode_lookup(postcode)$latitude
locations$postcode.lat[i] <- lat
long = postcode_lookup(postcode)$longitude
locations$postcode.long[i] <- long
}, error=function(cond) {return(NA)})
}
## join to cancerStudies table
cancerStudies <- merge(x=cancerStudies, by.x="postcode", all.x=TRUE, y =locations, by.y ="postcode")
## should be able to get lat and long values for about 85% of sites (90% of studies) based on city name alone
## try and fill values based on city name
# remove any commas and anything after a comma
cancerStudies$locations <- gsub(pattern = ",.*", replacement = "", x=cancerStudies$locations)
## use tidygeocoder (MIT licence)
## need append country from config file after city name...
cities <- as.data.frame(tidygeocoder::geo(address = unique(paste0(cancerStudies$locations, ", ", configuration$country)), method = 'osm'))
## trim off the suffix
cities$address <- gsub(pattern=paste0(", ", configuration$country), replacement = "", x=cities$address)
## join back on study location == address
cancerStudies <- merge(x=cancerStudies, by.x="locations", all.x=TRUE, y=dplyr::select(cities, address, lat, long), by.y="address")
## if postcode.lat is not NA, use that value to overwrite lat value
cancerStudies$lat[!is.na(cancerStudies$postcode.lat)] <- cancerStudies$postcode.lat[!is.na(cancerStudies$postcode.lat)]
## likewise for longitude
cancerStudies$long[!is.na(cancerStudies$postcode.long)] <- cancerStudies$postcode.long[!is.na(cancerStudies$postcode.long)]
tic("download, parse and write NCI thesaurus to file")
## specify URL for NCI thesaurus - this should always be the most recent?
NCItURL <- "https://evs.nci.nih.gov/ftp1/NCI_Thesaurus/Thesaurus.FLAT.zip"
destFlatFilename <- "NCIt_FLAT.zip"
download.file(url=NCItURL,destfile = destFlatFilename)
unzip(zipfile = paste0(getwd(),"/",destFlatFilename))
NCIt <- read.table("Thesaurus.txt",header = FALSE, sep = "\t", comment.char = "", fill = TRUE, stringsAsFactors = FALSE, quote = "")
names(NCIt) <- c("ID","URL","ParentID","Synonyms","Description","PreferredTerm","Type","Class")
## a drug may have more than one class, so need to multiply rows
## split and unnest the Class column of NCIt
NCIt$Class <- strsplit(NCIt$Class, split = "\\|")
NCIt <- unnest(data = NCIt, Class)
## subset to retain only relevant classes
NCItPharmacologics <- NCIt[which(NCIt$Class %in% c("Pharmacologic Substance","Amino Acid, Peptide, or Protein","Immunologic Factor","Clinical Drug","Therapeutic or Preventive Procedure", "Health Care Activity")), ]
## additional classes related to prior therapy
#  "Therapeutic or Preventive Procedure", "Health Care Activity"
## one drug can have more than one parent, so need to split into multiple rows...
## split ParentID column on pipe symbol
NCItPharmacologics$ParentID <- strsplit(NCItPharmacologics$ParentID, split = "\\|")
## unnest the ID column to multiply rows
NCItPharmacologics <- unnest(data=NCItPharmacologics,ParentID)
## join parent synonyms
## first, get the synonyms and IDs for parents
NCItParents <- NCIt[which(NCIt$ID %in% NCItPharmacologics$ParentID), which(names(NCIt) %in% c("ID", "Synonyms"))]
## each parent term may have more than one synonym
## for simplicity, we will retain only the first synonym for each parent term
NCItParents$Synonyms <- gsub("\\|.*","",NCItParents$Synonyms)
## merge parents on entity ID = parent ID
NCItPharmacologics <- merge(x=NCItPharmacologics,y=NCItParents,by.x="ParentID",by.y="ID",all.x=TRUE)
## reorder and rename
NCItPharmacologics <- dplyr::select(NCItPharmacologics,ID,Class,PreferredTerm,Synonyms="Synonyms.x",Description,ParentTerm="Synonyms.y",ParentID)
## split the Synonyms column on pipe symbol
NCItPharmacologics$Synonyms <- strsplit(NCItPharmacologics$Synonyms, split="\\|")
## unnest the Synonyms column to multiply rows
NCItPharmacologics <- unnest(data = NCItPharmacologics,Synonyms)
## add a column with lower case drug synonyms for joining
NCItPharmacologics$SynonymsLower <- tolower(NCItPharmacologics$Synonyms)
## convert from tibble to data frame
NCIthesaurus <- as.data.frame(NCItPharmacologics)
## add a column to indicate date downloaded
NCIthesaurus$downloaded <- Sys.Date()
## drop redundant rows, if any
NCIthesaurus <- unique(NCIthesaurus)
toc()
## first, get all interventions (note that there will be some redundancy due to case)
drugs.targets <- unique(dplyr::select(cancerStudies,interventions))
## keep interventions column as verbatim so can join later
## make a duplicate column
drugs.targets$interventions.processed <- drugs.targets$interventions
## split and unnest on " + "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\+ ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# also split and unneston the word " plus "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " plus ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# also split and unneston the word " and "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " and ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# also split and unnest on  " & "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\& ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# also split and unnest on  " or "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " or ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# also split and unnest on  " (+) "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(\\+\\) ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# also split and unnest on  " with "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " with ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
## also split on brackets
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# remove closing bracket
drugs.targets$interventions.processed <- gsub(pattern = "\\)", replacement = "", x=drugs.targets$interventions.processed)
## trim off anything related to dose
# pattern is (a number, with or without a decimal point) with/without a space, followed by "mg", anything after "mg is removed
drugs.targets$interventions.processed <- gsub(pattern = " \\d+\\.?\\d+ ?mg.*", replacement = "", x=drugs.targets$interventions.processed, ignore.case = T)
## join to NCIthesaurus so that any intervention not represented in the thesaurus is dropped
drugs.targets <- merge(x=drugs.targets,
by.x = "interventions.processed",
y= unique(dplyr::select(NCIthesaurus, Synonyms, Description, ParentTerm)),
by.y = "Synonyms")
## try to map each processed intervention to a Drug IDs from KEGG
## add an empty column to hold drug ID
drugs.targets$drugID <- NA
tic("get IDs for drugs")
for(i in 1:nrow(drugs.targets)) {
drugid <- NA
drugSynonym <- as.character(drugs.targets$interventions.processed[i])
#print(drugSynonym)
## get (onlY) first drug ID
tryCatch({drugid <- names(keggFind(database = "drug", query = drugSynonym))[1]},
error=function(cond) {return(NA)})
if(length(drugid)>0 ) {
#print(drugid)
drugs.targets$drugID[i] <- drugid}
}
toc()
## separate off drug IDs
targets <- as.data.frame(unique(dplyr::select(drugs.targets, drugID)))
## add a column to hold drug target ID
targets$drugTargetID <- NA
## add a column to hold Entrez symbol for drug target
targets$drugTargetSymbol <- NA
## drop rows without a drugID
targets <- targets[!is.na(targets$drugID),]
## use drug IDs to get gene IDs for target genes
for(i in 1:nrow(targets)) {
drugid <- targets$drugID[i]
geneid <- NA
tryCatch({geneid <- keggGet(drugid)[[1]]$TARGET$TARGET},
error=function(cond) {return(NA)})
#print(geneid)
if(length(geneid)>0) targets$drugTargetID[i] <- geneid
}
## parse the drugTargetID values - trim off extra characters and unnest where multiple targets per drug
## drop any columns that don't contain "HSA:"
#trim everything up to "HSA:"
targets$drugTargetID <- gsub(pattern = ".*\\HSA:", replacement = "", x=targets$drugTargetID)
# trim everything after square bracket
targets$drugTargetID  <- gsub(pattern = "\\].*", replacement = "", x=targets$drugTargetID )
# split on space into individual ids, where applicable
targets$drugTargetID <- strsplit(targets$drugTargetID, split = " ")
targets <- unnest(data = targets, drugTargetID)
targets <- as.data.frame(targets)
## drop rows where drugTargetID is NA
targets <- targets[!is.na(targets$drugTargetID), ]
# paste on a "hsa:"
targets$drugTargetID <- paste0("hsa:",targets$drugTargetID)
## use drugTargetId to get names (Entrez Symbols) for target genes
for(i in 1:nrow(targets)) {
targetId <- targets$drugTargetID[i]
#print(paste0("i= ", i, "; ID = ", targetId))
name <- NA
tryCatch({name <- keggGet(targetId)[[1]]$NAME[1]},
error=function(cond) {return(NA)})
if(length(targetId)>0) {
#name <- keggGet(targetId)[[1]]$NAME[1]
#print(name)
targets$drugTargetSymbol[i] <- name
}
}
## drugTargetSymbol may hold several comma separated values
## first value appears to be Entrez symbol
## trim off everything after first comma
targets$drugTargetSymbol <- gsub(pattern = ",.*", replacement = "", x=targets$drugTargetSymbol )
## join drugTargetSymbol values to drugs.targets table
drugs.targets <- merge(x=drugs.targets, by.x="drugID", all.x=TRUE,
y=unique(dplyr::select(targets, drugID, drugTargetSymbol)), by.y = "drugID")
## reorder columns
drugs.targets <- unique(dplyr::select(drugs.targets,"interventions.verbatim"= "interventions", interventions.processed, Description, ParentTerm, drugTargetSymbol))
## preview
formattable(head(drugs.targets))
## create as a table in database
dbWriteTable(conn = con,name = "drugsTargets", value = drugs.targets, overwrite=TRUE)
## check it has saved
dbListTables(con)
## join on interventions.verbatim == interventions
cancerStudies <- merge(x=cancerStudies, by.x="interventions", all.x=TRUE,
y=unique(dplyr::select(drugs.targets, interventions.verbatim, ParentTerm)), by.y="interventions.verbatim")
## preview
formattable(head(cancerStudies))
## create as a table in database
dbWriteTable(conn = con,name = "cancerStudies", value = cancerStudies, overwrite=TRUE)
## check it has saved
dbListTables(con)
# studyIDs <- unique(cancerStudies$nct_id)
#
# ## form SQL query
# studyIDsForSQL <- paste0("\'",paste(studyIDs, collapse = "\',\'"), "\'")
# getEligibilities <- paste0("select e.nct_id, e.criteria
# from eligibilities e
# where e.nct_id in (",
# "", studyIDsForSQL,
# ")")
#
# ## get criteria from clinicaltrials.gov
# eligibilities <- dbGetQuery(conn2,getEligibilities)
## add a column to indicate criterion type
eligibilities$criterion.type <- NA
## split into individual criteria
for(i in 1:length(eligibilities$criteria)) {
criteria <- as.character(eligibilities$criteria[i])
#criteria <- unlist(strsplit(criteria, split = "\n\n"))## split on double line breaks (DEPRECATED)
criteria <- unlist(strsplit(criteria, split = "\r\n\r\n"))## split on double newline/carriage return
criteria <- trimws(x=criteria, which = "both")## trim whitespace from start and end
criteria <- gsub(pattern = "\n", replacement = "", x= criteria)## remove single line breaks from each criterion
criteria <- str_squish(string = criteria) ## squish repeated spaces within each criterion
#criteria <- as.list(criteria)
eligibilities$criteria[i] <- list(criteria)
}
## unnest
eligibilities <- as.data.frame(unnest(data = eligibilities, cols = criteria))
eligibilities$criterion.type[1] <- "INCLUSION"
## classify as either inclusion or exclusion
## tag start of inclusion criteria
eligibilities$criterion.type[grep(pattern = "inclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "INCLUSION"
## tag start of exclusion criteria
eligibilities$criterion.type[grep(pattern = "exclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "EXCLUSION"
## fill "down" using the tdiyr::fill() function
eligibilities <- tidyr::fill(data=eligibilities, criterion.type, .direction="down")
## add a column to indicate feature referenced by text
eligibilities$feature <- NA
## add a column that will hold matching term (e.g. gene names)
eligibilities$match <- NA
indexOnPattern <- function(eligibilities, pattern, wordRange, featureLabel) {
table <- eligibilities
pattern <- pattern
wordRange <- wordRange
featureLabel <- featureLabel
## get indices containing specified pattern
indices <- grep(pattern = pattern, x=table$criteria, ignore.case = T)
# subset table
table <- table[indices, ]
# label nature of change
table$feature <- featureLabel
## loop through each criterion that contains pattern
for(i in 1:nrow(table)) {
criterion <- table$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - wordRange
ends <- indices + wordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) table$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
table <- table[!is.na(table$match), ]
## unnest
table <- as.data.frame(unnest(table, cols = "match"))
## join to Entrez symbols from humanGenes
table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
## rename Symbol to "controlled.match"
# using rename gives unreliable results (?!)
# see https://stackoverflow.com/questions/26371279/dplyr-0-3-0-2-rename-idiom-unstable-when-reshape-package-is-loaded
#table <- rename(table, "controlled.match"="Symbol")
table$controlled.match <- table$Symbol
table <- dplyr::select(table, -Symbol)
## drop redundant rows
table <- unique(table)
## return table
return(table)
}
## call indexing function
## exclude matches containing "positive" as these tend to be IHC, not mutation
## also exclude "loss" as this is included in rearrangementPattern
mutation.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function", wordRange = 6, featureLabel = "mutation")
## preview
formattable(head(mutation.eligibilities))
## NOT USED BECAUSE SUPERCEDED BY INDEX ON REARRANGEMENTS
fusion.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement", wordRange = 7, featureLabel = "fusion")
## preview
formattable(head(fusion.eligibilities))
rearrangement.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement|truncation|truncated|deletion|deleted|lost|duplication|duplicated", wordRange = 6, featureLabel = "rearrangement")
## preview
formattable(head(rearrangement.eligibilities))
## NOTE USE WORD RANGE OF 2 FOR LOSS, OTHERWISE GET TOO MANY FALSE HITS (including "loss of function" etc, which is indexed as a mutation)
loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 2, featureLabel = "loss")
## preview
formattable(head(loss.eligibilities))
amplification.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " amplification|overexpression", wordRange = 5, featureLabel = "amplification")
## preview
formattable(head(amplification.eligibilities))
## create a copy of eligibilities
therapy.eligibilities <- eligibilities
## filter to retain criteria with mention of "previous|prior"
# define pattern
therapyFilter <- "previous therapy|prior therapy|previous treatment|prior treatment"
# filter
therapy.eligibilities <- therapy.eligibilities[grep(pattern = therapyFilter, ignore.case = TRUE, x=therapy.eligibilities$criteria), ]
# set value for feature
therapy.eligibilities$feature <- "PRIOR_THERAPY"
## drop redundant rows, if any
therapy.eligibilities <- unique(therapy.eligibilities)
## since prior therapies tend to be a mixture of 2-word synonyms, 3-word synonyms etc, plus parent terms, best approach for now is to not try and match against a therapy
# add a controlled.match column for row binding only
therapy.eligibilities$controlled.match <- NA
## instead, in the UI, just show inclusion and exclusion criteria (separately) related to prior therapies
formattable(head(therapy.eligibilities))
# indexed.eligibilities <- unique(rbind(mutation.eligibilities, fusion.eligibilities,  amplification.eligibilities, therapy.eligibilities))
indexed.eligibilities <- unique(rbind(mutation.eligibilities, rearrangement.eligibilities, loss.eligibilities, amplification.eligibilities, therapy.eligibilities))
## preview
#formattable(head(indexed.eligibilities))
## create as a table in database
dbWriteTable(conn = con,name = "indexedEligibility", value = indexed.eligibilities, overwrite=TRUE)
## check it has saved
dbListTables(con)
## download KGML file for Pathways In Cancer as KGML file
pathwaysInCancer_KGML <- get_KGML("hsa05200")
#class(pathwaysInCancer_KGML)
## expand mappings
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML, convert_KEGG_IDs = FALSE)
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML)
pathwaysInCancer_edges <- expand_KEGG_edges(pathwaysInCancer_KGML, pathwaysInCancer_mappings)
## create a simple edgelist
edgelist <- unique(dplyr::select(pathwaysInCancer_edges, "from"="entry1symbol", "to"="entry2symbol", specific_subtype, value))
#Modify existing data sets; specify as nodes and edges
pathwaysInCancer_node_mapping_info <- node_mapping_info(pathwaysInCancer_mappings)
pathwaysInCancer_edge_mapping_info <- edge_mapping_info(pathwaysInCancer_edges)
#Create an igraph object
pathwaysInCancer.igraph <- get_graph_object(pathwaysInCancer_node_mapping_info, pathwaysInCancer_edge_mapping_info)
## get edgelist
edges <- as_data_frame(pathwaysInCancer.igraph, what = c("edges"))
## retain only edges where "from" is a gene
edges <- unique(dplyr::filter(edges, entry1type=="gene"))
## drop unnecessary columns
# keep edge IDs fur use in graph analysis
edges <- unique(dplyr::select(edges, "from"="entry1symbol", "to"="entry2symbol",edgeID, specific_subtype, tooltip))
## unnest the from and to columns
edges$from <- strsplit(edges$from, split = ",")
edges <- unnest(edges, cols = "from")
edges$to <- strsplit(edges$to, split = ",")
edges <- unnest(edges, cols = "to")
## convert back to dataframe
edges <- as.data.frame(edges)
## preview
formattable(head(edges))
## create as a table in database
dbWriteTable(conn = con,name = "edges", value = edges, overwrite=TRUE)
## check it has saved
dbListTables(con)
targetMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
targetMatches <- merge(x=targetMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
targetMatches <- targetMatches[!is.na(targetMatches$drugTargetSymbol), ]
targetMatches <- unique(dplyr::select(targetMatches, nct_id, interventions.processed, drugTargetSymbol))
targetMatches$intervention_rationale <- paste0("Study drug (", targetMatches$interventions.processed, ") targets ", targetMatches$drugTargetSymbol)
targetMatches <- unique(dplyr::select(targetMatches, -interventions.processed))
targetMatches$symbol <- targetMatches$drugTargetSymbol
targetMatches <- dplyr::select(targetMatches, -drugTargetSymbol)
targetMatches$intervention_score <- 2
pathwayMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
pathwayMatches <- merge(x=pathwayMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
pathwayMatches <- pathwayMatches[!is.na(pathwayMatches$drugTargetSymbol), ]
pathwayMatches <- unique(dplyr::select(pathwayMatches, nct_id, interventions.processed, drugTargetSymbol))
pathwayMatches <- merge(x=pathwayMatches, by.x="drugTargetSymbol", y=edges, by.y="to")
pathwayMatches <- unique(dplyr::select(pathwayMatches,nct_id, interventions.processed, "downstream"="drugTargetSymbol","upstream"="from" ))
pathwayMatches <- as.data.frame(pathwayMatches %>%
group_by(nct_id, interventions.processed, upstream) %>%
summarise(
downstream = paste(unique(downstream), collapse = ", ")
))
paste0("Study drug (", pathwayMatches$interventions.processed, ") targets downstream gene(s) (", pathwayMatches$downstream, ")")
unique(dplyr::select(cancerStudies, nct_id, interventions))
pathwayMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
merge(x=pathwayMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
pathwayMatches <- merge(x=pathwayMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
pathwayMatches[!is.na(pathwayMatches$drugTargetSymbol), ]
pathwayMatches <- pathwayMatches[!is.na(pathwayMatches$drugTargetSymbol), ]
unique(dplyr::select(pathwayMatches, nct_id, interventions.processed, drugTargetSymbol))
pathwayMatches <- unique(dplyr::select(pathwayMatches, nct_id, interventions.processed, drugTargetSymbol))
merge(x=pathwayMatches, by.x="drugTargetSymbol", y=edges, by.y="to")
View(edges)
head(pathwayMatches)
View(drugs.targets)
View(targets)
targets$drugTargetID[i]
targets$drugTargetID[1]
i <- 1
targets$drugTargetID[i]
keggGet(targetId)[[1]]$NAME[1]},
error=function(cond) {return(NA)})
keggGet(targetId)[[1]]$NAME[1]
keggGet(targetId)[[1]]
keggGet(targetId)[[1]]$SYMBOL[1]
i <- 12
targets$drugTargetID[i]
keggGet(targetId)[[1]]$SYMBOL[1]
keggGet("hsa:238")[[1]]$SYMBOL[1]
keggGet("hsa:2099")[[1]]$SYMBOL[1]
keggGet("hsa:207")[[1]]$SYMBOL[1]
name <- keggGet("hsa:207")[[1]]$SYMBOL[1]
name
strsplit(name, split = ", ")
unlist(strsplit(name, split = ", "))
class(unlist(strsplit(name, split = ", ")))
strsplit(name, split = ", ")[1]
strsplit(name, split = ", ")[[1]
}
strsplit(name, split = ", ")[[1]]
strsplit(name, split = ", ")[[1]][1]
rm(list = ls())
rmarkdown::render("trialMatchDataRefresh.Rmd")
View(indexed.eligibilities)
View(eligibilities)
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
eligibilities2 <- dbGetQuery(conn2,getEligibilities)
i <- 1
criteria <- as.character(eligibilities$criteria[i])
criteria
unlist(strsplit(criteria, split = "\r\n\r\n"))
criteria <- as.character(eligibilities2$criteria[i])
criteria
unlist(strsplit(criteria, split = "\n\n"))
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
i <- 1
criteria <- as.character(eligibilities2$criteria[i])
eligibilities2 <- dbGetQuery(conn2,getEligibilities)
criteria <- as.character(eligibilities2$criteria[i])
criteria
unlist(strsplit(criteria, split = "\n\n"))
names(eligibilities2)
criteria <- as.character(eligibilities2$criteria[eligibilities2$nct_id == "NCT03875820"])
criteria
unlist(strsplit(criteria, split = "\n\n"))
unlist(strsplit(criteria, split = "\n"))
strsplit(criteria, split = "\n")
unlist(strsplit(criteria, split = "\n"))
criteria <- unlist(strsplit(criteria, split = "\n"))
criteria
criteria[criteria != ""]
criteria <- criteria[criteria != ""] ## drop empty elements
class(criteria)
length(criteria)
criteria
dbDisconnect(conn2)
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
