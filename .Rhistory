require(kableExtra)
require(ggplot2)
require(reshape2)
require(arsenal)
require(httr)
require(forestmodel)
require(gridExtra)
require(caret)
require(rattle)
require(expss)
## clean up environment before starting
rm(list=ls())
## filepath for local production data
localFilepath <-"C:/Users/O’ReganPaul/Downloads"
## 3 March 2021 data cut, taken from /reactdata/observational/ReactUpload
demographics <- read.csv(file = paste(localFilepath,"REACT_Demographics_3Mar21.csv", sep = "/"), stringsAsFactors = FALSE, header = TRUE)
# convert gender from 0 and 1 to M and F
demographics$GENDER <- ifelse(demographics$GENDER==0, yes = "Male", no="Female")
## convert READM28 to logical
demographics$READM28 <- as.logical(demographics$READM28)
## format datetime fields as simple dates
demographics$ADMIT_DATETIME <- as.Date(demographics$ADMIT_DATETIME,  format = "%Y-%m-%d")
demographics$FIRST_POS_DATE <- as.Date(demographics$FIRST_POS_DATE,  format = "%Y-%m-%d")
demographics$DISCHARGEDATE <- as.Date(demographics$DISCHARGEDATE,  format = "%Y-%m-%d")
demographics$READM_DATETIME <- as.Date(demographics$READM_DATETIME,  format = "%Y-%m-%d")
demographics$DATE_OF_DEATH <- as.Date(demographics$DATE_OF_DEATH,  format = "%Y-%m-%d")
## add a column to indicate whether died
demographics$DIED <- !is.na(demographics$DATE_OF_DEATH)
## rename event columns appropriately
demographics <- rename(.data=demographics, "POS_TEST" = "FIRST_POS_DATE", "ADMISSION"="ADMIT_DATETIME", "DISCHARGE"="DISCHARGEDATE", "READMISSION"="READM_DATETIME", "DEATH"="DATE_OF_DEATH")
## create a table of demographic events
demographic.events <- unique(dplyr::select(demographics, STUDY_ID, POS_TEST, ADMISSION, DISCHARGE, READMISSION, DEATH))
# melt into tall format
demographic.events <- reshape2::melt(demographic.events,id.var="STUDY_ID", variable.name="EVENT", value.name = "EVENT_DATE", na.rm=TRUE)
## rename READMISSION to just ADMISSION
demographic.events$EVENT <- gsub(pattern = "READMISSION", replacement = "ADMISSION", x= demographic.events$EVENT)
# drop redundant rows
demographic.events <- unique(demographic.events)
# order by STUDY_ID then by EVENT_DATE
demographic.events <- dplyr::arrange(.data = demographic.events, STUDY_ID, EVENT_DATE)
## add an age group column
demographics$AGE_GROUP <- cut(demographics$PATIENT_AGE, breaks = c(-1,39,69,120))
## drop unused columns, reorder remaining columns
demographics <- unique(dplyr::select(demographics, STUDY_ID, GENDER, PATIENT_AGE, AGE_GROUP,  HEIG, WEIG, BMI, DIED))
## filter and retain only first infection
#demographics <- filter(demographics, INFECTION_NO == 1)
## indicate whether died within 28 days of first positive test
# demographics$DIED28 <- (demographics$DATE_OF_DEATH - demographics$FIRST_POS_DATE) <28
# # convert NA to FALSE
# demographics$DIED28[is.na(demographics$DIED28)] <- FALSE
## According to CDC, positive PCR during a 90-day time frame probably represents prolonged shedding rather than reinfection
## (taken from https://www.clinicalmicrobiologyandinfection.com/article/S1198-743X(20)30724-2/fulltext)
infections <- unique(dplyr::filter(demographic.events, EVENT=="POS_TEST"))
## add an index column
infections <- as.data.frame(infections %>%
group_by(STUDY_ID) %>%
mutate(TEST_NO = row_number()))
## cast into wide format (don't use reshape2::dcast as doesn't format dates correctly)
#infections <-  tidyr::spread(infections,TEST_NO, EVENT_DATE)
## classify infection numbers based on a cutoff of 90 days
new.infection.cutoff <- 90
lineage <- read.csv(file = paste(localFilepath, "REACT_lineage.csv", sep = "/"), stringsAsFactors = FALSE, header = TRUE, na.strings = "")
## drop rows where LINEAGE is either "No sequence" or NA
lineage <- lineage[!is.na(lineage$LINEAGE), ]
lineage <- lineage[lineage$LINEAGE != "No sequence", ]
## classify as either "KENT", "SA", "INDIA" or "OTHER"
lineage$STRAIN <- ifelse(test=lineage$LINEAGE == "B.1.1.7", yes = "KENT", no=ifelse(test = lineage$LINEAGE == "B.1.351", yes = "SA", no = ifelse(test = lineage$LINEAGE == "B.1.617", yes = "INDIA", no="OTHER")))
lineage.summary <- as.data.frame(lineage %>%
group_by(STUDY_ID) %>%
summarise(
LINEAGES = paste(unique(LINEAGE), collapse = ", "),
STRAINS = paste(unique(STRAIN), collapse = ", ")
))
## see if there are any SAMPLE_DATE values in lineage that are not in infections$EVENT_DATE
# (i.e. are all lineage samples associated with a positive test date?)
#setdiff(x=lineage$SAMPLE_DATE, y=infections$EVENT_DATE)
## join lineage data to infections table
infections <- merge(x=infections, by.x = c("STUDY_ID", "EVENT_DATE"), all.x = TRUE, y=unique(dplyr::select(lineage, STUDY_ID, SAMPLE_DATE, LINEAGE, STRAIN)), by.y = c("STUDY_ID", "SAMPLE_DATE"), all.y = TRUE)
## fill missing values "down"
infections <- as.data.frame(infections %>%
dplyr::group_by(STUDY_ID) %>%
tidyr::fill(c(LINEAGE, STRAIN, TEST_NO), .direction = "down") %>%
dplyr::ungroup())
## now fill "up"
infections <- as.data.frame(infections %>%
dplyr::group_by(STUDY_ID) %>%
tidyr::fill(c(LINEAGE, STRAIN, TEST_NO), .direction = "up") %>%
dplyr::ungroup())
## if no lineage data, assume "OTHER" for positive tests before a defined cutoff
# Kent variant was first detected in October 2020
kent.variant.cutoff.date <- as.Date("2020-10-01")
infections$STRAIN <- ifelse(test = is.na(infections$LINEAGE) & infections$EVENT_DATE < kent.variant.cutoff.date, yes = "OTHER")
infections$STRAIN[is.na(infections$LINEAGE) & infections$EVENT_DATE < kent.variant.cutoff.date]
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
require(dplyr)
require(formattable)
require(kableExtra)
require(ggplot2)
require(reshape2)
require(arsenal)
require(httr)
require(forestmodel)
require(gridExtra)
require(caret)
require(rattle)
require(expss)
## clean up environment before starting
rm(list=ls())
## filepath for local production data
localFilepath <-"C:/Users/O’ReganPaul/Downloads"
## 3 March 2021 data cut, taken from /reactdata/observational/ReactUpload
demographics <- read.csv(file = paste(localFilepath,"REACT_Demographics_3Mar21.csv", sep = "/"), stringsAsFactors = FALSE, header = TRUE)
# convert gender from 0 and 1 to M and F
demographics$GENDER <- ifelse(demographics$GENDER==0, yes = "Male", no="Female")
## convert READM28 to logical
demographics$READM28 <- as.logical(demographics$READM28)
## format datetime fields as simple dates
demographics$ADMIT_DATETIME <- as.Date(demographics$ADMIT_DATETIME,  format = "%Y-%m-%d")
demographics$FIRST_POS_DATE <- as.Date(demographics$FIRST_POS_DATE,  format = "%Y-%m-%d")
demographics$DISCHARGEDATE <- as.Date(demographics$DISCHARGEDATE,  format = "%Y-%m-%d")
demographics$READM_DATETIME <- as.Date(demographics$READM_DATETIME,  format = "%Y-%m-%d")
demographics$DATE_OF_DEATH <- as.Date(demographics$DATE_OF_DEATH,  format = "%Y-%m-%d")
## add a column to indicate whether died
demographics$DIED <- !is.na(demographics$DATE_OF_DEATH)
## rename event columns appropriately
demographics <- rename(.data=demographics, "POS_TEST" = "FIRST_POS_DATE", "ADMISSION"="ADMIT_DATETIME", "DISCHARGE"="DISCHARGEDATE", "READMISSION"="READM_DATETIME", "DEATH"="DATE_OF_DEATH")
## create a table of demographic events
demographic.events <- unique(dplyr::select(demographics, STUDY_ID, POS_TEST, ADMISSION, DISCHARGE, READMISSION, DEATH))
# melt into tall format
demographic.events <- reshape2::melt(demographic.events,id.var="STUDY_ID", variable.name="EVENT", value.name = "EVENT_DATE", na.rm=TRUE)
## rename READMISSION to just ADMISSION
demographic.events$EVENT <- gsub(pattern = "READMISSION", replacement = "ADMISSION", x= demographic.events$EVENT)
# drop redundant rows
demographic.events <- unique(demographic.events)
# order by STUDY_ID then by EVENT_DATE
demographic.events <- dplyr::arrange(.data = demographic.events, STUDY_ID, EVENT_DATE)
## add an age group column
demographics$AGE_GROUP <- cut(demographics$PATIENT_AGE, breaks = c(-1,39,69,120))
## drop unused columns, reorder remaining columns
demographics <- unique(dplyr::select(demographics, STUDY_ID, GENDER, PATIENT_AGE, AGE_GROUP,  HEIG, WEIG, BMI, DIED))
## filter and retain only first infection
#demographics <- filter(demographics, INFECTION_NO == 1)
## indicate whether died within 28 days of first positive test
# demographics$DIED28 <- (demographics$DATE_OF_DEATH - demographics$FIRST_POS_DATE) <28
# # convert NA to FALSE
# demographics$DIED28[is.na(demographics$DIED28)] <- FALSE
## According to CDC, positive PCR during a 90-day time frame probably represents prolonged shedding rather than reinfection
## (taken from https://www.clinicalmicrobiologyandinfection.com/article/S1198-743X(20)30724-2/fulltext)
infections <- unique(dplyr::filter(demographic.events, EVENT=="POS_TEST"))
## add an index column
infections <- as.data.frame(infections %>%
group_by(STUDY_ID) %>%
mutate(TEST_NO = row_number()))
## cast into wide format (don't use reshape2::dcast as doesn't format dates correctly)
#infections <-  tidyr::spread(infections,TEST_NO, EVENT_DATE)
## classify infection numbers based on a cutoff of 90 days
new.infection.cutoff <- 90
lineage <- read.csv(file = paste(localFilepath, "REACT_lineage.csv", sep = "/"), stringsAsFactors = FALSE, header = TRUE, na.strings = "")
## drop rows where LINEAGE is either "No sequence" or NA
lineage <- lineage[!is.na(lineage$LINEAGE), ]
lineage <- lineage[lineage$LINEAGE != "No sequence", ]
## classify as either "KENT", "SA", "INDIA" or "OTHER"
lineage$STRAIN <- ifelse(test=lineage$LINEAGE == "B.1.1.7", yes = "KENT", no=ifelse(test = lineage$LINEAGE == "B.1.351", yes = "SA", no = ifelse(test = lineage$LINEAGE == "B.1.617", yes = "INDIA", no="OTHER")))
lineage.summary <- as.data.frame(lineage %>%
group_by(STUDY_ID) %>%
summarise(
LINEAGES = paste(unique(LINEAGE), collapse = ", "),
STRAINS = paste(unique(STRAIN), collapse = ", ")
))
## see if there are any SAMPLE_DATE values in lineage that are not in infections$EVENT_DATE
# (i.e. are all lineage samples associated with a positive test date?)
#setdiff(x=lineage$SAMPLE_DATE, y=infections$EVENT_DATE)
## join lineage data to infections table
infections <- merge(x=infections, by.x = c("STUDY_ID", "EVENT_DATE"), all.x = TRUE, y=unique(dplyr::select(lineage, STUDY_ID, SAMPLE_DATE, LINEAGE, STRAIN)), by.y = c("STUDY_ID", "SAMPLE_DATE"), all.y = TRUE)
## fill missing values "down"
infections <- as.data.frame(infections %>%
dplyr::group_by(STUDY_ID) %>%
tidyr::fill(c(LINEAGE, STRAIN, TEST_NO), .direction = "down") %>%
dplyr::ungroup())
## now fill "up"
infections <- as.data.frame(infections %>%
dplyr::group_by(STUDY_ID) %>%
tidyr::fill(c(LINEAGE, STRAIN, TEST_NO), .direction = "up") %>%
dplyr::ungroup())
## if no lineage data, assume "OTHER" for positive tests before a defined cutoff
# Kent variant was first detected in October 2020
kent.variant.cutoff.date <- as.Date("2020-10-01")
infections$STRAIN[is.na(infections$LINEAGE) & infections$EVENT_DATE < kent.variant.cutoff.date] <-  "OTHER"
## where sequencing sample date does not match positive test date, set EVENT value
infections$EVENT[is.na(infections$EVENT)] <- "SEQUENCING"
infections$STRAIN[is.na(infections$STRAIN)] <- "UNKNOWN"
head(infections)
infections.summary <- as.data.frame(infections %>%
group_by(STUDY_ID) %>%
summarise(
STRAINS = paste(unique(STRAIN), collapse = ", ")
))
View(infections.summary)
unique(infections.summary$STRAINS)
head(infections)
head(demographic.events)
unique(dplyr::select(demographics, STUDY_ID, FIRST_POS_DATE, DATE_OF_DEATH))
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
require(dplyr)
require(formattable)
require(kableExtra)
require(ggplot2)
require(reshape2)
require(arsenal)
require(httr)
require(forestmodel)
require(gridExtra)
require(caret)
require(rattle)
require(expss)
## clean up environment before starting
rm(list=ls())
## filepath for local production data
localFilepath <-"C:/Users/O’ReganPaul/Downloads"
## 3 March 2021 data cut, taken from /reactdata/observational/ReactUpload
demographics <- read.csv(file = paste(localFilepath,"REACT_Demographics_3Mar21.csv", sep = "/"), stringsAsFactors = FALSE, header = TRUE)
# convert gender from 0 and 1 to M and F
demographics$GENDER <- ifelse(demographics$GENDER==0, yes = "Male", no="Female")
## convert READM28 to logical
demographics$READM28 <- as.logical(demographics$READM28)
## format datetime fields as simple dates
demographics$ADMIT_DATETIME <- as.Date(demographics$ADMIT_DATETIME,  format = "%Y-%m-%d")
demographics$FIRST_POS_DATE <- as.Date(demographics$FIRST_POS_DATE,  format = "%Y-%m-%d")
demographics$DISCHARGEDATE <- as.Date(demographics$DISCHARGEDATE,  format = "%Y-%m-%d")
demographics$READM_DATETIME <- as.Date(demographics$READM_DATETIME,  format = "%Y-%m-%d")
demographics$DATE_OF_DEATH <- as.Date(demographics$DATE_OF_DEATH,  format = "%Y-%m-%d")
## add a column to indicate whether died
demographics$DIED <- !is.na(demographics$DATE_OF_DEATH)
unique(dplyr::select(demographics, STUDY_ID, FIRST_POS_DATE, DATE_OF_DEATH))
dplyr::arrange(.data = first.pos.dates, STUDY_ID, FIRST_POS_DATE)
first.pos.dates <- unique(dplyr::select(demographics, STUDY_ID, FIRST_POS_DATE, DATE_OF_DEATH))
dplyr::arrange(.data = first.pos.dates, STUDY_ID, FIRST_POS_DATE)
first.pos.dates <- dplyr::arrange(.data = first.pos.dates, STUDY_ID, FIRST_POS_DATE)
as.data.frame(first.pos.dates %>%
group_by(STUDY_ID, DATE_OF_DEATH) %>%
summarise(
FIRST_POS_DATE = FIRST_POS_DATE[1]
))
first.pos.dates <- as.data.frame(first.pos.dates %>%
group_by(STUDY_ID, DATE_OF_DEATH) %>%
summarise(
FIRST_POS_DATE = FIRST_POS_DATE[1]
))
first.pos.dates$DIED28 <- (first.pos.dates$DATE_OF_DEATH - first.pos.dates$FIRST_POS_DATE) <28
View(first.pos.dates)
first.pos.dates$DIED28[is.na(first.pos.dates$DIED28)] <- FALSE
head(lineage)
lineage <- read.csv(file = paste(localFilepath, "REACT_lineage.csv", sep = "/"), stringsAsFactors = FALSE, header = TRUE, na.strings = "")
## drop rows where LINEAGE is either "No sequence" or NA
lineage <- lineage[!is.na(lineage$LINEAGE), ]
lineage <- lineage[lineage$LINEAGE != "No sequence", ]
## classify as either "KENT", "SA", "INDIA" or "OTHER"
lineage$STRAIN <- ifelse(test=lineage$LINEAGE == "B.1.1.7", yes = "KENT", no=ifelse(test = lineage$LINEAGE == "B.1.351", yes = "SA", no = ifelse(test = lineage$LINEAGE == "B.1.617", yes = "INDIA", no="OTHER")))
merge(x=first.pos.dates, by.x = c("STUDY_ID", "FIRST_POS_DATE"), all.x = TRUE, y=unique(dplyr::select(lineage, STUDY_ID, SAMPLE_DATE, LINEAGE, STRAIN)), by.y = c("STUDY_ID", "SAMPLE_DATE"), all.y = TRUE)
merge(x=first.pos.dates, by.x = c("STUDY_ID"), all.x = TRUE, y=unique(dplyr::select(lineage, STUDY_ID, SAMPLE_DATE, LINEAGE, STRAIN)), by.y = c("STUDY_ID"), all.y = TRUE)
rmarkdown::render("UHS_COVID_wave2_V2.Rmd")
merge(x=first.pos.dates, by.x = c("STUDY_ID"), all.x = TRUE, y=unique(dplyr::select(lineage, STUDY_ID, SAMPLE_DATE, LINEAGE, STRAIN)), by.y = c("STUDY_ID"), all.y = TRUE)
rmarkdown::render("UHS_COVID_wave2_V2.Rmd")
getwd()
setwd("C:/Users/O’ReganPaul/Documents/GitHub")
setwd("cancer-trial-match")
getwd()
rm(list=ls())
rmarkdown::render("trialMatchDataRefresh.Rmd")
indexOnPattern(eligibilities = eligibilities, pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function", wordRange = 6, featureLabel = "mutation")
names(eligibilities)
table <- eligibilities
pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function"
wordRange = 6
featureLabel = "mutation"
indices <- grep(pattern = pattern, x=table$criteria, ignore.case = T)
table <- table[indices, ]
table$feature <- featureLabel
for(i in 1:nrow(table)) {
criterion <- table$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - wordRange
ends <- indices + wordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) table$match[i] <- list(criterion)
}
table
names(table)
## drop rows not indexed against a gene
table <- table[!is.na(table$match), ]
## unnest
table <- as.data.frame(unnest(table, cols = "match"))
head(table)
names(humanGenes)
table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
names(table)
head(rename(table, "controlled.match"="Symbol"))
?rename
table$controlled.match <- table$Symbol
table <- dplyr::select(table, -Symbol)
names(table)
indexOnPattern <- function(eligibilities, pattern, wordRange, featureLabel) {
table <- eligibilities
pattern <- pattern
wordRange <- wordRange
featureLabel <- featureLabel
## get indices containing specified pattern
indices <- grep(pattern = pattern, x=table$criteria, ignore.case = T)
# subset table
table <- table[indices, ]
# label nature of change
table$feature <- featureLabel
## loop through each criterion that contains pattern
for(i in 1:nrow(table)) {
criterion <- table$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - wordRange
ends <- indices + wordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) table$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
table <- table[!is.na(table$match), ]
## unnest
table <- as.data.frame(unnest(table, cols = "match"))
## join to Entrez symbols from humanGenes
table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
## rename Symbol to "controlled.match"
# using rename gives unreliable results (?!)
#table <- rename(table, "controlled.match"="Symbol")
table$controlled.match <- table$Symbol
table <- dplyr::select(table, -Symbol)
## drop redundant rows
table <- unique(table)
## return table
return(table)
}
indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement|truncation|truncated|deletion|deleted|lost|duplication|duplicated", wordRange = 6, featureLabel = "rearrangement")
rearrangement.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement|truncation|truncated|deletion|deleted|lost|duplication|duplicated", wordRange = 6, featureLabel = "rearrangement")
View(rearrangement.eligibilities)
fusion.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement", wordRange = 7, featureLabel = "fusion")
View(fusion.eligibilities)
rmarkdown::render("trialMatchDataRefresh.Rmd")
rm(list = ls())
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rename(targetMatches,"symbol"= "drugTargetSymbol")
targetMatches$symbol <- targetMatches$drugTargetSymbol
targetMatches <- dplyr::select(targetMatches, -drugTargetSymbol)
names(targetMatches)
targetMatches$intervention_score <- 2
## start with studies and their interventions
pathwayMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
## join to drugs.targets on intervention name (verbatim)
pathwayMatches <- merge(x=pathwayMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
## drop rows where drugTargetSymbol is NA
pathwayMatches <- pathwayMatches[!is.na(pathwayMatches$drugTargetSymbol), ]
## drop unnecessary columns
pathwayMatches <- unique(dplyr::select(pathwayMatches, nct_id, interventions.processed, drugTargetSymbol))
## join to edges, where drugTargetSymbol == to
## i.e. intervention targets the downstream node
pathwayMatches <- merge(x=pathwayMatches, by.x="drugTargetSymbol", y=edges, by.y="to")
## select and rename columns
pathwayMatches <- unique(dplyr::select(pathwayMatches,nct_id, interventions.processed, "downstream"="drugTargetSymbol","upstream"="from" ))
## where an intervention targets >1 gene, aggregate
pathwayMatches <- as.data.frame(pathwayMatches %>%
group_by(nct_id, interventions.processed, upstream) %>%
summarise(
downstream = paste(unique(downstream), collapse = ", ")
))
## add rationale column
pathwayMatches$intervention_rationale <- paste0("Study drug (", pathwayMatches$interventions.processed, ") targets downstream gene(s) (", pathwayMatches$downstream, ")")
## drop intervention column
pathwayMatches <- unique(dplyr::select(pathwayMatches, -c(interventions.processed, downstream)))
## rename upstream column to drugTargetSymbol to match targetMatches
pathwayMatches <- rename(pathwayMatches, "symbol"="upstream")
dplyr::rename(pathwayMatches, "symbol"="upstream")
pathwayMatches$symbol <- pathwayMatches$upstream
pathwayMatches <- dplyr::select(pathwayMatches, -upstream)
names(pathwayMatches)
pathwayMatches$intervention_score <- 1
scoredMatches <- rbind(targetMatches, pathwayMatches)
## for genes that don't have a match in eligilityMatches, we want to be able to match on gene alone, regardless of variant_type...
scoredMatches$variant_type <- list(c("mutation", "rearrangement", "loss", "amplification"))
## unnest to multiply rows
scoredMatches <- data.frame(unnest(scoredMatches, cols = "variant_type"))
## start with indexed eligibilities
eligibilityMatches <- unique(dplyr::select(indexed.eligibilities, nct_id,"gene"="controlled.match",criterion.type, feature, criteria ))
## filter out matches against exclusion criteria
eligibilityMatches <- filter(eligibilityMatches, criterion.type=="INCLUSION")
## filter out matches against prior therapy
eligibilityMatches <- filter(eligibilityMatches, feature!="PRIOR_THERAPY")
## concatenate gene and feature
# eligibilityMatches$gene <- paste(eligibilityMatches$gene, eligibilityMatches$feature, sep = " ")
## add rationale column
eligibilityMatches$eligibility_rationale <- paste0("Enrolling subjects with ", eligibilityMatches$gene, " ", eligibilityMatches$feature)
## add a score
eligibilityMatches$eligibility_score <- 3
## where multiple criteria, aggregate
eligibilityMatches <- as.data.frame(eligibilityMatches %>%
group_by(nct_id, gene, criterion.type, feature, eligibility_rationale, eligibility_score) %>%
summarise(
criteria = paste(unique(criteria), collapse = "\n\n")
))
## select and rename columns to match targetMatches and pathwayMatches
eligibilityMatches <- unique(dplyr::select(eligibilityMatches, nct_id, "symbol"="gene", "variant_type" = "feature", eligibility_rationale, "matching_criteria"="criteria", eligibility_score))
scoredMatches <- merge(x=scoredMatches, by.x=c("nct_id", "symbol", "variant_type"), all.x=TRUE,
y=eligibilityMatches, by.y = c("nct_id", "symbol", "variant_type"), all.y=TRUE)
## add a combined score
scoredMatches$combined_score <- rowSums(scoredMatches[,c("intervention_score", "eligibility_score")], na.rm=TRUE)
## conatenate symbol and variant_type columns to get <gene name> <variant_type>, e.g. "EGFR mutation"
scoredMatches$gene_variant_type <- paste(scoredMatches$symbol, scoredMatches$variant_type, sep=" ")
## select and reorder columns
scoredMatches <- unique(dplyr::select(scoredMatches, symbol, variant_type,gene_variant_type, nct_id, intervention_rationale, eligibility_rationale, matching_criteria, combined_score))
## order on combined_score descending
scoredMatches <- scoredMatches[order(scoredMatches$combined_score, decreasing = TRUE), ]
## preview
formattable(head(scoredMatches,10))
getwd()
scoredMatches <- rbind(targetMatches, pathwayMatches)
## for genes that don't have a match in eligilityMatches, we want to be able to match on gene alone, regardless of variant_type...
scoredMatches$variant_type <- list(c("mutation", "rearrangement", "loss", "amplification"))
## unnest to multiply rows
scoredMatches <- data.frame(unnest(scoredMatches, cols = "variant_type"))
## start with indexed eligibilities
eligibilityMatches <- unique(dplyr::select(indexed.eligibilities, nct_id,"gene"="controlled.match",criterion.type, feature, criteria ))
## filter out matches against exclusion criteria
eligibilityMatches <- filter(eligibilityMatches, criterion.type=="INCLUSION")
## filter out matches against prior therapy
eligibilityMatches <- filter(eligibilityMatches, feature!="PRIOR_THERAPY")
## concatenate gene and feature
# eligibilityMatches$gene <- paste(eligibilityMatches$gene, eligibilityMatches$feature, sep = " ")
## add rationale column
eligibilityMatches$eligibility_rationale <- paste0("Enrolling subjects with ", eligibilityMatches$gene, " ", eligibilityMatches$feature)
## add a score
eligibilityMatches$eligibility_score <- 3
## where multiple criteria, aggregate
eligibilityMatches <- as.data.frame(eligibilityMatches %>%
group_by(nct_id, gene, criterion.type, feature, eligibility_rationale, eligibility_score) %>%
summarise(
criteria = paste(unique(criteria), collapse = "\n\n")
))
## select and rename columns to match targetMatches and pathwayMatches
eligibilityMatches <- unique(dplyr::select(eligibilityMatches, nct_id, "symbol"="gene", "variant_type" = "feature", eligibility_rationale, "matching_criteria"="criteria", eligibility_score))
scoredMatches <- merge(x=scoredMatches, by.x=c("nct_id", "symbol", "variant_type"), all.x=TRUE,
y=eligibilityMatches, by.y = c("nct_id", "symbol", "variant_type"), all.y=TRUE)
## add a combined score
scoredMatches$combined_score <- rowSums(scoredMatches[,c("intervention_score", "eligibility_score")], na.rm=TRUE)
## conatenate symbol and variant_type columns to get <gene name> <variant_type>, e.g. "EGFR mutation"
scoredMatches$gene_variant_type <- paste(scoredMatches$symbol, scoredMatches$variant_type, sep=" ")
## select and reorder columns
scoredMatches <- unique(dplyr::select(scoredMatches, symbol, variant_type,gene_variant_type, nct_id, intervention_rationale, eligibility_rationale, matching_criteria, combined_score))
## order on combined_score descending
scoredMatches <- scoredMatches[order(scoredMatches$combined_score, decreasing = TRUE), ]
## preview
formattable(head(scoredMatches,10))
rm(list=ls())
rmarkdown::render("trialMatchDataRefresh.Rmd")
