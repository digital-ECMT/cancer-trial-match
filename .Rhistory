)
sqrt(mean((predict(lm1,newdata = testFaith)-testFaith$eruptions)^2))
sqrt(mean((predict(lm1,newdata = trainFaith)-trainFaith$eruptions)^2))
pred1 <- predict(lm1, newdata = testFaith, interval = "prediction")
class(pred1)
ord <- order(testFaith$waiting)
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue") ## plot actual values in test set
matlines(testFaith$waiting[ord], pred1[ord], type = "l", col = c(1,2,2), lty = c(1,1,1), lwd = 3) ## add lines with predicted values and prediction intervals
matlines(testFaith$waiting[ord], pred1[ord, ], type = "l", col = c(1,2,2), lty = c(1,1,1), lwd = 3) ## add lines with predicted values and prediction intervals
ord
pred1
pred1[ord, ] ## reorder on waiting time
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue") ## plot actual values in test set
matlines(testFaith$waiting, pred1 , type = "l", col = c(1,2,2), lty = c(1,1,1), lwd = 3) ## add lines with predicted values and prediction intervals
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue") ## plot actual values in test set
matlines(testFaith$waiting[ord], pred1[ord, ], type = "l", col = c(1,2,2), lty = c(1,1,1), lwd = 3) ## add lines with predicted values and prediction intervals
modFit <- train(eruptions ~ waiting, data=trainFaith, method="lm")
summary(modFit$finalModel)
predict(modFit, newdata)
pred2 <- predict(modFit, newdata = testFaith, interval="prediction")
head(pred2)
predict(modFit, newdata = testFaith, interval="prediction")
predict(modFit$finalModel, newdata = testFaith, interval="prediction")
pred2 <- predict(modFit$finalModel, newdata = testFaith, interval="prediction")
head(pred2)
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue") ## plot actual values in test set
matlines(testFaith$waiting, pred2, type = "l", col = c(1,2,2), lty = c(1,1,1), lwd = 3)
?train
library(ISLR)
data("Wage")
Wage <- subset(Wage, select = -c(logwage))
inTrain <- createDataPartition(y-Wage$wage, p=0.7, list = FALSE)
inTrain <- createDataPartition(y=Wage$wage, p=0.7, list = FALSE)
training <- Wage[inTrain, ]
testing <- Wage[-inTrain, ]
qplot(age, wage, colour=jobclass, data=training)  ## exploratory plot
qplot(age, wage, colour=education, data=training)  ## exploratory plot
modeFit <- train(wage ~ age + jobclass + education,
method = "lm",
data=training)
finMod <- modFit$finalModel
print(modFit)
modFit <- train(wage ~ age + jobclass + education,
method = "lm",
data=training)
finMod <- modFit$finalModel
print(modFit)
plot(finMod, pch=19, cex=0.5,col="#00000010")
qplot(finMod$fitted.values, finMod$residuals, colour=race, data=training)
plot(finMod$residuals, pch=19)
library(AppliedPredictiveModeling)
install.packages("AppliedPredictiveModeling")
library(AppliedPredictiveModeling)
data(AlzheimerDisaease)
data(AlzheimerDisease)
data("concrete")
set.seed(1000)
inTrain <- createDataPartition(mixtures$CompressiveStrength, p=3/4)[[1]]
training <- mixtures[inTrain, ]
testing <- mixtures[-inTrain, ]
qplot(training$CompressiveStrength)
plot(training$CompressiveStrength)
names(training)
plot(training$CompressiveStrength, colour="Cement")
qplot(training$CompressiveStrength, colour="Cement")
qplot(training$CompressiveStrength,seq_along(training$CompressiveStrength) colour="Cement")
qplot(training$CompressiveStrength,seq_along(training$CompressiveStrength), colour="Cement")
plot(training$CompressiveStrength, colour="Cement")
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour="Cement")
names(training)
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour="BlastFurnaceSlag")
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour="FlyAsh")
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour=Cement)
unique(training$Cement)
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour="Cement")
?cut2
libary(Hmisc)
library(Hmisc)
?cut2
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour=cut2(training$Cement))
head(training)
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour=cut2(training$BlastFurnaceSlag))
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour=cut2(training$FlyAsh))
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour=cut2(training$Water))
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour=cut2(training$Age))
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength)
qplot(seq_along(training$CompressiveStrength),training$CompressiveStrength, colour=cut2(training$FlyAsh))
qplot(training$Superplasticizer)
log(training$Superplasticizer)
set.seed(3433)
adData <- data.frame(diagnosis, predictors)
inTrain <- createDataPartition(adData$diagnosis, p=3/4)[[1]]
training <- adData[inTrain, ]
testing <- adData[-inTrain, ]
names(training)
grep(pattern = "IL", x=names(training))
head(training[ ,grep(pattern = "IL", x=names(training))])
head(training[ ,grep(pattern = "^IL", x=names(training))])
subTraining <- training[ ,grep(pattern = "^IL", x=names(training))]
prComp <- prcomp(subTraining)
head(prComp)
summary(prComp)
preObj <- preProcess(training[ ,grep(pattern = "^IL", x=names(training))])
summary(preObj)
class(preObj)
preObj$rotation
set.seed(3433)
data(AlzheimerDisease)
names(training)
rm(list=ls())
rm(list=ls())
data("iris")
library(caret)
inTrain <- createDataPartition(y=iris$Species, p=0.7, list=FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]
modFit <- train(Species ~ ., data=training, method="rf", prox=TRUE)
modFit <- train(Species ~ ., data=training, method="rf", prox=TRUE)
modFit
getTree(modFit$finalModel, k=2)
library(randomForest)
getTree(modFit$finalModel, k=2)
irisP <- classCenter(training[ ,c(3,4)], training$Species, modFit$finalModel$proximity)
class(irisP)
irisP <- as.data.frame(irisP)
head(irisP)
irisP
irisP$Species <- rownames(irisP)
irisP
p <- qplot(Petal.Width, Petal.Length, col=Species, data=training)
p+ geom_point(aes(x=Petal.Width, y=Petal.Length, col=Species), size=5, shape=4, data=irisP)
pred <- predict(modFit, testing)
testing$predRight <- pred==testing$Species
table(pred, testing$Species)
qplot(Petal.Width, Petal.Length, colour=predRight,data=testing, main="newdata Predictions")
rm(list=ls())
library(caret)
data("iris")
head(iris)
inTrain <- createDataPartition(y=iris$Species, p=0.7, list=FALSE)
training <- iris[inTrain, ]
testing <- iris[ -inTrain, ]
head(training)
sample(x=training, size=5, replace = TRUE)
?sample
X[sample(nrow(training),size=5,replace=TRUE),]
training[sample(nrow(training),size=5,replace=TRUE),]
training[sample(nrow(training),size=5,replace=TRUE),]
training[sample(nrow(training),size=5,replace=TRUE),]
training[sample(nrow(training),size=5,replace=TRUE),]  ## sample 5 rows from training dataset, all variables
training[sample(nrow(training),size=5,replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## sample 5 rows and 2 variables from training dataset
training[sample(nrow(training),size=5,replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## sample 5 rows and 2 variables from training dataset
training[sample(nrow(training),size=5,replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## sample 5 rows and 2 variables from training dataset
split0 <- training[sample(nrow(training),size=5,replace=TRUE),]  ## sample 5 rows from training dataset, all variables
split1 <- training[sample(nrow(training),size=5,replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## sample 5 rows and 2 variables from training dataset
split2 <- training[sample(nrow(training),size=5,replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## sample 5 rows and 2 variables from training dataset
install.packages("ineq")
library(ineq)
modFit <- train(Species ~ ., method="rpart", data=split0)
head(split0)
split0 <- training[sample(nrow(training),size=nrow(training),replace=TRUE),]  ## sample 5 rows from training dataset, all variables
modFit <- train(Species ~ ., method="rpart", data=split0)
library(rattle)
fancyRpartPlot(modFit$finalModel)
split(split0, Petal.Length < 2.6)
split(split0, split0$Petal.Length < 2.6)
split(split0, split0$Petal.Length < 2.6)[[1]]
split1.1 <- split(split0, split0$Petal.Length < 2.6)[[1]]
head(split1.1)
split1.2 <- split(split0, split0$Petal.Length < 2.6)[[2]]
head(split1.2)
split1.1 <- training[sample(nrow(training),size=nrow(split1.1),replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## resample all rows and 2 variables from the result of the first split
head(split1.1)
modFit <- train(Species ~ ., method="rpart", data=split1.1)
fancyRpartPlot(modFit$finalModel)
split2.1 <- split(split1.1, split1.1$Sepal.Length < 5.5)[[1]]
head(split2.1)
split2.2 <- split(split1.1, split1.1$Sepal.Length < 5.5)[[2]]
head(split2.2)
bootstrap1 <- training[sample(nrow(training),size=nrow(training),replace=TRUE),]  ## sample rows from training dataset, all variables
split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[1]]
split1.1 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[1]]
head(split1.1)
split1.2 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[2]]
split1.1 <- training[sample(nrow(training),size=nrow(split1.1),replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## resample all rows and 2 variables from the result of the first split
head(split1.1)
split1.2 <- training[sample(nrow(training),size=nrow(split1.2),replace=TRUE),c(sample(1:4,size=2,replace=TRUE),5)]  ## resample all rows and 2 variables from the result of the first split
head(split1.2)
available.for.split <- sample(names(split1.1)[1:4], size = 4, replace = TRUE))
sample(names(split1.1)[1:4], size = 4, replace = TRUE)
sample(names(split1.1)[1:4], size = 4, replace = TRUE)
sample(names(split1.1)[1:4], size = 4, replace = TRUE)
> split1.1 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[1]]
> split1.2 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[2]]
split1.1 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[1]]
split1.2 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[2]]
sample(names(split1.1)[1:4], size = 4, replace = TRUE)
sample(names(split1.1)[1:4], size = 4, replace = TRUE)
sample(names(split1.1)[1:4], size = 4, replace = TRUE)
available.for.split <- sample(names(split1.1)[1:4], size = 4, replace = TRUE)
available.for.split
head(split1.1)
head(split1.2)
?getTree
library(randomForest)
?getTree
modFit <- train(Species ~ ., data = training, method="rf", prox=TRUE)
getTree(modFit$finalModel, k=1)
class(getTree(modFit$finalModel, k=1))
fancyRpartPlot(getTree(modFit$finalModel, k=1))
cforest(Species ~ ., data=training, controls=cforest_control(mtry=2, mincriterion=0))
rm(list=ls())
data("iris")
library(caret)
inTrain <- createDataPartition(y=iris$Species, p=0.7, list=FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]
head(training)
> modFit <- train(Species ~ ., method="rpart", data=training) ## rpart is R's method for creating decision trees
modFit <- train(Species ~ ., method="rpart", data=training) ## rpart is R's method for creating decision trees
library(rattle)
fancyRpartPlot(modFit$finalModel) ## nicer looking plot
split1.1 <- split(training, Petal.Length<2.5)[[1]]
split1.1 <- split(training, training$Petal.Length<2.5)[[1]]
split1.2 <- split(training, training$Petal.Length<2.5)[[2]]
head(split1.1,10)
head(split1.2,10)
head(training,10)
table(iris$Species)
table(training$Species)
table(split1.1$Species)
table(split1.2$Species)
split2.1 <- split(split1.1, split1.1$Petal.Width<1.6)[[1]]
split2.2 <- split(split1.1, split1.1$Petal.Width<1.6)[[2]]
head(split2.1)
table(split2.1$Species)
head(split2.2)
table(split2.2$Species)
bootstrap1 <- training[sample(nrow(training),size=nrow(training),replace=TRUE),]
split1.1 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[1]]
table(split1.1$Species)
split1.2 <- split(bootstrap1, bootstrap1$Petal.Length < 2.6)[[2]]
table(split1.2$Species)
available.for.split <- sample(names(split1.1)[1:4], size = 4, replace = TRUE)
available.for.split
available.for.split <- sample(names(split1.1)[1:4], size = 4, replace = TRUE)
available.for.split
available.for.split <- sample(names(split1.1)[1:4], size = 4, replace = TRUE)
available.for.split
available.for.split <- sample(names(split1.1)[1:4], size = 4, replace = TRUE)
available.for.split
read.csv(file = "https://civicdb.org/downloads/nightly/nightly-ClinicalEvidenceSummaries.tsv", sep = "\t")
evidence <- read.csv(file = "https://civicdb.org/downloads/nightly/nightly-ClinicalEvidenceSummaries.tsv", sep = "\t")
dim(evidence)
names(evidence)
"H773_V774insAH" %in% evidence$variant
filter(evidence, gene=="EGFR")
library(dplyr)
filter(evidence, gene=="EGFR")
unique(filter(evidence, gene=="EGFR"))
unique(filter(evidence, gene=="EGFR"))$variant
sort(unique(filter(evidence, gene=="EGFR"))$variant)
sort(unique(filter(evidence, gene=="MYC"))$variant)
sort(unique(filter(evidence, gene=="MYC")))
unique(filter(evidence, gene=="MYC"))
sort(unique(filter(evidence, gene=="FGFR3"))$variant)
unique(filter(evidence, gene=="FGFR3"))
unique(filter(evidence, gene=="KRAS"))
unique(filter(evidence, gene=="KRAS"))$variant
sort(unique(filter(evidence, gene=="FGFR3")$variant))
sort(unique(filter(evidence, gene=="KRAS")$variant))
unique(filter(evidence, gene=="KRAS" & variant =="Q61R"))
unique(filter(evidence, gene=="KRAS" & variant =="Q61*"))
unique(filter(evidence, gene=="KRAS" & variant =="Q61.*"))
unique(filter(evidence, gene=="KRAS" & variant =="Q61*"))
unique(filter(evidence, gene=="KRAS" & variant =="Q61"))
rm(list=ls())
getwd()
?checkboxInput
?buttonInput
?actionButton
paste0("<input id='type1_",1:nrow(table), "' type='checkbox' >")
paste0("<input id='type1_",1:15, "' type='checkbox' >")
?observeEvent
shiny::runApp('GitHub/UHS_COVID/checkboxes')
runApp('GitHub/UHS_COVID/checkboxes')
runApp('GitHub/UHS_COVID/checkboxes')
runApp('GitHub/UHS_COVID/checkboxes')
runApp('GitHub/UHS_COVID/checkboxes')
data.frame(bins = c(30, 50), cb = c(T, F))
?datatable
head(humanGenes)
humanGenes[0,]
## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password
drv <- dbDriver("PostgreSQL")
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
library(rjson)
## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password
drv <- dbDriver("PostgreSQL")
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
getwd()
setwd("GitHub/cancer-trial-match")
## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password
drv <- dbDriver("PostgreSQL")
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
knitr::opts_chunk$set(echo = TRUE)
require(rjson)
## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password
drv <- dbDriver("PostgreSQL")
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
## get country name specified in configuration file
country <- configuration$country
## get interventional studies for country specified in configuration file
## any indication
## with sites in specified country that have a status of "Recruiting" or "Not yet recruiting"
# form query
openStudiesQ <- paste0("SELECT s.nct_id, s.brief_title, s.overall_status, c.name AS condition, i.name AS interventions, f.name AS site_name,
f.city AS locations, f.zip AS postcode, f.status AS site_status,
fi.name as investigators,
fc.email AS contacts
FROM studies s
INNER JOIN facilities f ON f.nct_id = s.nct_id
INNER JOIN conditions c ON c.nct_id = s.nct_id
INNER JOIN interventions i ON i.nct_id = s.nct_id
LEFT JOIN facility_contacts fc ON f.id = fc.facility_id
LEFT JOIN facility_investigators fi ON f.id=fi.facility_id
WHERE f.country LIKE ('",
country,
"')
AND s.study_type LIKE ('Interventional')
AND s.overall_status IN ('Recruiting')
AND f.status IN ('Recruiting', 'Not yet recruiting')")
## get data from clinicaltrials.gov
openStudies <- dbGetQuery(conn2,openStudiesQ)
## add a column to indicate refresh date
openStudies$Refresh.date <- today
## conditionSynonyms specifies which cancer types are of interest, and which condition names (as used by clinicaltrials.gov) will be considered as matches for each
## synonyms define on basis of those in clinicaltrials.gov
#conditionSynonyms <- read.csv(file = "conditionSynonyms4.csv", stringsAsFactors = FALSE)
## updated set of more granular cancer types
conditionSynonyms <- read.csv(file = "conditionSynonyms5.csv", stringsAsFactors = FALSE)
## trim leading/trailing whitespace
conditionSynonyms$condition.synonyms <- str_squish(string = conditionSynonyms$condition.synonyms)
knitr::opts_chunk$set(echo = TRUE)
require(RPostgreSQL)
require(RODBC)
require(formattable)
require(org.Hs.eg.db)
require(DBI)
require(dplyr)
require(tidyr)
require(kableExtra)
require(KEGGREST)
require(stringr)
#require(stringi)
require(splitstackshape)
require(reshape2)
require(tictoc)
require(maps)
require(leaflet)
require(PostcodesioR)
require(rjson)
require(RSQLite)
require(igraph)
## clean up first
rm(list=ls())
##get today's date
today <- format(Sys.Date(), format = "%d %B %Y")
## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password
drv <- dbDriver("PostgreSQL")
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
## get country name specified in configuration file
country <- configuration$country
## get interventional studies for country specified in configuration file
## any indication
## with sites in specified country that have a status of "Recruiting" or "Not yet recruiting"
# form query
openStudiesQ <- paste0("SELECT s.nct_id, s.brief_title, s.overall_status, c.name AS condition, i.name AS interventions, f.name AS site_name,
f.city AS locations, f.zip AS postcode, f.status AS site_status,
fi.name as investigators,
fc.email AS facility_contacts,
fc.phone AS facility_phone,
cc.email AS central_contact,
cc.phone AS central_phone
FROM studies s
INNER JOIN facilities f ON f.nct_id = s.nct_id
INNER JOIN conditions c ON c.nct_id = s.nct_id
INNER JOIN interventions i ON i.nct_id = s.nct_id
INNER JOIN central_contacts cc ON cc.nct_id = s.nct_id
LEFT JOIN facility_contacts fc ON f.id = fc.facility_id
LEFT JOIN facility_investigators fi ON f.id=fi.facility_id
WHERE f.country LIKE ('",
country,
"')
AND s.study_type LIKE ('Interventional')
AND s.overall_status IN ('Recruiting')
AND f.status IN ('Recruiting', 'Not yet recruiting')")
## get data from clinicaltrials.gov
openStudies <- dbGetQuery(conn2,openStudiesQ)
## add a column to indicate refresh date
openStudies$Refresh.date <- today
## conditionSynonyms specifies which cancer types are of interest, and which condition names (as used by clinicaltrials.gov) will be considered as matches for each
## synonyms define on basis of those in clinicaltrials.gov
#conditionSynonyms <- read.csv(file = "conditionSynonyms4.csv", stringsAsFactors = FALSE)
## updated set of more granular cancer types
conditionSynonyms <- read.csv(file = "conditionSynonyms5.csv", stringsAsFactors = FALSE)
## trim leading/trailing whitespace
conditionSynonyms$condition.synonyms <- str_squish(string = conditionSynonyms$condition.synonyms)
## remove redundancy, if any
conditionSynonyms <- unique(conditionSynonyms)
## display conditions and synonyms used
# formattable(as.data.frame(conditionSynonyms %>%
#                   group_by(controlled.cancer.type) %>%
#                   summarise(
#                   synonyms = paste(condition.synonyms, collapse = ", "))))
## preview
formattable(head(conditionSynonyms))
## create as a table in database
#dbWriteTable(conn = con,name = "cancers", value = conditionSynonyms, overwrite=TRUE)
## check it has saved
#dbListTables(con)
## add a column to hold matching condition
openStudies$matching.condition <- NA
openStudies$TARGET.condition <- NA
## create an empty version to which matching rows will be added after looping through condition synonyms
cancerStudies <- openStudies[0, ]
# loop through condition synonyms
for(i in 1:nrow(conditionSynonyms)) {
synonym <- as.character(conditionSynonyms$condition.synonyms[i])
targetCondition <- as.character(conditionSynonyms$controlled.cancer.type[i])
## look for a match in condition name
matching.rows <- grep(pattern = synonym, x=openStudies$condition, ignore.case = TRUE)
## create a temporary data frame to hold matches
temp <- openStudies[matching.rows, ]
if(nrow(temp)>0) {
temp$matching.condition <- synonym
temp$TARGET.condition <- targetCondition
cancerStudies <- rbind(cancerStudies, temp)
}
}
## overwrite openStudies with openStudies2
#openStudies <- openStudies2
## delete copy of openStudies to save memory
rm(openStudies)
## remove redundant rows, if any
cancerStudies <- unique(cancerStudies)
head(cancerStudies)
cancerStudies <- unique(dplyr::filter(cancerStudies, site_status == "Recruiting"))
head(cancerStudies)
View(cancerStudies)
unique(cancerStudies$nct_id[!is.na(cancerStudies$facility_contacts)])
length(unique(cancerStudies$nct_id[!is.na(cancerStudies$facility_contacts)]))
studyIDswithFacilityContacts <- unique(cancerStudies$nct_id[!is.na(cancerStudies$facility_contacts)])
studyIDswithFacilityContacts
unique(cancerStudies$nct_id[!is.na(cancerStudies$central_contact )])
studyIDswithCentralContacts <- unique(cancerStudies$nct_id[!is.na(cancerStudies$central_contact )])
?setdiff
setdiff(x=studyIDswithCentralContacts, y=studyIDswithFacilityContacts)
length(unique(cancerStudies$nct_id))
length(setdiff(x=studyIDswithCentralContacts, y=studyIDswithFacilityContacts))
head(unique(cancerStudies$central_contact))
head(unique(cancerStudies$central_contact),30)
grep(x= head(unique(cancerStudies$central_contact),30), pattern = ".*\.uk")
grep(x= head(unique(cancerStudies$central_contact),30), pattern = ".*\\.uk")
head(unique(cancerStudies$central_contact),30)[grep(x= head(unique(cancerStudies$central_contact),30), pattern = ".*\\.uk")]
[grep(x= unique(cancerStudies$central_contact), pattern = ".*\\.uk")]
grep(x= unique(cancerStudies$central_contact), pattern = ".*\\.uk")
length(grep(x= unique(cancerStudies$central_contact), pattern = ".*\\.uk"))
unique(cancerStudies$central_contact)[grep(x= unique(cancerStudies$central_contact), pattern = ".*\\.uk")]
unique(cancerStudies$central_contact)[grep(x= unique(cancerStudies$central_contact), pattern != ".*\\.uk")]
unique(filter(cancerStudies, central_contact == ".*\\.uk"))
unique(filter(cancerStudies, central_contact == ".*\\.uk", perl=T))
unique(filter(cancerStudies, central_contact = ".*\\.uk", perl=T))
length(unique(cancerStudies$central_contact))
head(cancerStudies)
head(unique(dplyr::filter(cancerStudies, nct_id,locations, central_contact, facility_contacts))
)
head(unique(dplyr::select(cancerStudies, nct_id,locations, central_contact, facility_contacts))
)
simple <- unique(dplyr::select(cancerStudies, nct_id,locations, central_contact, facility_contacts))
head(simple)
filter(simple, is.na(facility_contacts)
)
missingFacilityContacts <- filter(simple, is.na(facility_contacts))
[grep(x= unique(simple$central_contact), pattern = ".*\\.uk")]
simple[grep(x= unique(simple$central_contact), pattern = ".*\\.uk"), ]
grep(x= unique(simple$central_contact), pattern = ".*\\.uk")
grep(x= simple$central_contact, pattern = ".*\\.uk")
simple[grep(x= simple$central_contact, pattern = ".*\\.uk"), ]
simple <- simple[grep(x= simple$central_contact, pattern = ".*\\.uk"), ]
length(unique(simple$nct_id))
simple %>%
aggregate( by=simple['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
as.data.frame()
simple <- simple %>%
aggregate( by=simple['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
as.data.frame()
