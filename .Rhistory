tableScored <- dplyr::filter(tableScored, gene_variant_type %in% selectedAlterations)
tableStudies <- cancerStudies
tableStudies <- merge(x=tableStudies, by.x=c("nct_id"), all.x=TRUE,
y=tableScored, by.y=c("nct_id"))
head(tableStudies)
tableStudies$combined_score[is.na(tableStudies$combined_score)] <- 0
head(tableStudies)
tableStudies <- tableStudies[order(tableStudies$combined_score, decreasing = TRUE), ]
head(tableStudies)
tableStudies[is.na(tableStudies)] <- "-"
head(tableStudies)
?arrange
head(tableStudies)
tableStudies %>%
arrange(desc(nct_id))
tableStudies %>%
arrange(desc(nct_id)) %>%
head()
tableStudies %>%
arrange(desc(nct_id)) %>%
head() %>%
arrange(desc(combined_score)) %>%
head()
tableStudies %>%
arrange(desc(nct_id)) %>%
#head() %>%
arrange(desc(combined_score)) %>%
head()
tableStudies %>%
arrange(desc(nct_id)) %>%
#head() %>%
aggregate( by=tableStudies['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
arrange(desc(combined_score)) %>%
head()
rlang::last_error()
rlang::last_trace()
tableStudies %>%
arrange(desc(nct_id)) %>%
#head() %>%
aggregate( by=tableStudies['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
#arrange(desc(combined_score)) %>%
head()
tableStudies %>%
arrange(desc(nct_id)) %>%
#head() %>%
aggregate( by=tableStudies['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
#arrange(desc(combined_score)) %>%
names()
cancerStudies[0, ]
?validate
?DTOutput
?showNotification
?showModal
?validate
strsplit(x="ERBB2 amplification,KRAS mutation", split=",")
class(strsplit(x="ERBB2 amplification,KRAS mutation", split=","))
class(unlist(strsplit(x="ERBB2 amplification,KRAS mutation", split=",")))
unlist(strsplit(x="ERBB2 amplification,KRAS mutation", split=","))
?selectInput
class(unlist(strsplit(x="ERBB2 amplification,KRAS mutation", split=",")))
length(unlist(strsplit(x="ERBB2 amplification,KRAS mutation", split=",")))
url <- "http://en.wikipedia.org/wiki/api.php"
param_set(url, key = "pageid", value = "12")
install.packages("urltools")
library(urltools)
param_set(url, key = "pageid", value = "12")
param_set(url, key = "pageid", value = c("12", "13"))
class(c("ERBB2 amplification", "KRAS mutation"))
x <- data.table(letters[1:4], 1:4)
library(DT)
x <- data.table(letters[1:4], 1:4)
?datatable
x <- datatable(letters[1:4], 1:4)
?datatable
length(names(table)
)
View(table)
sort(unique(cancerStudies$gene_variant_type))
sort(unique(scoredMatches$gene_variant_type))
?scrollY
?DT::scrollY
unique(c(names(cancerStudies), names(scoredMatches)))
shortlistNames <- unique(c(names(cancerStudies), names(scoredMatches)))
shortlist <- data.frame()
shortlist
colnames(shortlist) <- shortlistNames
data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=shortlistNames))
data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=list(shortlistNames)))
list(shortlistNames)
data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=list(NULL, shortlistNames)))
shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=list(NULL, shortlistNames)))
createEmptyShortlist <- function() {
## get column names from a merge of cancerStudies and scoredMatches
shortlistNames <- unique(c(names(cancerStudies), names(scoredMatches)))
## create empty dataframe
shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=list(NULL, shortlistNames)))
## return empty shortlist
return(shortlist)
}
createEmptyShortlist()
shortlist <-createEmptyShortlist()
shortlistNames
mergedStudyTableStatisHead <- merge(x=head(cancerStudies), by.x=c("nct_id")
y=head(scoredMatches), by.y=c("nct_id"))
mergedStudyTableStaticHead <- merge(x=head(cancerStudies), by.x=c("nct_id"),
y=head(scoredMatches), by.y=c("nct_id"))
mergedStudyTableStaticHead
setdiff(names(mergedStudyTableStaticHead), names(shortlistNames))
setdiff(names(mergedStudyTableStaticHead), names(shortlist))
filter(scoredMatches, gene_variant_type %in% NULL)
testScored <- filter(scoredMatches, gene_variant_type %in% NULL)
merge(x=head(cancerStudies), by.x="nct_id", all.x=TRUE, y=testScored, by.y="nct_id")
rm(list = ls())
rmarkdown::render("trialMatchDatarefresh.Rmd")
1375/25
rmarkdown::render("trialMatchDatarefresh.Rmd")
rm(list=ls())
rmarkdown::render("trialMatchDatarefresh.Rmd")
rmarkdown::render("trialMatchDatarefresh.Rmd")
grep(pattern = fusionPattern, x="Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement
", ignore.case = T)
grep(pattern = fusionPattern, x="Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene spacing rearrangement
", ignore.case = T)
grep(pattern = fusionPattern, x="Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene", ignore.case = T)
grep(pattern = fusionPattern, x="Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene spac ing rearrangement
", ignore.case = T)
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
tarts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
}
range <- unique(range)
criterion
criterion <- criterion[range]
criterion
criterion <- criterion[!is.na(criterion)]
criterion
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
View(fusion.eligibilities)
## define fusion pattern
fusionPattern <- " fusion|rearrangement"
## specify word range - fusionPattern must occur within this many words of a gene name
fusionWordRange <- 6
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
criterion
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
criterion
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
}
criterion
range <- unique(range)
criterion <- criterion[range]
criterion
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
criterion <- fusion.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
criterion
criterion[criterion!=""]
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion
criterion[criterion!=""]
criterion <- criterion[criterion!=""]
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
## define fusion pattern
fusionPattern <- " fusion|rearrangement"
## specify word range - fusionPattern must occur within this many words of a gene name
fusionWordRange <- 7
criterion <- criterion[criterion!=""]
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
criterion <- "Histologically- or cytologically-confirmed diagnosis of locally advanced or metastatic solid tumor that harbors an NTRK1/2/3, ROS1, or ALK gene rearrangement"
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
criterion
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
rmarkdown::render("trialMatchDataRefresh.Rmd")
?selectInput
library(shiny)
?selectInput
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
View(cancerStudies)
unique(cancerStudies$Refresh.date)
class(unique(cancerStudies$Refresh.date))
parseQueryString("http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation")
rearrangement.eligibilities <- eligibilities
rearrangementPattern <- " fusion|rearrangement|truncation|truncated|deletion|loss|deleted|lost|duplication|duplicated"
rearrangementRange <- 6
View(rearrangement.eligibilities)
rearrangementIndices <- grep(pattern = rearrangementPattern, x=rearrangement.eligibilities$criteria, ignore.case = T)
# subset table
rearrangement.eligibilities <- rearrangement.eligibilities[rearrangementIndices, ]
# label nature of change
rearrangement.eligibilities$feature <- "rearrangement"
dim(rearrangement.eligibilities)
for(i in 1:nrow(rearrangement.eligibilities)) {
criterion <- rearrangement.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
#criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(rearrangementPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - rearrangementRange
ends <- indices + rearrangementRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) rearrangement.eligibilities$match[i] <- list(criterion)
}
dim(rearrangement.eligibilities)
## drop rows not indexed against a gene
rearrangement.eligibilities <- rearrangement.eligibilities[!is.na(rearrangement.eligibilities$match), ]
## unnest
rearrangement.eligibilities <- as.data.frame(unnest(rearrangement.eligibilities, cols = "match"))
dim(rearrangement.eligibilities)
rearrangementPattern
## create a copy of eligibilities table
mutation.eligibilities <- eligibilities
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss|loss of function|loss-of-function"
## specify word range - mutantPattern must occur within this many words of a gene name
mutantWordRange <- 6
## define which rows contain a match for mutantPattern
mutantIndices <- grep(pattern = mutantPattern, x=mutation.eligibilities$criteria, ignore.case = T)
# subset table
mutation.eligibilities <- mutation.eligibilities[mutantIndices, ]
# label nature of change
mutation.eligibilities$feature <- "mutation"
## loop through each criterion that contains mutant pattern
for(i in 1:nrow(mutation.eligibilities)) {
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## get indices of match(es) against mutantPattern
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) mutation.eligibilities$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
mutation.eligibilities <- mutation.eligibilities[!is.na(mutation.eligibilities$match), ]
## unnest
mutation.eligibilities <- as.data.frame(unnest(mutation.eligibilities, cols = "match"))
## join to Entrez symbols from humanGenes
mutation.eligibilities <- merge(x=mutation.eligibilities, by.x="match", y=humanGenes, by.y = "Aliases")
## rename Symbol to "controlled.match"
mutation.eligibilities <- rename(mutation.eligibilities, "controlled.match"="Symbol")
View(mutation.eligibilities)
indexOnPattern <- function(eligibilities, pattern, wordRange, featureLabel) {
table <- eligibilities
pattern <- pattern
wordRange <- wordRange
featureLabel <- featureLabel
## get indices containing specified pattern
indices <- grep(pattern = pattern, x=table$criteria, ignore.case = T)
# subset table
table <- table[indices, ]
# label nature of change
table$feature <- featureLabel
## loop through each criterion that contains pattern
for(i in 1:nrow(table)) {
criterion <- table$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
## criterion is now a vector of tokens (words, but also some empty elements)
## remove any empty elements in criterion
criterion <- criterion[criterion!=""]
## get indices of match(es) against pattern (need to squish preceding space)
indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - wordRange
ends <- indices + wordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) table$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
table <- table[!is.na(table$match), ]
## unnest
table <- as.data.frame(unnest(table, cols = "match"))
## join to Entrez symbols from humanGenes
table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
## rename Symbol to "controlled.match"
table <- rename(table, "controlled.match"="Symbol")
return(table)
}
indexOnPattern(eligibilities = eligibilities, pattern = rearrangementPattern, wordRange = rearrangementRange, featureLabel = "rearrangement")
testrun <- indexOnPattern(eligibilities = eligibilities, pattern = rearrangementPattern, wordRange = rearrangementRange, featureLabel = "rearrangement")
View(testrun)
library(arsenal)
comparedf(x=rearrangement.eligibilities,y=testrun)
rm(list=ls())
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
indexOnPattern(eligibilities = eligibilities, pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function", wordRange = 6, featureLabel = "mutation")
View(eligibilities)
indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 5, featureLabel = "loss")
loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 5, featureLabel = "loss")
View(loss.eligibilities)
loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 2, featureLabel = "loss")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
rmarkdown::render("trialMatchDataRefresh.Rmd")
