for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     pattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single character
criterion <- criterion[nchar(criterion)>1]
if(length(criterion)>0) eligibilities$gene[i] <- list(criterion)
}
}
## indicate which criteria relate to mutations (append to existing value in case it relates to both)
eligibilities$change[grep(pattern = mutantPattern, x=eligibilities$criteria, ignore.case = T)] <- list(c("MUTATION",                                                                      eligibilities$change[grep(pattern = mutantPattern, x=eligibilities$criteria, ignore.case = T)]))
## do the same for fusions
eligibilities$change[grep(pattern = fusionPattern, x=eligibilities$criteria, ignore.case = T)] <- list(c("FUSION",                                                                      eligibilities$change[grep(pattern = fusionPattern, x=eligibilities$criteria, ignore.case = T)]))
## add a column to indicate nature of genetic changes
eligibilities$change <- NA
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss"
fusionPattern <- " fusion"
## indicate which criteria relate to mutations (append to existing value in case it relates to both)
mutantIndices <- grep(pattern = mutantPattern, x=eligibilities$criteria, ignore.case = T)
fusionIndices <- grep(pattern = fusionPattern, x=eligibilities$criteria, ignore.case = T)
intersect(mutantIndices,fusionIndices)
list("FUSION","MUTATION")
eligibilities$change[mutantIndices] <- "MUTATION"
eligibilities$change[fusionIndices] <- "FUSION"
eligibilities$change[intersect(fusionIndices,mutantIndices)] <- list("FUSION","MUTATION")
unique(eligibilities$change)
as.data.frame(unnest(data = eligibilities, cols = change))
eligibilities <- as.data.frame(unnest(data = eligibilities, cols = change))
test.study <- "NCT02314481"
?unnest
eligibilities$change[mutantIndices] <- "MUTATION"
filter(eligibilities, nct_id == test.study)
eligibilities$change[fusionIndices] <- "FUSION"
filter(eligibilities, nct_id == test.study)
eligibilities$change[intersect(fusionIndices,mutantIndices)] <- list("FUSION","MUTATION")
filter(eligibilities, nct_id == test.study)
eligibilities$change[intersect(fusionIndices,mutantIndices)]
## add a column to indicate nature of genetic changes
eligibilities$change <- NA
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss"
fusionPattern <- " fusion"
## indicate which criteria relate to mutations (append to existing value in case it relates to both)
mutantIndices <- grep(pattern = mutantPattern, x=eligibilities$criteria, ignore.case = T)
fusionIndices <- grep(pattern = fusionPattern, x=eligibilities$criteria, ignore.case = T)
eligibilities$change[mutantIndices] <- "MUTATION"
eligibilities$change[fusionIndices] <- "FUSION"
eligibilities$change[intersect(fusionIndices,mutantIndices)]
eligibilities$change[intersect(fusionIndices,mutantIndices)] <- list("FUSION","MUTATION")
eligibilities$change[intersect(fusionIndices,mutantIndices)]
eligibilities$change[intersect(fusionIndices,mutantIndices)] <- list(c("FUSION","MUTATION"))
eligibilities$change[intersect(fusionIndices,mutantIndices)]
eligibilities <- as.data.frame(unnest(data = eligibilities, cols = change))
filter(eligibilities, nct_id == test.study)
rmarkdown::render("trialMatchDataRefresh.Rmd")
length(unique(humanGenes$Symbol))
nrow(humhumanGenes)
nrow(humanGenes)
nrow(eligibilities)
eligibilities.raw <- dbGetQuery(conn2,getEligibilities)
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
eligibilities.raw <- dbGetQuery(conn2,getEligibilities)
View(eligibilities.raw)
eligibilities.raw$criteria[21]
write.table(eligibilities.raw, file = "eligibilities_unprocessed.tsv", sep = "\t",
row.names = FALSE, col.names = names(eligibilities.raw))
length(unique(eligibilities.raw$nct_id))
mutantPattern
wordrange
rmarkdown::render("trialMatchDataRefresh.Rmd")
## create a copy of eligibilities table
mutation.eligibilities <- eligibilities
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss"
## specify word range - mutantPattern must occur within this many words of a gene name
mutantWordRange <- 6
## define which rows contain a match for mutantPattern
mutantIndices <- grep(pattern = mutantPattern, x=mutation.eligibilities$criteria, ignore.case = T)
# subset table
mutation.eligibilities <- mutation.eligibilities[mutantIndices, ]
# label nature of change
eligibilities$feature <- "MUTATION"
## loop through each criterion that contains mutant pattern
for(i in 1:nrow(mutation.eligibilities)) {
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
## get indices of match(es) against mutantPattern
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single character
criterion <- criterion[nchar(criterion)>1]
if(length(criterion)>0) mutation.eligibilities$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
mutation.eligibilities <- mutation.eligibilities[!is.na(mutation.eligibilities$match), ]
View(mutation.eligibilities)
i <- 1
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
criterion
criterion <- mutation.eligibilities$criteria[i]
criterion
mutation.eligibilities <- eligibilities
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss"
## specify word range - mutantPattern must occur within this many words of a gene name
mutantWordRange <- 6
## define which rows contain a match for mutantPattern
mutantIndices <- grep(pattern = mutantPattern, x=mutation.eligibilities$criteria, ignore.case = T)
mutantIndices
mutation.eligibilities <- mutation.eligibilities[mutantIndices, ]
head(mutation.eligibilities)
mutation.eligibilities$feature <- "MUTATION"
criterion <- mutation.eligibilities$criteria[i]
criterion
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
criterion
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
}
range
range <- unique(range)
range
criterion <- criterion[range]
criterion
criterion <- criterion[!is.na(criterion)]
criterion
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
criterion <- criterion[nchar(criterion)>1]
criterion
length(criterion)>0
head(eligibilities)
head(mutation.eligibilities)
i <- 2
for(i in 1:nrow(mutation.eligibilities)) {
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
## get indices of match(es) against mutantPattern
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single character
criterion <- criterion[nchar(criterion)>1]
if(length(criterion)>0) mutation.eligibilities$match[i] <- list(criterion)
}
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
criterion
## get indices of match(es) against mutantPattern
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
criterion
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
criterion
criterion <- criterion[nchar(criterion)>1]
length(criterion)>0
if(length(criterion)>0) mutation.eligibilities$match[i] <- list(criterion)
class(mutation.eligibilities$match)
names(eligibilities)
eligibilities$match <- NA
## create a copy of eligibilities table
mutation.eligibilities <- eligibilities
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss"
## specify word range - mutantPattern must occur within this many words of a gene name
mutantWordRange <- 6
## define which rows contain a match for mutantPattern
mutantIndices <- grep(pattern = mutantPattern, x=mutation.eligibilities$criteria, ignore.case = T)
# subset table
mutation.eligibilities <- mutation.eligibilities[mutantIndices, ]
# label nature of change
mutation.eligibilities$feature <- "MUTATION"
## loop through each criterion that contains mutant pattern
for(i in 1:nrow(mutation.eligibilities)) {
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
## get indices of match(es) against mutantPattern
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single character
criterion <- criterion[nchar(criterion)>1]
if(length(criterion)>0) mutation.eligibilities$match[i] <- list(criterion)
}
mutation.eligibilities <- mutation.eligibilities[!is.na(mutation.eligibilities$match), ]
head(mutation.eligibilities)
head(unnest(mutation.eligibilities, cols = "match"))
head(as.data.frame(unnest(mutation.eligibilities, cols = "match")))
rmarkdown::render("trialMatchDataRefresh.Rmd")
i <- 1
criterion <- fusion.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
criterion
## get indices of match(es) against mutantPattern
indices <- grep(pattern = fusionPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
starts
ends
indices
fusionPattern
fusionPattern %in% criterion
criterion
str_squish(fusionPattern) %in% criterion
"fusion" %in% criterion
criterion
grep(pattern =str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
for(i in 1:nrow(fusion.eligibilities)) {
criterion <- fusion.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(fusionPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - fusionWordRange
ends <- indices + fusionWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single character
criterion <- criterion[nchar(criterion)>1]
if(length(criterion)>0) fusion.eligibilities$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
fusion.eligibilities <- fusion.eligibilities[!is.na(fusion.eligibilities$match), ]
indexed.eligibilities <- rbind(mutation.eligibilities, fusion.eligibilities)
head(indexed.eligibilities)
View(indexed.eligibilities)
nrow(indexed.eligibilities)
indexed.eligibilities <- unique(rbind(mutation.eligibilities, fusion.eligibilities))
nrow(indexed.eligibilities)
## create a copy of eligibilities table
mutation.eligibilities <- eligibilities
## define a pattern of word stems to filter for mutation-related criteria
#mutantPattern <- "mutat|mutant|positiv|defect|deficien|alter|loss"
## (OPTIONAL) drop matches containing "positive" as these tend to be IHC, not mutation
mutantPattern <- "mutat|mutant|defect|deficien|alter|loss"
## specify word range - mutantPattern must occur within this many words of a gene name
mutantWordRange <- 6
## define which rows contain a match for mutantPattern
mutantIndices <- grep(pattern = mutantPattern, x=mutation.eligibilities$criteria, ignore.case = T)
# subset table
mutation.eligibilities <- mutation.eligibilities[mutantIndices, ]
# label nature of change
mutation.eligibilities$feature <- "MUTATION"
## loop through each criterion that contains mutant pattern
for(i in 1:nrow(mutation.eligibilities)) {
criterion <- mutation.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
## get indices of match(es) against mutantPattern
indices <- grep(pattern = mutantPattern, x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - mutantWordRange
ends <- indices + mutantWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single character
criterion <- criterion[nchar(criterion)>1]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) mutation.eligibilities$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
mutation.eligibilities <- mutation.eligibilities[!is.na(mutation.eligibilities$match), ]
## unnest
mutation.eligibilities <- as.data.frame(unnest(mutation.eligibilities, cols = "match"))
View(mutation.eligibilities)
rmarkdown::render("trialMatchDataRefresh.Rmd")
names(humanGenes)
merge(x=fusion.eligibilities, by.x="match", y=humanGenes, by.y = "Aliases")
head(fusion.eligibilities)
fusion.eligibilities <- as.data.frame(unnest(fusion.eligibilities, cols = "match"))
merge(x=fusion.eligibilities, by.x="match", y=humanGenes, by.y = "Aliases")
rmarkdown::render("trialMatchDataRefresh.Rmd")
filter(indexed.eligibilities, nct_id=="NCT03565445")
filter(indexed.eligibilities, nct_id=="NCT03625323")
## create a copy of eligibilities
amplification.eligibilities <- eligibilities
## define pattern
amplificationPattern <- " amplification"
## specify word range - fusionPattern must occur within this many words of a gene name
amplificationWordRange <- 6
## define which rows contain a match for mutantPattern
amplificationIndices <- grep(pattern = amplificationPattern, x=amplification.eligibilities$criteria, ignore.case = T)
# subset table
amplification.eligibilities <- amplification.eligibilities[amplificationIndices, ]
# label nature of change
amplification.eligibilities$feature <- "AMPLIFICATION"
## loop through each criterion that contains pattern
for(i in 1:nrow(amplification.eligibilities)) {
criterion <- amplification.eligibilities$criteria[i]
# also create an alternative criterion for patterns such as "BRCA1/2"
alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
# now do the same and trim off the first character after the slash
criterion <- gsub(pattern = "/.", replacement = "", x=criterion)
# concatenate
criterion <- paste(criterion,alternative.criterion, sep = " " )
# split into tokens
criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-"))
## get indices of match(es) against fusionPattern (need to squish preceding space)
indices <- grep(pattern = str_squish(amplificationPattern), x = criterion, ignore.case = TRUE)
## specify start and end point(s) based on specified word range
starts <- indices - amplificationWordRange
ends <- indices + amplificationWordRange
range <- numeric(0)
for(j in 1:length(starts)) { ## because there may be more than one match
if(starts[j] <1) {starts[j] <- 1}
range <- append(range,starts[j]:ends[j])
} ## now range contains the indices of the words either side of the     mutantPattern, within specified word range
range <- unique(range) ## if the ranges overlap, just get the unique elements
## range is the indices of words within the criterion that are within the specified wordRange from mutantPattern... (i.e. the ones we want to keep)
## subset the criterion retain only words within specified range
criterion <- criterion[range]
## omit any NA values (i.e. where match is less than wordRange from end of sentence)
criterion <- criterion[!is.na(criterion)]
## now subset and retain only words that are a valid gene alias
criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
## drop any aliases that are a single or 2 characters
criterion <- criterion[nchar(criterion)>2]
## drop any matches against the word "not"
criterion <- criterion[criterion != "not"]
if(length(criterion)>0) amplification.eligibilities$match[i] <- list(criterion)
}
## drop rows not indexed against a gene
amplification.eligibilities <- amplification.eligibilities[!is.na(amplification.eligibilities$match), ]
## unnest
amplification.eligibilities <- as.data.frame(unnest(amplification.eligibilities, cols = "match"))
## join to Entrez symbols from humanGenes
amplification.eligibilities <- merge(x=amplification.eligibilities, by.x="match", y=humanGenes, by.y = "Aliases")
View(amplification.eligibilities)
indexed.eligibilities <- unique(rbind(mutation.eligibilities, fusion.eligibilities,amplification.eligibilities))
View(indexed.eligibilities)
length(unique(indexed.eligibilities$nct_id))
names(indexed.eligibilities)
rename(data=amplification.eligibilities, "controlled.match"="Aliases")
rename(amplification.eligibilities, "controlled.match"="Aliases")
rename(amplification.eligibilities, "controlled.match"="Symbol")
amplification.eligibilities <- rename(amplification.eligibilities, "controlled.match"="Symbol")
mutation.eligibilities <- rename(mutation.eligibilities, "controlled.match"="Symbol")
fusion.eligibilities <- rename(fusion.eligibilities, "controlled.match"="Symbol")
indexed.eligibilities <- unique(rbind(mutation.eligibilities, fusion.eligibilities,amplification.eligibilities))
rmarkdown::render("trialMatchDataRefresh.Rmd")
head(filter(indexed.eligibilities, feature =="FUSION"))
head(filter(indexed.eligibilities, feature =="AMPLIFICATION"))
rmarkdown::render("trialMatchDataRefresh.Rmd")
