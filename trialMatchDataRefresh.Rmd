---
title: "Data refresh for Cancer Trial Match"
author: "digital ECMT"
date: ""
output: html_document

---

```{r setup, include=FALSE, warning=FALSE, message=FALSE, results=F} 
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
##NOTE: the following packages are required to run this script, but should be installed (e.g. using code snippets below) before runnning the script, NOT as part of the script itself

# options(repos = "http://cran.us.r-project.org")
# install.packages("BiocManager")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("KEGGREST")
# BiocManager::install("KEGGlincs")
# BiocManager::install("hgu133a.db")
require(KEGGlincs)
require(KEGGgraph)

require(RPostgreSQL)
require(RODBC)
require(formattable)
require(org.Hs.eg.db)
require(DBI)
require(dplyr)
require(tidyr)
require(kableExtra)
require(KEGGREST)
require(stringr)
require(stringi)
require(splitstackshape)
require(reshape2)
require(tictoc)
require(maps)
require(leaflet)
require(PostcodesioR)
require(rjson)
require(RSQLite)
require(igraph)

## clean up first
rm(list=ls())

##get today's date
today <- format(Sys.Date(), format = "%d %B %Y")



```

**Date of data refresh: `r today`**  
  
  
```{r create empty SQLite DB} 
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

dbListTables(con)

```
  
#### **Define controlled terms and synonyms for cancer types**  
  
  
```{r create table of cancer types}
## conditionSynonyms specifies which cancer types are of interest, and which condition names (as used by clinicaltrials.gov) will be considered as matches for each

## synonyms define on basis of those in clinicaltrials.gov
#conditionSynonyms <- read.csv(file = "conditionSynonyms4.csv", stringsAsFactors = FALSE)
## updated set of more granular cancer types
conditionSynonyms <- read.csv(file = "conditionSynonyms5.csv", stringsAsFactors = FALSE)




## trim leading/trailing whitespace

## remove redundancy, if any
conditionSynonyms <- unique(conditionSynonyms)

## display conditions and synonyms used
# formattable(as.data.frame(conditionSynonyms %>% 
#                   group_by(controlled.cancer.type) %>%
#                   summarise(
#                   synonyms = paste(condition.synonyms, collapse = ", "))))

## preview
formattable(head(conditionSynonyms))

## create as a table in database
dbWriteTable(conn = con,name = "cancers", value = conditionSynonyms, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
#### **List human gene names and their synonyms**  
    
  
```{r download and process a list of all human genes and their synonyms}

## start timer
tic("download a list of all human genes and their synonyms")


humanGenes <- read.table(file = "humanGenes.tsv", header = TRUE, quote = "", sep = "\t", fill = TRUE, stringsAsFactors = FALSE)

humanGenes <- dplyr::select(humanGenes, Symbol, Aliases)## drop everything except Symbol and Aliases columns


humanGenes$Aliases <- strsplit(x=humanGenes$Aliases, split = ",")## split the aliases on comma 
humanGenes <- unnest(data = humanGenes, cols = Aliases, keep_empty = TRUE) ## unnest to multiply rows, keep any rows with no aliases
humanGenes <- as.data.frame(humanGenes) ## convert to data frame

humanGenes$Aliases <- str_squish(string = humanGenes$Aliases) ## trim excess whitespace from Aliases values

## Symbol values are not represented among Aliases
# create a data frame with unique Symbol values
symbols <- data.frame("Symbol"=unique(humanGenes$Symbol), "Aliases"=unique(humanGenes$Symbol))
# bind this onto bottom of humanGenes data frame
humanGenes <- rbind(humanGenes,symbols)
# remove duplicated values, if any
humanGenes <- unique(humanGenes)
# sort on Symbol values
humanGenes <- humanGenes[order(humanGenes$Symbol), ] 

# drop any rows where Aliases is NA
humanGenes <- humanGenes[!is.na(humanGenes$Aliases), ]

## drop any rows where Aliases value is only a single character

## NOW humanGenes TABLE CONTAINS ALL HUMAN GENES AND THEIR SYNONYMS
## (61,593 unique symbols, 130,989 rows)

## stop timer
toc()
```
  
```{r create table of human genes}
## preview
formattable(head(humanGenes))

## create as a table in database
dbWriteTable(conn = con,name = "genes", value = humanGenes, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
#### **Download variant info from clinVar and civicDB**  
    
  
```{r download and process variants from clinvar}
## download variant summaries from clinvar
download.file(url="https://ftp.ncbi.nlm.nih.gov/pub/clinvar/tab_delimited/variant_summary.txt.gz",destfile = "variant_summary.txt.gz")
clinvar <- read.table(gzfile("variant_summary.txt.gz"), sep="\t", quote="", fill = TRUE, stringsAsFactors = FALSE) 
# V1 contains values for Allele ID
# V2 gives nature (e.g. fusion, single nucleotide variant etc)
# V7 contains values for clinical significance (inc whether pathogenic or not)
# V25 gives a measure of confidence in assertion
clinvar <- unique(dplyr::select(clinvar, "allele.id" = "V1", "nature"="V2", "significance"="V7", "confidence"="V25"))

## variation_allele contains mappings from clinvar variation ID (clinvar ID) and allele ID
download.file(url="https://ftp.ncbi.nlm.nih.gov/pub/clinvar/tab_delimited/variation_allele.txt.gz",destfile = "variation_allele.txt.gz")
variationAllele <- read.table(gzfile("variation_allele.txt.gz"), sep="\t", quote="", fill = TRUE, stringsAsFactors = FALSE) 
# V1 contains values for clinvar ID
# V3 contains values for Allele ID
variationAllele <- unique(dplyr::select(variationAllele, "clinvar.id"="V1", "allele.id"="V3"))

## join tables
clinvar <- merge(x=clinvar, by.x="allele.id", y=variationAllele, by.y="allele.id")


# variants contains mappings from variant_id to clinvar_ids
variants <- read.csv(file = "https://civicdb.org/downloads/nightly/nightly-VariantSummaries.tsv", sep = "\t", quote = "", stringsAsFactors = FALSE)
# variants$gene contains gene name (Entrez symbol)
# variants$variant contains amino acid change
# variants$summary contains a useful summary of evidence for each variant
# variants$clinvar_ids contains (comma-separated) clinvar IDs that can be mapped to the clinvar table to get info whether pathogenic or not... 


## drop unwanted columns
variants <- unique(dplyr::select(variants, variant_id, gene, variant, summary, variant_groups,civic_variant_evidence_score,clinvar_ids ))

## split and unnest the clinvar_ids column
variants$clinvar_ids <- strsplit(as.character(variants$clinvar_ids), split = ",")
variants <- unnest(data = variants, clinvar_ids)


## join significance from clinvar
variants <- unique(merge(x=variants, by.x="clinvar_ids", all.x=TRUE, y=clinvar, by.y="clinvar.id"))



## drop unwanted columns 
variants <- unique(dplyr::select(variants,variant_id, clinvar_ids,gene,variant,summary,variant_groups, significance,confidence))

## split on the word "and"
variants$variant <- strsplit(x=variants$variant, split = " and ") 
variants <- unnest(data = variants, cols = variant, keep_empty = TRUE) ## unnest to multiply rows, keep any rows with no aliases
variants <- as.data.frame(variants) ## convert to datack a frame


## trim everything after first space in variants$variant
variants$variant <- gsub(pattern = " .*", replacement = "", x=variants$variant)

```

 
```{r create table of variants}
## preview
formattable(head(variants))

## create as a table in database
dbWriteTable(conn = con,name = "variants", value = variants, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
    
#### **Download variant:drug evidence from clinVar**  
    
    
```{r download and process evidence from civic DB}
## download evidence from civicDB
# evidence contains mappings from variant_id to gene (gene name) and variant (amino acid change) to drugs etc
evidence <- read.csv(file = "https://civicdb.org/downloads/nightly/nightly-ClinicalEvidenceSummaries.tsv", sep = "\t", quote="", stringsAsFactors = FALSE)
# evidence contains more detailed data re: drugs, sensitivity etc
# evidence$evidence_level contains details of nature of evidence: 
# A = validated
# B = clinical
# C = case study
# D = preclinical


## drop unwanted columns
evidence <- unique(dplyr::select(evidence, variant_id, disease, drugs,  evidence_type, evidence_direction,evidence_level,clinical_significance,evidence_statement))

evidence <- as.data.frame(evidence)

## unnest the drugs column
evidence$drugs <- strsplit(x=evidence$drugs, split=",")
evidence <- unnest(data = evidence, cols = drugs, keep_empty = TRUE) 
evidence <- as.data.frame(evidence) ## convert to data frame
```

 
```{r create table of evidence}
## preview
formattable(head(evidence))

## create as a table in database
dbWriteTable(conn = con,name = "evidence", value = evidence, overwrite=TRUE)

## check it has saved
dbListTables(con)


## print a list of disease in evidence table, but not represented among condition synonyms
# setdiff(x=unique(evidence$disease), y=unique(conditionSynonyms$condition.synonyms))
```

**The following disease are listed in the evidence table, but are not represented among the cancer types and synonyms defined above:**  
  
  
`r setdiff(x=unique(evidence$disease), y=unique(conditionSynonyms$condition.synonyms))`  
  
#### **Download cancer study data from clinicaltrials.gov**  
     
  
```{r connect to clinicaltrialsgov}  
## specify user name and password for AACT account
## see https://aact.ctti-clinicaltrials.org/ for how to create an account

## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password

drv <- dbDriver("PostgreSQL")
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
```
 
 
```{r get study data}

## get country name specified in configuration file
country <- configuration$country
## get interventional studies for country specified in configuration file
## any indication
## with sites in specified country that have a status of "Recruiting" or "Not yet recruiting"

# form query
openStudiesQ <- paste0("SELECT s.nct_id, s.brief_title, s.overall_status, c.name AS condition, i.name AS interventions, f.name AS site_name,
f.city AS locations, f.zip AS postcode, f.status AS site_status,
fi.name as investigators,
fc.email AS contacts
FROM studies s
INNER JOIN facilities f ON f.nct_id = s.nct_id
INNER JOIN conditions c ON c.nct_id = s.nct_id
INNER JOIN interventions i ON i.nct_id = s.nct_id
LEFT JOIN facility_contacts fc ON f.id = fc.facility_id
LEFT JOIN facility_investigators fi ON f.id=fi.facility_id
WHERE f.country LIKE ('",
country,
"')
  AND s.study_type LIKE ('Interventional')
  AND s.overall_status IN ('Recruiting')
  AND f.status IN ('Recruiting', 'Not yet recruiting')")


## get data from clinicaltrials.gov
openStudies <- dbGetQuery(conn2,openStudiesQ)

## add a column to indicate refresh date
openStudies$Refresh.date <- today

```
 

```{r loop through synonyms and look for matches against condition name}
## add a column to hold matching condition
openStudies$matching.condition <- NA
openStudies$TARGET.condition <- NA

## create an empty version to which matching rows will be added after looping through condition synonyms
cancerStudies <- openStudies[0, ]

# loop through condition synonyms
for(i in 1:nrow(conditionSynonyms)) {
  synonym <- as.character(conditionSynonyms$condition.synonyms[i])
  targetCondition <- as.character(conditionSynonyms$controlled.cancer.type[i])
  ## look for a match in condition name
  matching.rows <- grep(pattern = synonym, x=openStudies$condition, ignore.case = TRUE)
  ## create a temporary data frame to hold matches
  temp <- openStudies[matching.rows, ]
  if(nrow(temp)>0) {
    temp$matching.condition <- synonym
  temp$TARGET.condition <- targetCondition
  cancerStudies <- rbind(cancerStudies, temp)
  }
}

## overwrite openStudies with openStudies2
#openStudies <- openStudies2
## delete copy of openStudies to save memory
rm(openStudies)

## remove redundant rows, if any
cancerStudies <- unique(cancerStudies)

## add a column to hold link
cancerStudies$Link <- paste0("https://clinicaltrials.gov/ct2/show/", cancerStudies$nct_id)

## get eligibility criteria (before connection times out)
studyIDs <- unique(cancerStudies$nct_id)

## form SQL query
studyIDsForSQL <- paste0("\'",paste(studyIDs, collapse = "\',\'"), "\'")
getEligibilities <- paste0("select e.nct_id, e.criteria 
from eligibilities e
where e.nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
eligibilities <- dbGetQuery(conn2,getEligibilities)
```

```{r get latitude and longitude values for sites}



```



```{r get latitude and longitude values for sites based on postcode, warning=FALSE, message=FALSE}
## get lat and long for UK cities
## use postcodes where available
locations <- unique(dplyr::select(cancerStudies, postcode))
locations$postcode.lat <- NA
locations$postcode.long <- NA

for(i in 1:nrow(locations)) {
  postcode <- locations$postcode[i]
  tryCatch({
            lat = postcode_lookup(postcode)$latitude
            locations$postcode.lat[i] <- lat
            long = postcode_lookup(postcode)$longitude
            locations$postcode.long[i] <- long
            }, error=function(cond) {return(NA)})
}

## join to cancerStudies table
cancerStudies <- merge(x=cancerStudies, by.x="postcode", all.x=TRUE, y =locations, by.y ="postcode")

```


```{r get lat long values based on city name}
## should be able to get lat and long values for about 85% of sites (90% of studies) based on city name alone

## try and fill values based on city name
# remove any commas and anything after a comma
cancerStudies$locations <- gsub(pattern = ",.*", replacement = "", x=cancerStudies$locations)
# get names of cities that are still missing latitude (and longitude) values
data("world.cities")


## get country specified in configuration file
## accepted values are: 
# Afghanistan, Albania, Algeria, American Samoa, Andorra, Angola, Anguilla, Antigua and Barbuda, Argentina, Armenia, Aruba, Australia, Austria, Azerbaijan, Azores, Bahamas, Bahrain, Bangladesh, Barbados, Belarus, Belgium, Belize, Benin, Bermuda, Bhutan, Bolivia, Bosnia and Herzegovina, Botswana, Brazil, British Virgin Islands, Brunei, Bulgaria, Burkina Faso, Burundi, Cambodia, Cameroon, Canada, Canary Islands, Cape Verde, Cayman Islands, Central African Republic, Chad, Chile, China, Colombia, Comoros, Congo, Congo Democratic Republic, Cook Islands, Costa Rica, Croatia, Cuba, Cyprus, Czech Republic, Denmark, Djibouti, Dominica, Dominican Republic, East Timor, Easter Island, Ecuador, Egypt, El Salvador, Equatorial Guinea, Eritrea, Estonia, Ethiopia, Falkland Islands, Faroe Islands, Fiji, Finland, France, French Guiana, French Polynesia, Gabon, Gambia, Georgia, Germany, Ghana, Gibraltar, Greece, Greenland, Grenada, Guadeloupe, Guam, Guatemala, Guernsey and Alderney, Guinea, Guinea-Bissau, Guyana, Haiti, Honduras, Hungary, Iceland, India, Indonesia, Iran, Iraq, Ireland, Isle of Man, Israel, Italy, Ivory Coast, Jamaica, Japan, Jersey, Jordan, Kazakhstan, Kenya, Kiribati, Korea North, Korea South, Kuwait, Kyrgyzstan, Laos, Latvia, Lebanon, Lesotho, Liberia, Libya, Liechtenstein, Lithuania, Luxembourg, Macedonia, Madagascar, Madeira, Madiera, Malawi, Malaysia, Maldives, Mali, Malta, Marshall Islands, Martinique, Mauritania, Mauritius, Mayotte, Mexico, Micronesia, Moldova, Monaco, Mongolia, Montserrat, Morocco, Mozambique, Myanmar, Namibia, Nauru, Nepal, Netherlands, Netherlands Antilles, New Caledonia, New Zealand, Nicaragua, Niger, Nigeria, Niue, Norfolk Island, Northern Mariana Islands, Norway, Oman, Pakistan, Palau, Palestine, Panama, Papua New Guinea, Paraguay, Peru, Philippines, Pitcairn, Poland, Portugal, Puerto Rico, Qatar, Reunion, Romania, Russia, Rwanda, Saint-Barthelemy, Saint-Martin, Saint Helena, Saint Kitts and Nevis, Saint Lucia, Saint Pierre and Miquelon, Saint Vincent and The Grenadines, Samoa, San Marino, Sao Tome and Principe, Saudi Arabia, Senegal, Serbia and Montenegro, Seychelles, Sicily, Sierra Leone, Singapore, Slovakia, Slovenia, Solomon Islands, Somalia, South Africa, Spain, Sri Lanka, Sudan, Suriname, Svalbard and Jan Mayen, Swaziland, Sweden, Switzerland, Syria, Taiwan, Tajikistan, Tanzania, Thailand, Togo, Tokelau, Tonga, Trinidad and Tobago, Tunisia, Turkey, Turkmenistan, Turks and Caicos, Tuvalu, Uganda, UK, Ukraine, United Arab Emirates, Uruguay, US Virgin Islands, USA, Uzbekistan, Vanuatu, Vatican City, Venezuela, Vietnam, Wallis and Futuna, Western Sahara, Yemen, Zambia, Zimbabwe
world.cities.country <- configuration$world.cities.country


cities <- world.cities %>% filter(country.etc == world.cities.country)
## join on study location == city name
cancerStudies <- merge(x=cancerStudies, by.x="locations", all.x=TRUE, y=dplyr::select(cities, name, lat, long), by.y="name")

# ## where latitude value from postcode lookup is missing, use the latitude from city name lookup
# cancerStudies$latitude[is.na(cancerStudies$latitude)] <- cancerStudies$lat[is.na(cancerStudies$latitude)]
# ## do the same for longitude values
# cancerStudies$longitude[is.na(cancerStudies$longitude)] <- cancerStudies$long[is.na(cancerStudies$longitude)]
# 
# ## drop lat and long columns
# cancerStudies <- dplyr::select(cancerStudies, -c(lat, long))
# 
# ## rename latitude and longitude columns
# # use new_name = old_name syntax
# cancerStudies <- rename(cancerStudies, c("lat"="latitude" ,"long"="longitude"))

```
  

```{r overwrite lat long based on postcode data where available}
## if postcode.lat is not NA, use that value to overwrite lat value
cancerStudies$lat[!is.na(cancerStudies$postcode.lat)] <- cancerStudies$postcode.lat[!is.na(cancerStudies$postcode.lat)]

## likewise for longitude
cancerStudies$long[!is.na(cancerStudies$postcode.long)] <- cancerStudies$postcode.long[!is.na(cancerStudies$postcode.long)]


```


 
#### **Get drug:mechanism and drug:target data**  
      
##### **Get mechanisms from NCI thesaurus**  
     

```{r download and create NCIthesaurus table}

tic("download, parse and write NCI thesaurus to file")

## specify URL for NCI thesaurus - this should always be the most recent? 
NCItURL <- "https://evs.nci.nih.gov/ftp1/NCI_Thesaurus/Thesaurus.FLAT.zip"

destFlatFilename <- "NCIt_FLAT.zip"
download.file(url=NCItURL,destfile = destFlatFilename)
unzip(zipfile = paste0(getwd(),"/",destFlatFilename))

NCIt <- read.table("Thesaurus.txt",header = FALSE, sep = "\t", comment.char = "", fill = TRUE, stringsAsFactors = FALSE, quote = "")
names(NCIt) <- c("ID","URL","ParentID","Synonyms","Description","PreferredTerm","Type","Class")

## a drug may have more than one class, so need to multiply rows
## split and unnest the Class column of NCIt
NCIt$Class <- strsplit(NCIt$Class, split = "\\|")
NCIt <- unnest(data = NCIt, Class)

## subset to retain only relevant classes
NCItPharmacologics <- NCIt[which(NCIt$Class %in% c("Pharmacologic Substance","Amino Acid, Peptide, or Protein","Immunologic Factor","Clinical Drug","Therapeutic or Preventive Procedure", "Health Care Activity")), ]

## additional classes related to prior therapy
#  "Therapeutic or Preventive Procedure", "Health Care Activity"


## one drug can have more than one parent, so need to split into multiple rows...
## split ParentID column on pipe symbol
NCItPharmacologics$ParentID <- strsplit(NCItPharmacologics$ParentID, split = "\\|")
## unnest the ID column to multiply rows
NCItPharmacologics <- unnest(data=NCItPharmacologics,ParentID)

## join parent synonyms
## first, get the synonyms and IDs for parents
NCItParents <- NCIt[which(NCIt$ID %in% NCItPharmacologics$ParentID), which(names(NCIt) %in% c("ID", "Synonyms"))]

## each parent term may have more than one synonym
## for simplicity, we will retain only the first synonym for each parent term
NCItParents$Synonyms <- gsub("\\|.*","",NCItParents$Synonyms)

## merge parents on entity ID = parent ID
NCItPharmacologics <- merge(x=NCItPharmacologics,y=NCItParents,by.x="ParentID",by.y="ID",all.x=TRUE)
## reorder and rename
NCItPharmacologics <- dplyr::select(NCItPharmacologics,ID,Class,PreferredTerm,Synonyms="Synonyms.x",Description,ParentTerm="Synonyms.y",ParentID)

## split the Synonyms column on pipe symbol
NCItPharmacologics$Synonyms <- strsplit(NCItPharmacologics$Synonyms, split="\\|")
## unnest the Synonyms column to multiply rows
NCItPharmacologics <- unnest(data = NCItPharmacologics,Synonyms)

## add a column with lower case drug synonyms for joining
NCItPharmacologics$SynonymsLower <- tolower(NCItPharmacologics$Synonyms)

## convert from tibble to data frame
NCIthesaurus <- as.data.frame(NCItPharmacologics)

## add a column to indicate date downloaded
NCIthesaurus$downloaded <- Sys.Date()

## drop redundant rows, if any
NCIthesaurus <- unique(NCIthesaurus)

toc()

```
  
##### **Get targets from KEGG**  
     

```{r get molecular targets for cancerStudies interventions}
## first, get all interventions (note that there will be some redundancy due to case)
drugs.targets <- unique(dplyr::select(cancerStudies,interventions))
## keep interventions column as verbatim so can join later
## make a duplicate column
drugs.targets$interventions.processed <- drugs.targets$interventions


## split and unnest on " + "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\+ ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " plus "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " plus ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " and "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " and ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " & "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\& ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " or "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " or ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " (+) "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(\\+\\) ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " with "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " with ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

## also split on brackets
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# remove closing bracket
drugs.targets$interventions.processed <- gsub(pattern = "\\)", replacement = "", x=drugs.targets$interventions.processed)


## trim off anything related to dose
# pattern is (a number, with or without a decimal point) with/without a space, followed by "mg", anything after "mg is removed
drugs.targets$interventions.processed <- gsub(pattern = " \\d+\\.?\\d+ ?mg.*", replacement = "", x=drugs.targets$interventions.processed, ignore.case = T)


## join to NCIthesaurus so that any intervention not represented in the thesaurus is dropped
drugs.targets <- merge(x=drugs.targets, 
      by.x = "interventions.processed", 
      y= unique(dplyr::select(NCIthesaurus, Synonyms, Description, ParentTerm)), 
      by.y = "Synonyms")

## try to map each processed intervention to a Drug IDs from KEGG
## add an empty column to hold drug ID
drugs.targets$drugID <- NA
tic("get IDs for drugs")
for(i in 1:nrow(drugs.targets)) {
  drugid <- NA
  drugSynonym <- as.character(drugs.targets$interventions.processed[i])
  #print(drugSynonym)
  ## get (onlY) first drug ID
  tryCatch({drugid <- names(keggFind(database = "drug", query = drugSynonym))[1]},
             error=function(cond) {return(NA)})
  if(length(drugid)>0 ) {
    #print(drugid)
    drugs.targets$drugID[i] <- drugid}
}
toc()

## separate off drug IDs
targets <- as.data.frame(unique(dplyr::select(drugs.targets, drugID)))
## add a column to hold drug target ID
targets$drugTargetID <- NA
## add a column to hold Entrez symbol for drug target
targets$drugTargetSymbol <- NA
## drop rows without a drugID
targets <- targets[!is.na(targets$drugID),]

## use drug IDs to get gene IDs for target genes
for(i in 1:nrow(targets)) {
  drugid <- targets$drugID[i]
  geneid <- NA
  tryCatch({geneid <- keggGet(drugid)[[1]]$TARGET$TARGET},
             error=function(cond) {return(NA)})
  #print(geneid)
  if(length(geneid)>0) targets$drugTargetID[i] <- geneid
}

## parse the drugTargetID values - trim off extra characters and unnest where multiple targets per drug
## drop any columns that don't contain "HSA:"

#trim everything up to "HSA:"
targets$drugTargetID <- gsub(pattern = ".*\\HSA:", replacement = "", x=targets$drugTargetID)
# trim everything after square bracket
targets$drugTargetID  <- gsub(pattern = "\\].*", replacement = "", x=targets$drugTargetID )
# split on space into individual ids, where applicable
targets$drugTargetID <- strsplit(targets$drugTargetID, split = " ")
targets <- unnest(data = targets, drugTargetID)
targets <- as.data.frame(targets)
## drop rows where drugTargetID is NA
targets <- targets[!is.na(targets$drugTargetID), ]

# paste on a "hsa:"
targets$drugTargetID <- paste0("hsa:",targets$drugTargetID)

## use drugTargetId to get names (Entrez Symbols) for target genes
for(i in 1:nrow(targets)) {
  targetId <- targets$drugTargetID[i]
  #print(paste0("i= ", i, "; ID = ", targetId))
  name <- NA
  tryCatch({name <- keggGet(targetId)[[1]]$NAME[1]},
             error=function(cond) {return(NA)})
  if(length(targetId)>0) {
    #name <- keggGet(targetId)[[1]]$NAME[1]
    #print(name)
    targets$drugTargetSymbol[i] <- name
  }
}

## drugTargetSymbol may hold several comma separated values
## first value appears to be Entrez symbol
## trim off everything after first comma
targets$drugTargetSymbol <- gsub(pattern = ",.*", replacement = "", x=targets$drugTargetSymbol )

## join drugTargetSymbol values to drugs.targets table
drugs.targets <- merge(x=drugs.targets, by.x="drugID", all.x=TRUE,
                       y=unique(dplyr::select(targets, drugID, drugTargetSymbol)), by.y = "drugID")

## reorder columns
drugs.targets <- unique(dplyr::select(drugs.targets,"interventions.verbatim"= "interventions", interventions.processed, Description, ParentTerm, drugTargetSymbol))
```

##### **Write drugsTargets table to database**  
     

 
```{r create table of drugs and targets}
## preview
formattable(head(drugs.targets))

## create as a table in database
dbWriteTable(conn = con,name = "drugsTargets", value = drugs.targets, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
#### **Append mechanisms to cancerStudies table**  


```{r join mechanisms to cancerStudies}
## join on interventions.verbatim == interventions
cancerStudies <- merge(x=cancerStudies, by.x="interventions", all.x=TRUE, 
                       y=unique(dplyr::select(drugs.targets, interventions.verbatim, ParentTerm)), by.y="interventions.verbatim")



```

  
 
```{r create table of studies}
## preview
formattable(head(cancerStudies))

## create as a table in database
dbWriteTable(conn = con,name = "cancerStudies", value = cancerStudies, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
   
#### **Index eligibility criteria for cancer studies**  
      
  
```{r get eligibility criteria for cancer studies}
# studyIDs <- unique(cancerStudies$nct_id)
# 
# ## form SQL query
# studyIDsForSQL <- paste0("\'",paste(studyIDs, collapse = "\',\'"), "\'")
# getEligibilities <- paste0("select e.nct_id, e.criteria 
# from eligibilities e
# where e.nct_id in (",
# "", studyIDsForSQL,
# ")")
# 
# ## get criteria from clinicaltrials.gov
# eligibilities <- dbGetQuery(conn2,getEligibilities)

```

```{r retain individual eligibility criteria containing mutant pattern}


## add a column to indicate criterion type
eligibilities$criterion.type <- NA



## split into individual criteria
for(i in 1:length(eligibilities$criteria)) {
  criteria <- as.character(eligibilities$criteria[i])
  #criteria <- unlist(strsplit(criteria, split = "\n\n"))## split on double line breaks (DEPRECATED)
  criteria <- unlist(strsplit(criteria, split = "\r\n\r\n"))## split on double newline/carriage return
  criteria <- trimws(x=criteria, which = "both")## trim whitespace from start and end
  criteria <- gsub(pattern = "\n", replacement = "", x= criteria)## remove single line breaks from each criterion
  criteria <- str_squish(string = criteria) ## squish repeated spaces within each criterion
  #criteria <- as.list(criteria)
  eligibilities$criteria[i] <- list(criteria)
}


## unnest
eligibilities <- as.data.frame(unnest(data = eligibilities, cols = criteria))
eligibilities$criterion.type[1] <- "INCLUSION"
```


```{r classify eligibility criteria}
## classify as either inclusion or exclusion
## tag start of inclusion criteria
eligibilities$criterion.type[grep(pattern = "inclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "INCLUSION"

## tag start of exclusion criteria
eligibilities$criterion.type[grep(pattern = "exclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "EXCLUSION"

## fill "down" using the tdiyr::fill() function
eligibilities <- tidyr::fill(data=eligibilities, criterion.type, .direction="down")


## add a column to indicate feature referenced by text 
eligibilities$feature <- NA
## add a column that will hold matching term (e.g. gene names)
eligibilities$match <- NA
```
  
```{r define indexing function}
indexOnPattern <- function(eligibilities, pattern, wordRange, featureLabel) {
  table <- eligibilities
  pattern <- pattern
  wordRange <- wordRange
  featureLabel <- featureLabel
  ## get indices containing specified pattern
  indices <- grep(pattern = pattern, x=table$criteria, ignore.case = T) 
  # subset table 
  table <- table[indices, ]
  # label nature of change
  table$feature <- featureLabel
  
  ## loop through each criterion that contains pattern
  for(i in 1:nrow(table)) {
    criterion <- table$criteria[i]
    # also create an alternative criterion for patterns such as "BRCA1/2"
    alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
    # concatenate
    criterion <- paste(criterion,alternative.criterion, sep = " " )
    # split into tokens
    criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
    ## criterion is now a vector of tokens (words, but also some empty elements)
    ## remove any empty elements in criterion 
    criterion <- criterion[criterion!=""]
    
    ## get indices of match(es) against pattern (need to squish preceding space)
    indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
    ## specify start and end point(s) based on specified word range
    starts <- indices - wordRange
    ends <- indices + wordRange
    range <- numeric(0)
    for(j in 1:length(starts)) { ## because there may be more than one match
      if(starts[j] <1) {starts[j] <- 1}
      range <- append(range,starts[j]:ends[j])
    } ## now range contains the indices of the words either side of the pattern, within specified word range
    range <- unique(range) ## if the ranges overlap, just get the unique elements
    ## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
    ## subset the criterion retain only words within specified range
    criterion <- criterion[range]
    ## omit any NA values (i.e. where match is less than wordRange from end of sentence)
    criterion <- criterion[!is.na(criterion)]
    ## now subset and retain only words that are a valid gene alias
    criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
    ## drop any aliases that are a single or 2 characters
    criterion <- criterion[nchar(criterion)>2]
    ## drop any matches against the word "not"
    criterion <- criterion[criterion != "not"]
    if(length(criterion)>0) table$match[i] <- list(criterion)
  }
  ## drop rows not indexed against a gene
  table <- table[!is.na(table$match), ]
  ## unnest
  table <- as.data.frame(unnest(table, cols = "match"))
  
  
  ## join to Entrez symbols from humanGenes
  table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
  
  ## rename Symbol to "controlled.match"
  table <- rename(table, "controlled.match"="Symbol")
  ## drop redundant rows
  table <- unique(table)
  ## return table
  return(table)
}




```

  
  
  
##### **Index on mutations**  
     
  
```{r index criteria on mutations}

## call indexing function
## exclude matches containing "positive" as these tend to be IHC, not mutation
## also exclude "loss" as this is included in rearrangementPattern

mutation.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function", wordRange = 6, featureLabel = "mutation")

## preview
formattable(head(mutation.eligibilities))
```
  
##### **Index on fusions (not currently used)**  
     
  
```{r index criteria on fusions}

## NOT USED BECAUSE SUPERCEDED BY INDEX ON REARRANGEMENTS
fusion.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement", wordRange = 7, featureLabel = "fusion")

## preview
formattable(head(fusion.eligibilities))
```
  
##### **Index on rearrangements**  
     
  
```{r index criteria on rearrangements}

rearrangement.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement|truncation|truncated|deletion|loss|deleted|lost|duplication|duplicated", wordRange = 6, featureLabel = "rearrangement")

## preview
formattable(head(rearrangement.eligibilities))
```
    
##### **Index on copy number loss**  
     
  
```{r index criteria on copy number loss}

loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " amplification|overexpression", wordRange = 5, featureLabel = "amplification")

## preview
formattable(head(loss.eligibilities))

```
    

    
  
##### **Index on amplifications**  
     
  
```{r index criteria on amplifications}

amplification.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " amplification|overexpression", wordRange = 5, featureLabel = "amplification")

## preview
formattable(head(rearrangement.eligibilities))

```
  

##### **Index on performance status**  
  
<<not developed yet>>    

  
##### **Store criteria related to prior therapies**  
     
  
```{r index criteria on prior therapies}
## create a copy of eligibilities
therapy.eligibilities <- eligibilities

## filter to retain criteria with mention of "previous|prior"
# define pattern
therapyFilter <- "previous therapy|prior therapy|previous treatment|prior treatment"
# filter
therapy.eligibilities <- therapy.eligibilities[grep(pattern = therapyFilter, ignore.case = TRUE, x=therapy.eligibilities$criteria), ]
# set value for feature
therapy.eligibilities$feature <- "PRIOR_THERAPY"

## drop redundant rows, if any
therapy.eligibilities <- unique(therapy.eligibilities)

## since prior therapies tend to be a mixture of 2-word synonyms, 3-word synonyms etc, plus parent terms, best approach for now is to not try and match against a therapy

# add a controlled.match column for row binding only
therapy.eligibilities$controlled.match <- NA

## instead, in the UI, just show inclusion and exclusion criteria (separately) related to prior therapies

formattable(head(therapy.eligibilities))
```
      

##### **Write indexedEligibility table to database**  
  
  
```{r row bind indexed eligbility tables}
# indexed.eligibilities <- unique(rbind(mutation.eligibilities, fusion.eligibilities,  amplification.eligibilities, therapy.eligibilities))


indexed.eligibilities <- unique(rbind(mutation.eligibilities, rearrangement.eligibilities,  amplification.eligibilities, therapy.eligibilities))



```

```{r create table of indexed eligibility criteria}
## preview
#formattable(head(indexed.eligibilities))

## create as a table in database
dbWriteTable(conn = con,name = "indexedEligibility", value = indexed.eligibilities, overwrite=TRUE)

## check it has saved
dbListTables(con)

```

#### **Get pathway graph data from KEGG**  
  
  
```{r get edge list}


## download KGML file for Pathways In Cancer as KGML file
pathwaysInCancer_KGML <- get_KGML("hsa05200")
#class(pathwaysInCancer_KGML)

## expand mappings
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML, convert_KEGG_IDs = FALSE)
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML)
pathwaysInCancer_edges <- expand_KEGG_edges(pathwaysInCancer_KGML, pathwaysInCancer_mappings)

## create a simple edgelist
edgelist <- unique(dplyr::select(pathwaysInCancer_edges, "from"="entry1symbol", "to"="entry2symbol", specific_subtype, value))



#Modify existing data sets; specify as nodes and edges
pathwaysInCancer_node_mapping_info <- node_mapping_info(pathwaysInCancer_mappings)

pathwaysInCancer_edge_mapping_info <- edge_mapping_info(pathwaysInCancer_edges)

#Create an igraph object
pathwaysInCancer.igraph <- get_graph_object(pathwaysInCancer_node_mapping_info, pathwaysInCancer_edge_mapping_info)

## get edgelist
edges <- as_data_frame(pathwaysInCancer.igraph, what = c("edges"))

## retain only edges where "from" is a gene
edges <- unique(dplyr::filter(edges, entry1type=="gene"))

## drop unnecessary columns
# keep edge IDs fur use in graph analysis 
edges <- unique(dplyr::select(edges, "from"="entry1symbol", "to"="entry2symbol",edgeID, specific_subtype, tooltip))


## unnest the from and to columns
edges$from <- strsplit(edges$from, split = ",")
edges <- unnest(edges, cols = "from")

edges$to <- strsplit(edges$to, split = ",")
edges <- unnest(edges, cols = "to")

## convert back to dataframe
edges <- as.data.frame(edges)


```

  

```{r create table of edges}
## preview
formattable(head(edges))

## create as a table in database
dbWriteTable(conn = con,name = "edges", value = edges, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
  
#### **Score matches against trials**  
  
```{r score matches on gene intervention target}

## start with studies and their interventions
targetMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
## join to drugs.targets on intervention name (verbatim)
targetMatches <- merge(x=targetMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
## drop rows where drugTargetSymbol is NA
targetMatches <- targetMatches[!is.na(targetMatches$drugTargetSymbol), ]

## drop unnecessary columns
targetMatches <- unique(dplyr::select(targetMatches, nct_id, interventions.processed, drugTargetSymbol))

## add rationale column
targetMatches$intervention_rationale <- paste0("Study drug (", targetMatches$interventions.processed, ") targets ", targetMatches$drugTargetSymbol)

## drop intervention column
targetMatches <- unique(dplyr::select(targetMatches, -interventions.processed))

## rename drugTargetSymbol column
targetMatches <- rename(targetMatches,"symbol"= "drugTargetSymbol")

## add a score
targetMatches$intervention_score <- 2

```

```{r score matches on pathway}
## start with studies and their interventions
pathwayMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
## join to drugs.targets on intervention name (verbatim)
pathwayMatches <- merge(x=pathwayMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
## drop rows where drugTargetSymbol is NA
pathwayMatches <- pathwayMatches[!is.na(pathwayMatches$drugTargetSymbol), ]
## drop unnecessary columns
pathwayMatches <- unique(dplyr::select(pathwayMatches, nct_id, interventions.processed, drugTargetSymbol))

## join to edges, where drugTargetSymbol == to
## i.e. intervention targets the downstream node
pathwayMatches <- merge(x=pathwayMatches, by.x="drugTargetSymbol", y=edges, by.y="to")

## select and rename columns
pathwayMatches <- unique(dplyr::select(pathwayMatches,nct_id, interventions.processed, "downstream"="drugTargetSymbol","upstream"="from" ))

## where an intervention targets >1 gene, aggregate
pathwayMatches <- as.data.frame(pathwayMatches %>%
                group_by(nct_id, interventions.processed, upstream) %>%
                summarise(
                  downstream = paste(unique(downstream), collapse = ", ")
                ))

## add rationale column
pathwayMatches$intervention_rationale <- paste0("Study drug (", pathwayMatches$interventions.processed, ") targets downstream gene(s) (", pathwayMatches$downstream, ")")

## drop intervention column
pathwayMatches <- unique(dplyr::select(pathwayMatches, -c(interventions.processed, downstream)))

## rename upstream column to drugTargetSymbol to match targetMatches
pathwayMatches <- rename(pathwayMatches, "symbol"="upstream")

## add a score
pathwayMatches$intervention_score <- 1
```

```{r row bind target and pathway matches}

scoredMatches <- rbind(targetMatches, pathwayMatches)

## for genes that don't have a match in eligilityMatches, we want to be able to match on gene alone, regardless of variant_type... 
scoredMatches$variant_type <- list(c("mutation", "fusion", "amplification"))

## unnest to multiply rows
scoredMatches <- data.frame(unnest(scoredMatches, cols = "variant_type"))

```




```{r score matches on inclusion criteria}
## start with indexed eligibilities
eligibilityMatches <- unique(dplyr::select(indexed.eligibilities, nct_id,"gene"="controlled.match",criterion.type, feature, criteria ))

## filter out matches against exclusion criteria
eligibilityMatches <- filter(eligibilityMatches, criterion.type=="INCLUSION")

## filter out matches against prior therapy
eligibilityMatches <- filter(eligibilityMatches, feature!="PRIOR_THERAPY")

## concatenate gene and feature
# eligibilityMatches$gene <- paste(eligibilityMatches$gene, eligibilityMatches$feature, sep = " ")

## add rationale column
eligibilityMatches$eligibility_rationale <- paste0("Enrolling subjects with ", eligibilityMatches$gene, " ", eligibilityMatches$feature)



## add a score
eligibilityMatches$eligibility_score <- 3

## where multiple criteria, aggregate
eligibilityMatches <- as.data.frame(eligibilityMatches %>%
                group_by(nct_id, gene, criterion.type, feature, eligibility_rationale, eligibility_score) %>%
                summarise(
                  criteria = paste(unique(criteria), collapse = "\n\n")
                ))


## select and rename columns to match targetMatches and pathwayMatches
eligibilityMatches <- unique(dplyr::select(eligibilityMatches, nct_id, "symbol"="gene", "variant_type" = "feature", eligibility_rationale, "matching_criteria"="criteria", eligibility_score))


```

```{r join eligibility matches to scored matches}
scoredMatches <- merge(x=scoredMatches, by.x=c("nct_id", "symbol", "variant_type"), all.x=TRUE, 
      y=eligibilityMatches, by.y = c("nct_id", "symbol", "variant_type"), all.y=TRUE)

## add a combined score
scoredMatches$combined_score <- rowSums(scoredMatches[,c("intervention_score", "eligibility_score")], na.rm=TRUE)

## conatenate symbol and variant_type columns to get <gene name> <variant_type>, e.g. "EGFR mutation"
scoredMatches$gene_variant_type <- paste(scoredMatches$symbol, scoredMatches$variant_type, sep=" ")

## select and reorder columns
scoredMatches <- unique(dplyr::select(scoredMatches, symbol, variant_type,gene_variant_type, nct_id, intervention_rationale, eligibility_rationale, matching_criteria, combined_score))

## order on combined_score descending
scoredMatches <- scoredMatches[order(scoredMatches$combined_score, decreasing = TRUE), ]


```


```{r create table of scored matches}
## preview
formattable(head(scoredMatches,10))

## create as a table in database
dbWriteTable(conn = con,name = "scoredMatches", value = scoredMatches, overwrite=TRUE)

## check it has saved
dbListTables(con)

```


```{r score matches on variant sensitivity}
## start with evidence data
variantMatches <- unique(dplyr::select(evidence, variant_id, drugs, evidence_type, evidence_direction, clinical_significance))

## join variant info
variantMatches <- merge(x=variantMatches, by.x="variant_id", y=dplyr::select(variants, variant_id, gene, variant), by.y="variant_id")

## drop rows where drugs == NA
variantMatches <- variantMatches[!is.na(variantMatches$drugs), ]

## drop rows where evidence_direction does not support
variantMatches <- variantMatches[variantMatches$evidence_direction=="Supports", ]

## drop unnecessary columns
variantMatches <- unique(dplyr::select(variantMatches, gene, variant, clinical_significance, drugs))

## apply underscore consistently for mutations, amplifications, fusions
variantMatches$variant[grep(pattern = "mutation", x=variantMatches$variant, ignore.case = T)] <- "mutation"
variantMatches$variant[grep(pattern = "amplification", x=variantMatches$variant, ignore.case = T)] <- "amplification"
variantMatches$variant[grep(pattern = "fusion", x=variantMatches$variant, ignore.case = T)] <- "fusion"





## if more than one interpretation for a gene-variant-drug combination, aggregate
variantMatches <- as.data.frame(variantMatches %>%
                  group_by(gene,variant, drugs) %>%
                  summarise(
                      clinical_significance = paste(unique(clinical_significance), collapse = ", ")
                  ))
# drop those rows that have >1 interpretation (based on presence of comma)
variantMatches <- variantMatches[-grep(pattern = ",", x=variantMatches$clinical_significance), ]

## join to intervention names as per clinicaltrials.gov
variantMatches <- merge(x=variantMatches, by.x="drugs", y=unique(dplyr::select(drugs.targets, interventions.verbatim, interventions.processed)), by.y="interventions.processed")

## add rationale column
variantMatches$rationale <- paste0(variantMatches$gene, " ", variantMatches$variant, " predicts ", variantMatches$clinical_significance, " to study intervention (", variantMatches$drugs, ")")

## add score column
variantMatches$score <- ifelse(variantMatches$clinical_significance=="Sensitivity/Response", yes=3, no=-3)


## join to cancerStudies
variantMatches <- merge(x=variantMatches, 
      by.x="interventions.verbatim", 
      y=unique(dplyr::select(cancerStudies, nct_id, interventions)), 
      by.y="interventions")

## create gene_variant values
variantMatches$gene_variant <- paste(variantMatches$gene, variantMatches$variant, sep = " ")

## select and rename columns to match targetMatches etc
variantMatches <- unique(dplyr::select(variantMatches, nct_id, "symbol"="gene_variant", rationale, score))
```

```{r row bind scored matches}
# scoredMatches <- rbind(eligibilityMatches, targetMatches, pathwayMatches)
# 
# ## aggregate where mutliple lines of rationale per gene-study
# scoredMatches <- as.data.frame(scoredMatches %>%
#                 group_by(nct_id, symbol) %>%
#                 summarise(
#                   rationale = paste(unique(rationale), collapse = ", "), 
#                   score = sum(score)
#                 ))

```



```{r disconnect from  database}

# disconnect from clincialtrials.gov
dbDisconnect(conn2)

# Disconnect from SQLite database
dbDisconnect(con)


```
  
`r knitr::knit_exit()`    
  
  
```{r preview graph}
## fourth, plot graph... 
graph <- graph_from_data_frame(d=edges, directed=T)
## look at the nodes
#V(graph)

## look at the edges
#E(graph)


#plot(graph, layout=layout_as_tree(graph))



## get a list of nodes that represent the roots (i.e. the most upstream nodes)
## i.e. nodes that are source nodes (in edges$from) but not target nodes (not in edges$to)
rootNodes <- unique(setdiff(edges$from, edges$to))
# rootNodes
# plot(graph, layout=layout_as_tree(graph, root=rootNodes,mode="out"))


## get degrees of nodes
deg <- degree(graph, mode="all")
# plot(graph, layout=layout_as_tree(graph, root=rootNodes,mode="out"),edge.arrow.size=0.2, vertex.label.cex=0.5, vertex.size=deg*3)
  

##As a test, get a list of all vertices (nodes) downstream of KRAS
KRASdownstreamNodes <- subcomponent(graph, "KRAS", mode = c("out"))
## get all downstream nodes as a vector
KRASdownstreamNodes$name

##create a subgraph of a graph, containing only the specified vertices and all the edges among them
KRASdownstreamGraph <- induced_subgraph(graph=graph, vids = KRASdownstreamNodes, impl = "auto")



## find paths e.g. from KRAS to CCND1
#all_simple_paths(graph, "KRAS", "CCND1")

## find single shortest path from KRAS to AKT1
shortest.KRAS.AKT1.path <- shortest_paths(graph=KRASdownstreamGraph, from="KRAS", to = "AKT1", mode = c("out"), weights = NULL, output = "both",
  predecessors = FALSE, inbound.edges = FALSE)



## display edges in shortest path
shortest.KRAS.AKT1.path$epath[[1]]

## also, would depth-first search be useful? see https://stackoverflow.com/questions/16783095/use-a-list-of-edges-to-draw-a-graph

## see also http://cneurocvs.rmki.kfki.hu/igraphbook/igraphbook-iterators.html#id2530580 

```




      



### **Map trial interventions to biological pathway based on their molecular target**  

#### **Create cancerPathways table**  

```{r get data from KEGG}

## get all networks for Pathways in Cancer (hsa05200) from KEGG, and filter to retain only those targeted by an intervention in an open UK cancer study 
## (i.e. of known cancer pathways, which ones are currently being targeted by UK studies?)
## can't get it for all cancers, have to do it for each individual cancer type: 

if(!file.exists("cancerPathways.tsv")) {
## specify a table of network IDs for cancer pathways
cancerPathways <- data.frame(network.name = character(0), 
                             network.id = character(0))
cancerPathways <- cancerPathways %>% add_row(network.name = "Colorectal cancer", 
                           network.id = "hsa05210")
cancerPathways <- cancerPathways %>% add_row(network.name = "Gastric cancer", 
                           network.id = "hsa05226")
cancerPathways <- cancerPathways %>% add_row(network.name = "Pancreatic cancer", 
                           network.id = "hsa05212")
cancerPathways <- cancerPathways %>% add_row(network.name = "Hepatocellular carcinoma", 
                           network.id = "hsa05225")
cancerPathways <- cancerPathways %>% add_row(network.name = "Renal cell carcinoma", 
                           network.id = "hsa05211")
cancerPathways <- cancerPathways %>% add_row(network.name = "Bladder cancer", 
                           network.id = "hsa05219")
cancerPathways <- cancerPathways %>% add_row(network.name = "Non-small cell lung cancer", 
                           network.id = "hsa05223")
cancerPathways <- cancerPathways %>% add_row(network.name = "Small cell lung cancer", 
                           network.id = "hsa05222")
cancerPathways <- cancerPathways %>% add_row(network.name = "Melanoma", 
                           network.id = "hsa05218")
cancerPathways <- cancerPathways %>% add_row(network.name = "Basal cell carcinoma", 
                           network.id = "hsa05217")
cancerPathways <- cancerPathways %>% add_row(network.name = "Breast cancer", 
                           network.id = "hsa05224")
cancerPathways <- cancerPathways %>% add_row(network.name = "Endometrial cancer", 
                           network.id = "hsa05213")
cancerPathways <- cancerPathways %>% add_row(network.name = "Prostate cancer", 
                           network.id = "hsa05215")
cancerPathways <- cancerPathways %>% add_row(network.name = "Glioma", 
                           network.id = "hsa05214")
cancerPathways <- cancerPathways %>% add_row(network.name = "Thyroid cancer", 
                           network.id = "hsa05216")
cancerPathways <- cancerPathways %>% add_row(network.name = "Acute myeloid leukaemia", 
                           network.id = "hsa05221")
cancerPathways <- cancerPathways %>% add_row(network.name = "Chronic myeloid leukaemia", 
                           network.id = "hsa05220")


## add a column that will hold a list of network elements for each network
cancerPathways$network.elements <- NA

tic("get KEGG networks")
for(i in 1:length(cancerPathways$network.id)) {
  network.id <- cancerPathways$network.id[i]
  pathway.list <- keggGet(network.id)
  cancerPathways$network.elements[i] <- list(pathway.list[[1]]$NETWORK$ELEMENT)
}

toc()

## unnest the network.elements column to get a table with one row per network element per cancer type
cancerPathways <- data.frame(unnest(cancerPathways, cols = "network.elements"))

cancerPathways$network.element.id <- gsub(pattern = " .*", replacement = "", x=cancerPathways$network.elements)

cancerPathways$network.element.name <- gsub(pattern = ".*  ", replacement = "", x=cancerPathways$network.elements)

## add a column that will hold the network element "definition"
cancerPathways$network.element.definition <- NA
## add a column that will hold the "expanded" (i.e. gene IDs) definition
cancerPathways$network.element.definition.expanded <- NA
## add a column that will hold the names of genes in the elements
cancerPathways$network.element.gene.names <- NA
## add a column that will hold the IDs (minus hsa: prefix) of genes in the elements
cancerPathways$network.element.gene.ids <- NA

tic("get network element definitions")
for(i in 1:length(cancerPathways$network.element.id)) {
  element.id <- cancerPathways$network.element.id[i]
  element.list <- keggGet(element.id)
  cancerPathways$network.element.definition[i] <- element.list[[1]]$DEFINITION$DEFINITION
  cancerPathways$network.element.definition.expanded[i] <- element.list[[1]]$DEFINITION$EXPANDED
  element.genes <- element.list[[1]]$GENE
  ## gene names are stored in even numbered elements
  evens <- seq(from = 2, to=length(element.genes), by=2)
  element.gene.names <- element.genes[evens]
  ## trim off everything after semicolon
  element.gene.names <- gsub(pattern = ";.*", replacement = "", x=element.gene.names)
  cancerPathways$network.element.gene.names[i] <- list(element.gene.names)
  
  odds <- seq(from = 1, to=length(element.genes), by=2)
  element.gene.ids <- element.genes[odds]
  #element.gene.ids <- paste0("hsa:",element.gene.ids)
  cancerPathways$network.element.gene.ids[i] <- list(element.gene.ids)
}
toc()
## unnest the network.element.gene.names column to get a table with one row per gene per network element per cancer type
cancerPathways <- unnest(cancerPathways, cols=c("network.element.gene.names", "network.element.gene.ids"))

## THE GENE NAMES IN THE DEFINITION DON'T MATCH THOSE IN THE GENE LIST (!)
## e.g. "SOS" in network element N00005 corresponds to gene names "SOS1" and "SOS2"
## WE NEED TO REPLACE THE GENE IDS IN THE EXPANDED DEFINITIONS WITH THE CORRESPONDING GENE NAMES

## first, make a lookup table of gene ids and names
gene.lookup <- data.frame(unique(dplyr::select(cancerPathways, network.element.gene.names, network.element.gene.ids)))

## need to trim off v suffixes from gene ids
cancerPathways$network.element.definition.expanded <- gsub(pattern = "v.", replacement = "", x=cancerPathways$network.element.definition.expanded)

tic("gene lookup")
## loop through the lookup table and replace the gene ids in expanded definition column with gene names
## need to do whole-word match using \\b ... \\b
for(i in 1:nrow(gene.lookup)) {
  pattern <- gene.lookup$network.element.gene.ids[i]
  replacement <- gene.lookup$network.element.gene.names[i]
  cancerPathways$network.element.definition.expanded <- gsub(pattern=paste0("\\b", pattern, "\\b"), replacement = replacement, x=cancerPathways$network.element.definition.expanded)
}
toc()
## delete the brackets
cancerPathways$network.element.definition.expanded <- gsub(pattern = "\\(|\\)", replacement = "", x=cancerPathways$network.element.definition.expanded)


## add a column that will hold downstream pathway info
cancerPathways$downstream <- NA

tic("loop through cancer pathways")

for(i in 1:nrow(cancerPathways)) {
  pattern = paste0(".*",cancerPathways$network.element.gene.names[i])
  replacement = cancerPathways$network.element.gene.names[i]
  cancerPathways$downstream[i] <- gsub(pattern = pattern, replacement = replacement, x=cancerPathways$network.element.definition.expanded[i])
}

toc()

## ultimately, we want to join to trial info on the basis of downstream gene name == target gene name for intervention
## therefore we need a column that contains the names of genes downstream of every given gene in very pathway
## currently downstream genes are stored in the "downstream" column, need to split first on spaces, then on commas

## add a column that will hold names of downstream genes
cancerPathways$downstream.genes <- cancerPathways$downstream
## split on space
cancerPathways$downstream.genes <- strsplit(cancerPathways$downstream.genes, split = " ")
cancerPathways <- unnest(cancerPathways, cols = "downstream.genes")
## now we need to filter out rows that contain only the edges (->, -|, //, =>, =| etc)
cancerPathways <- cancerPathways[!cancerPathways$downstream.genes %in% c("->", "-|", "//", "=>", "--", "=|" ), ]

## split again on comma or plus symbol
cancerPathways$downstream.genes <- strsplit(cancerPathways$downstream.genes, split = ",|+ ")
## unnest again
cancerPathways <- unnest(cancerPathways, cols = "downstream.genes")


## write to tsv
write.table(cancerPathways, file = "cancerPathways.tsv", sep = "\t",
            row.names = FALSE, col.names = names(cancerPathways)) } else  {cancerPathways <- read.table(file = "cancerPathways.tsv", header = TRUE, sep = "\t", stringsAsFactors = FALSE)}

```

```{r preprocess cancerPathways table}

## Drop unwanted columns, save only unique combinations
cancerPathways.trimmed <- unique(dplyr::select(cancerPathways, network.name, network.element.name, network.element.gene.names, downstream, downstream.genes))

## Group by all except network.name - i.e. Aggregate cancer types into a single value
cancerPathways.trimmed <-data.frame(cancerPathways.trimmed %>%
               group_by_at(vars(-network.name))  %>%
               summarise(network.name = paste(unique(network.name), collapse = ",")))

```

```{r preprocess targetMatches table}
## Drop unwanted columns, save only unique combinations 
pathwayMatches <- unique(dplyr::select(targetMatches, nct_id, Interventions, Target, Mechanism))

```

#### **Create pathwayMatches table**  

```{r left join cancerpathways to targetmatches}
## left join on cancerPathways.trimmed$downstream.genes = target.Matches$Target
pathwayMatches <- merge(x=cancerPathways.trimmed, by.x = "downstream.genes", y=pathwayMatches, by.y = "Target")

## drop rows where network.element.gene.names == downstream.genes
pathwayMatches <- filter(pathwayMatches, downstream.genes!=network.element.gene.names)

```

```{r write pathway matches to tsv}
#dim(pathwayMatches)

## write full table of all pathway matches to tsv
write.table(pathwayMatches, file = "pathwayMatches.tsv", sep = "\t",
            row.names = FALSE, col.names = names(pathwayMatches))

```
  
Mappings between cancer studies, interventions and biological pathways have been written to file pathwayMatches.tsv. First few rows are as follows:  
  
```{r preview pathwayMatches table}

kable(head(pathwayMatches)) %>%
  kable_styling(bootstrap_options = "striped") %>%
  kable_styling(fixed_thead = T)

```


































  

```{r delete big files from memory}
# rm(NCIt)
# rm(NCIthesaurus)
# rm(NCItPharmacologics)
# rm(humanGenes)
# rm(world.cities)
```

  
### **Specify mappings between cancer types and synonyms based on csv file**  
  
Mappings between synonyms (cancer types specified in clinicaltrials.gov condition.name field) and controlled cancer types are specified by the file conditionSynonyms4.csv. The following mappings between have been used:  
  
  
```{r read conditionSynonyms table}
## conditionSynonyms specifies which cancer types are of interest, and which condition names (as used by clinicaltrials.gov) will be considered as matches for each

## synonyms define on basis of those in clinicaltrials.gov
conditionSynonyms <- read.csv(file = "conditionSynonyms4.csv", stringsAsFactors = FALSE)

## remove redundancy, if any
conditionSynonyms <- unique(conditionSynonyms)

## display conditions and synonyms used
formattable(as.data.frame(conditionSynonyms %>% 
                  group_by(controlled.cancer.type) %>%
                  summarise(
                  synonyms = paste(condition.synonyms, collapse = ", "))))
```
  
  
### **Index studies on cancer type**  

### **Locations of all cancer study sites identified**  
  

There are currently **`r length(unique(cancerStudies$nct_id))`** cancer studies in clinicaltrials.gov with sites in the specified country that are open to recruitment or not yet recruiting.    
  
```{r print a map with study sites indicated}
locations.cancer.studies <- unique(dplyr::select(cancerStudies, nct_id, lat, long))

## zoomed and centred based on parameters in configuration file...
leaflet() %>%
    addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
    setView(lat = configuration$zoom.lat, 
            lng = configuration$zoom.long, 
            zoom = 6) %>%
    addMarkers(lat = locations.cancer.studies$lat, 
               lng = locations.cancer.studies$long, 
               label = locations.cancer.studies$nct_id,
               clusterOptions = markerClusterOptions())

```
  
  
```{r write cancerStudies table to file}

## write to tab-separated file    
write.table(cancerStudies, file = "cancerStudies.tsv", sep = "\t",
            row.names = FALSE, col.names = names(cancerStudies))
```
  
  
Cancer studies table has been written to file (cancerStudies.tsv), first few lines are as follows:  
  


```{r preview cancerStudies table}
#dim(cancerStudies)

kable(head(cancerStudies)) %>%
  kable_styling(bootstrap_options = "striped") %>%
  kable_styling(fixed_thead = T)

## save a list of study IDs matched on condition to use later
studyIDs <- unique(cancerStudies$nct_id)

```

### **Index inclusion criteria for cancer studies on human gene name**

This code requires a list of all human genes and their synonyms, accessible from https://www.ncbi.nlm.nih.gov/gene  
Once only, download and save as follows:  
search Gene using the term (Homo sapiens) AND "Homo sapiens"[porgn:__txid9606]  
download using Send to/File/Create File  
save as flat text file called humanGenes.tsv  

   
```{r look for gene names among words in criteria}

## %in% returns a logical vector indicating if there is a match or not for its left operand
## i.e. it will indicate which gene aliases occur in any of the criteria
# subset humanGenes, retain only those rows with a match between aliases and criteria
humanGeneMatches <- humanGenes[humanGenes$Aliases %in% eligibilities$words, ]

## drop any duplicated rows
humanGeneMatches <- unique(humanGeneMatches)

## drop any rows where Aliases value is a single character (e.g. PPIB, aka B)
humanGeneMatches <- humanGeneMatches[nchar(humanGeneMatches$Aliases)>1, ]

## drop any rows where the matching Alias is "not" (which is a synonym of ALG3 )
humanGeneMatches <- humanGeneMatches[humanGeneMatches$Aliases != "not", ]

## now we have a list of aliases (and their Entrez symbol) that occur within the specified range of the specified mutantPattern in inclusion criteria for open UK cancer studies

## make a little table that will hold matches, will ultimately be joined to eligibilities on nct_id
matchesTable <- data.frame(nct_id = character(0), 
                           matching.substring = character(0),
                           matching.alias = character(0), 
                           matching.symbol = character(0))

tic("loop through the list of aliases and match against criteria by grep")

## loop through the list of aliases and match against criteria by grep
for(i in 1:nrow(humanGeneMatches)) {
  alias <- humanGeneMatches$Aliases[i]
  symbol <- humanGeneMatches$Symbol[i]
  ## get indices
  indices <- grep(pattern = alias, x = eligibilities$substring, ignore.case = FALSE)
  ## get NCT IDs
  nct_ids <- eligibilities$nct_id[indices]
  ## get matching substrings
  matching.substring <- eligibilities$substring[indices]
  matchesTable <- matchesTable %>% add_row(nct_id=nct_ids, matching.substring = matching.substring, matching.alias=alias, matching.symbol=symbol)
  
  ## now look for additional matches like "BRCA2" against "BRCA1/2"
  more.indices <- grep(pattern = alias, x = gsub(pattern = "./", replacement = "",x=eligibilities$substring), ignore.case = FALSE)
  if(length(more.indices)>0) {
    ## get NCT IDs
  more.nct_ids <- eligibilities$nct_id[more.indices]
  ## get matching substrings
  more.matching.substring <- eligibilities$substring[more.indices]
  matchesTable <- matchesTable %>% add_row(nct_id=more.nct_ids, matching.substring = more.matching.substring, matching.alias=alias, matching.symbol=symbol)
  }
}

toc()

matchesTable <- unique(matchesTable)
```


```{r join matching genes table to table of eligibilities}
## join matchesTable to eligibilities
eligibilities <- merge(x=eligibilities, y=matchesTable, by.x = c("nct_id", "substring"), by.y=c("nct_id", "matching.substring"))

## select columns of interest
eligibilities <- dplyr::select(eligibilities, nct_id, criteria, matching.alias, matching.symbol)

## remove duplicated rows
eligibilities <- unique(eligibilities)


## for reference, store todays's date, mutantPattern and wordRange
eligibilities$refresh.date <- today
eligibilities$mutantPattern <- mutantPattern
eligibilities$wordRange <- wordRange

```

```{r join eligibilities table to cancerStudies}
## inner join to NLPcriteria table
manualNLPmatches <- merge(x=cancerStudies, y=eligibilities, by.x="nct_id", by.y="nct_id")

## remove any redundant rows
manualNLPmatches <- unique(manualNLPmatches)

## remove any rows where matching.alias is only 1 character (e.g. 1 is an alias of ST3GAL1)
manualNLPmatches <- manualNLPmatches[nchar(as.character(manualNLPmatches$matching.alias)) >1,  ]

```

```{r write manual NLP matches to file}
#dim(manualNLPmatches)

## for efficiency, just select unique features (get the rest from a join to cancerStudies)
manualNLPmatches <- unique(dplyr::select(manualNLPmatches, nct_id, criteria, matching.alias, matching.symbol, mutantPattern, wordRange))

#dim(manualNLPmatches)



write.table(manualNLPmatches, file = "manualNLPmatches.tsv", sep = "\t",
            row.names = FALSE, col.names = names(manualNLPmatches))
```
  
Inclusion criteria for specified cancer studies have been indexed on gene name (Entrez symbol) and written to file (manualNLPmatches.tsv). First few lines are as follows:  
  
```{r preview manualNLPmatches table}

## preview table
kable(head(manualNLPmatches)) %>%
  kable_styling(bootstrap_options = "striped") %>%
  kable_styling(fixed_thead = T)


```

  
### **Tag trial interventions with their mechanism**  

#### **Create NCIthesaurus table**  
  
#### **Join to cancerStudies table**  

```{r join thesaurus to cancerStudies table}
## create a copy of cancerStudies table
interventionMatches <- cancerStudies

## add a lower case copy of interventions column to perform join to NCI thesaurus
interventionMatches$interventionsLower <- tolower(interventionMatches$interventions)

## inner join to NCIthesaurus data frame on NCIthesaurus$SynonymsLower
interventionMatches <- merge(x=interventionMatches,y=NCIthesaurus,by.x="interventionsLower",by.y="SynonymsLower", all.x=TRUE)

## drop any rows where mechanism is NA
interventionMatches <- interventionMatches[!is.na(interventionMatches$ParentTerm), ]

```

There are a total of **`r length(levels(as.factor(interventionMatches$ParentTerm)))`** different mechanisms represented across selected cancer studies.  

```{r write interventionMatches to file}
#dim(interventionMatches)

## for efficiency, just select unique features (get the rest from a join to cancerStudies)
interventionMatches <- unique(dplyr::select(interventionMatches, nct_id, interventions, Description, ParentTerm ))

#dim(interventionMatches)


## write to file
write.table(interventionMatches, file = "interventionMatches.tsv", sep = "\t",
            row.names = FALSE, col.names = names(interventionMatches))

```
  
Table of interventions, descriptions and mechanisms has been written to file (interventionMatches.tsv). First few lines are as follows:  
  
  
```{r preview interventionMatches table}  


kable(head(interventionMatches)) %>%
  kable_styling(bootstrap_options = "striped") %>%
  kable_styling(fixed_thead = T)

```

  
  
  
### **Get molecular targets of trial interventions from KEGG**  
  
```{r get details of target genes for trial interventions from KEGG}
## create a copy of cancerStudies table
targetMatches <- cancerStudies

## add a lower case copy of interventions column to perform join to NCI thesaurus
targetMatches$interventionsLower <- tolower(targetMatches$interventions)

## inner join to NCIthesaurus data frame on NCIthesaurus$SynonymsLower
targetMatches <- merge(x=targetMatches,y=NCIthesaurus,by.x="interventionsLower",by.y="SynonymsLower", all.x=TRUE)

## select and reorder required columns
targetMatches <- dplyr::select(targetMatches, brief_title,  nct_id, Link = "Link",  TARGET.condition, condition, Interventions = "interventions", PreferredTerm, Mechanism = "ParentTerm", Locations = locations,  investigators, Contacts = contacts, Refresh.date)

targets <- data.frame(PreferredTerm = unique(targetMatches$PreferredTerm), 
                      drugID = NA, 
                      drugTargetSymbol = NA)
## drop any rows where PreferredTerm is empty
targets <- targets[-which(targets$PreferredTerm == ""),]
targets <- targets[-which(is.na(targets$PreferredTerm)),]

tic("get IDs for drugs")

## get IDs for drugs
for(i in 1:nrow(targets)) {
  drugid <- NA  
  preferred <- as.character(targets$PreferredTerm[i])
  ## get (onlY) first drug ID
  tryCatch({drugid <- names(keggFind(database = "drug", query = preferred))[1]}, 
             error=function(cond) {return(NA)})
  if(length(drugid)>0 ) targets$drugID[i] <- drugid
}

## drop rows without a drugID
targets <- targets[!is.na(targets$drugID),]

toc()

tic("use drug IDs to get names (Entrez Symbols) for target genes")

## use drug IDs to get names (Entrez Symbols) for target genes
for(i in 1:nrow(targets)) {
  #print(i)
    ##target variable will hold IDs of target gene(s) listed for each drug
    target <- NA
    # names variable will hold names of target gene(s)
    names <- character(0)
    id <- targets$drugID[i]
    #print(id)    
  
    tryCatch({target <- keggGet(id)[[1]]$TARGET$TARGET}, 
             error=function(cond) {return(NA)})
    #print(target)
    ## parse the TARGET value to get the target id(s)
    if(length(target)>0 && !is.na(target)) {
      #trim everything up to "HSA:"
      target <- gsub(pattern = ".*\\HSA:", replacement = "", x=target)
      # trim everything after square bracket
      target <- gsub(pattern = "\\].*", replacement = "", x=target)
      # split into individual ids, where applicable
      target <- unlist(strsplit(x=target, split=" "))
      # paste on a "hsa:"
      target <- paste0("hsa:",target)
      #print(target)
      # make an empty vector that will hold names
      #names <- character(0)
      # make calls to keggGet
      for(j in 1:length(target)) {
        name <- keggGet(target[j])[[1]]$NAME[1]
        #print(name)
        #trim everything after first comma
        name <- gsub(pattern = ",.*", replacement = "", x=name)
        names <- c(names,name)
        }
    target <- paste(names, collapse = ",")
    #print(target)
    targets$drugTargetSymbol[i] <- target
      
    }

}

## drop rows where symbol is empty
targets <- targets[targets$drugTargetSymbol != "",]

## split drugTargetSymbol values on comma into new rows
targets <- as.data.frame(cSplit(targets, "drugTargetSymbol", ",", direction = "long"))
toc()

```

```{r join targets to targetMatches table}
## note this is an inner join - any interventions not mapped to a target gene in KEGG will be lost in this join
targetMatches <- merge(x=targetMatches, by.x = "PreferredTerm", y=targets, by.y = "PreferredTerm")

## select and reorder columns again
targetMatches <- dplyr::select(targetMatches,nct_id,brief_title,Link,TARGET.condition,condition,Interventions,Target = "drugTargetSymbol", Mechanism,Locations,investigators,Contacts,Refresh.date)

## trim off asterisks from Target values
targetMatches$Target <- gsub(pattern = "\\*", replacement = "", x=targetMatches$Target)

```
  
**`r length(unique(targetMatches$Interventions))`** interventions in open UK cancer studies have been mapped to a molecular target based on KEGG.  

```{r write targetMatches table to file}
#dim(targetMatches)
## for efficiency, just select unique features (get the rest from a join to cancerStudies)
targetMatches <- unique(dplyr::select(targetMatches, nct_id, Interventions, Target, Mechanism ))
#dim(targetMatches)

## write table to tab-separated file
write.table(targetMatches, file = "targetMatches.tsv", sep = "\t",
            row.names = FALSE, col.names = names(targetMatches))
```
  
Mappings between cancer trials, interventions and their molecular targets have been written to file targetMatches.tsv. First few rows are as follows:  
  
```{r preview targetMatches table}

kable(head(targetMatches)) %>%
  kable_styling(bootstrap_options = "striped") %>%
  kable_styling(fixed_thead = T)

```




### **Score matches between genes and cancer trials**  
  
For a given gene of interest...  
Score 5 if that gene is mentioned in inclusion criteria, and it is the molecular target of the study drug.  
Score 4 if that gene is mentioned in inclusion criteria, and the study drug targets a downstream gene.  
Score 3 if that gene is mentioned in inclusion criteria.  
Score 2 if the study drug targets that gene.  
Score 1 if the study drug targets a downstream gene.  
  

```{r create scoredMatches table}
## create an empty table that will hold details of matches
## a bit like a SQL view
scoredMatches <- data.frame(gene.of.interest = character(0), 
                                nct_id=character(0), 
                                intervention.name = character(0),
                                intervention.target=character(0),
                                rationale=character(0), 
                                confidence=numeric(0))

## create a table of target matches that will ultimately be added as new rows
temp.target.matches <- unique(dplyr::select(targetMatches, gene.of.interest="Target", nct_id, intervention.name="Interventions",intervention.target="Target"))
## drop rows where Target is NA
temp.target.matches <- temp.target.matches[!is.na(temp.target.matches$intervention.target),]
## add a rationale column
temp.target.matches$rationale <- paste0("Study drug (", temp.target.matches$intervention.name, ") targets ", temp.target.matches$intervention.target)
## add confidence score of +2 for target matches
temp.target.matches$confidence <- 2

## bind as new rows onto scoredMatches table
scoredMatches <- rbind(scoredMatches, temp.target.matches)

## do the same for pathwayMatches
## rename columns to match scoredMatches table
temp.pathway.matches <- unique(dplyr::select(pathwayMatches, gene.of.interest="network.element.gene.names", nct_id, intervention.name="Interventions", intervention.target="downstream.genes"))
## aggregate the downstream targets
temp.pathway.matches <- temp.pathway.matches %>%
            group_by_at(vars(-intervention.target)) %>%
            summarize(intervention.target = toString(intervention.target) ) %>%
            as.data.frame()
## drop rows with any NA
temp.pathway.matches <- temp.pathway.matches[complete.cases(temp.pathway.matches),]
## add a rationale column
temp.pathway.matches$rationale <- paste0("Study drug (", temp.pathway.matches$intervention.name, ") targets downstream gene(s) (", temp.pathway.matches$intervention.target, ")")
## add confidence score of +1 for pathway matches
temp.pathway.matches$confidence <- 1
## bind as new rows onto big.gene.matches table
scoredMatches <- rbind(scoredMatches, temp.pathway.matches)

scoredMatches <- merge(x=scoredMatches, by.x=c("nct_id", "gene.of.interest"), all.x = TRUE, y=unique(dplyr::select(manualNLPmatches,nct_id, matching.symbol, criteria )), by.y = c("nct_id", "matching.symbol"), all.y=TRUE)

## append rationale for studies matched on eligibility criteria
for(i in 1:nrow(scoredMatches)) {
   if(!is.na(scoredMatches$criteria[i])) {
     ## add +3 to confidence score
     if(!is.na(scoredMatches$confidence[i])) {
       scoredMatches$confidence[i] <- scoredMatches$confidence[i]+3
     } else scoredMatches$confidence[i] <- 3
     ## indicate that gene of interest is mentioned in criteria
     if(!is.na(scoredMatches$rationale[i])) {
       scoredMatches$rationale[i] <- paste(scoredMatches$rationale[i], paste0(scoredMatches$gene.of.interest[i],  " is mentioned in inclusion criteria"), sep = ", ")} else {scoredMatches$rationale[i] <- paste0(scoredMatches$gene.of.interest[i],  " is mentioned in inclusion criteria")}
   }
}


## write full table of all pathway matches to tsv
write.table(scoredMatches, file = "scoredMatches.tsv", sep = "\t",
            row.names = FALSE, col.names = names(scoredMatches))
```
  
Scored matches between a gene and study have been written to file scoredMatches.tsv. First few rows are as follows:  
  
  
```{r write scoredMatches to tsv}
#dim(scoredMatches)

kable(head(scoredMatches)) %>%
  kable_styling(bootstrap_options = "striped") %>%
  kable_styling(fixed_thead = T)

```

### **Exit script**  

```{r exit markdown}
knitr::knit_exit()
```


  
