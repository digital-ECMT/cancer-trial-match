---
title: "Data refresh for Cancer Trial Match"
author: "digital ECMT"
date: ""
output: html_document

---

```{r copyright notice}
 # 
 # This file is part of the cancer-trial-match distribution (https://github.com/digital-ECMT/cancer-trial-match).
 # Copyright (C) 2021 digital ECMT
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3 or later.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #


```



```{r setup, include=FALSE, warning=FALSE, message=FALSE, results=F} 
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
##NOTE: the following packages are required to run this script, but should be installed (e.g. using code snippets below) before runnning the script, NOT as part of the script itself
# options(repos = "http://cran.us.r-project.org")
# install.packages("BiocManager")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("KEGGREST")
# BiocManager::install("KEGGlincs")
# BiocManager::install("hgu133a.db")
require(KEGGlincs)        ## GPL-3
require(KEGGgraph)        ## GPL >= 2
require(org.Hs.eg.db)     ## Artistic-2.0
require(KEGGREST)         ## Artistic 2.0
require(DBI)              ## LGPL-2.1 | LGPL-3 
require(RODBC)            ## GPL-2 | GPL-3
require(RPostgres)        ## GPL-3
require(RSQLite)          ## LGPL-2.1 | LGPL-3
require(jsonlite)         ## MIT
require(dplyr)            ## MIT
require(tidyr)            ## MIT
require(formattable)      ## MIT
require(kableExtra)       ## MIT
require(stringr)          ## MIT
require(splitstackshape)  ## GPL-3
require(reshape2)         ## MIT
require(tictoc)           ## Apache License (== 2.0
require(leaflet)          ## GPL-3
require(PostcodesioR)     ## GPL-3
require(igraph)           ## GPL-2 | GPL-3
require(tidygeocoder)     ## MIT

## clean up first
rm(list=ls())

##get today's date
today <- format(Sys.Date(), format = "%d %B %Y")



```

**Date of data refresh: `r today`**  
  
  
```{r create empty SQLite DB} 
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

dbListTables(con)

```
  
#### **Define controlled terms and synonyms for cancer types**  
  
  
```{r create table of cancer types}
## conditionSynonyms specifies which cancer types are of interest, and which condition names (as used by clinicaltrials.gov) will be considered as matches for each

## synonyms define on basis of those in clinicaltrials.gov
#conditionSynonyms <- read.csv(file = "conditionSynonyms4.csv", stringsAsFactors = FALSE)
## updated set of more granular cancer types
conditionSynonyms <- read.csv(file = "conditionSynonyms5.csv", stringsAsFactors = FALSE)




## trim leading/trailing whitespace
conditionSynonyms$condition.synonyms <- str_squish(string = conditionSynonyms$condition.synonyms)

## remove redundancy, if any
conditionSynonyms <- unique(conditionSynonyms)

## display conditions and synonyms used
# formattable(as.data.frame(conditionSynonyms %>% 
#                   group_by(controlled.cancer.type) %>%
#                   summarise(
#                   synonyms = paste(condition.synonyms, collapse = ", "))))

## preview
formattable(head(conditionSynonyms))

## create as a table in database
dbWriteTable(conn = con,name = "cancers", value = conditionSynonyms, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
#### **List human gene names and their synonyms**  
    
  
```{r download and process a list of all human genes and their synonyms}

## start timer
tic("download a list of all human genes and their synonyms")


humanGenes <- read.table(file = "humanGenes.tsv", header = TRUE, quote = "", sep = "\t", fill = TRUE, stringsAsFactors = FALSE)

humanGenes <- dplyr::select(humanGenes, Symbol, Aliases)## drop everything except Symbol and Aliases columns


humanGenes$Aliases <- strsplit(x=humanGenes$Aliases, split = ",")## split the aliases on comma 
humanGenes <- unnest(data = humanGenes, cols = Aliases, keep_empty = TRUE) ## unnest to multiply rows, keep any rows with no aliases
humanGenes <- as.data.frame(humanGenes) ## convert to data frame

humanGenes$Aliases <- str_squish(string = humanGenes$Aliases) ## trim excess whitespace from Aliases values

## Symbol values are not represented among Aliases
# create a data frame with unique Symbol values
symbols <- data.frame("Symbol"=unique(humanGenes$Symbol), "Aliases"=unique(humanGenes$Symbol))
# bind this onto bottom of humanGenes data frame
humanGenes <- rbind(humanGenes,symbols)
# remove duplicated values, if any
humanGenes <- unique(humanGenes)
# sort on Symbol values
humanGenes <- humanGenes[order(humanGenes$Symbol), ] 

# drop any rows where Aliases is NA
humanGenes <- humanGenes[!is.na(humanGenes$Aliases), ]

## drop any rows where Aliases value is only a single character

## NOW humanGenes TABLE CONTAINS ALL HUMAN GENES AND THEIR SYNONYMS
## (61,593 unique symbols, 130,989 rows)

## stop timer
toc()
```
  
```{r create table of human genes}
## preview
formattable(head(humanGenes))

## create as a table in database
dbWriteTable(conn = con,name = "genes", value = humanGenes, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
#### **Download variant info from clinVar and civicDB**  
    
  
```{r download and process variants from clinvar}
## download variant summaries from clinvar
download.file(url="https://ftp.ncbi.nlm.nih.gov/pub/clinvar/tab_delimited/variant_summary.txt.gz",destfile = "variant_summary.txt.gz")
clinvar <- read.table(gzfile("variant_summary.txt.gz"), sep="\t", quote="", fill = TRUE, stringsAsFactors = FALSE) 
# V1 contains values for Allele ID
# V2 gives nature (e.g. fusion, single nucleotide variant etc)
# V7 contains values for clinical significance (inc whether pathogenic or not)
# V25 gives a measure of confidence in assertion
clinvar <- unique(dplyr::select(clinvar, "allele.id" = "V1", "nature"="V2", "significance"="V7", "confidence"="V25"))

## variation_allele contains mappings from clinvar variation ID (clinvar ID) and allele ID
download.file(url="https://ftp.ncbi.nlm.nih.gov/pub/clinvar/tab_delimited/variation_allele.txt.gz",destfile = "variation_allele.txt.gz")
variationAllele <- read.table(gzfile("variation_allele.txt.gz"), sep="\t", quote="", fill = TRUE, stringsAsFactors = FALSE) 
# V1 contains values for clinvar ID
# V3 contains values for Allele ID
variationAllele <- unique(dplyr::select(variationAllele, "clinvar.id"="V1", "allele.id"="V3"))

## join tables
clinvar <- merge(x=clinvar, by.x="allele.id", y=variationAllele, by.y="allele.id")


# variants contains mappings from variant_id to clinvar_ids
variants <- read.csv(file = "https://civicdb.org/downloads/nightly/nightly-VariantSummaries.tsv", sep = "\t", quote = "", stringsAsFactors = FALSE)
# variants$gene contains gene name (Entrez symbol)
# variants$variant contains amino acid change
# variants$summary contains a useful summary of evidence for each variant
# variants$clinvar_ids contains (comma-separated) clinvar IDs that can be mapped to the clinvar table to get info whether pathogenic or not... 


## drop unwanted columns
variants <- unique(dplyr::select(variants, variant_id, gene, variant, summary, variant_groups,civic_variant_evidence_score,clinvar_ids ))

## split and unnest the clinvar_ids column
variants$clinvar_ids <- strsplit(as.character(variants$clinvar_ids), split = ",")
variants <- unnest(data = variants, clinvar_ids)


## join significance from clinvar
variants <- unique(merge(x=variants, by.x="clinvar_ids", all.x=TRUE, y=clinvar, by.y="clinvar.id"))



## drop unwanted columns 
variants <- unique(dplyr::select(variants,variant_id, clinvar_ids,gene,variant,summary,variant_groups, significance,confidence))

## split on the word "and"
variants$variant <- strsplit(x=variants$variant, split = " and ") 
variants <- unnest(data = variants, cols = variant, keep_empty = TRUE) ## unnest to multiply rows, keep any rows with no aliases
variants <- as.data.frame(variants) ## convert to datack a frame


## trim everything after first space in variants$variant
variants$variant <- gsub(pattern = " .*", replacement = "", x=variants$variant)

```

 
```{r create table of variants}
## preview
formattable(head(variants))

## create as a table in database
dbWriteTable(conn = con,name = "variants", value = variants, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
    
#### **Download variant:drug evidence from clinVar**  
    
    
```{r download and process evidence from civic DB}
## download evidence from civicDB
# evidence contains mappings from variant_id to gene (gene name) and variant (amino acid change) to drugs etc
evidence <- read.csv(file = "https://civicdb.org/downloads/nightly/nightly-ClinicalEvidenceSummaries.tsv", sep = "\t", quote="", stringsAsFactors = FALSE)
# evidence contains more detailed data re: drugs, sensitivity etc
# evidence$evidence_level contains details of nature of evidence: 
# A = validated
# B = clinical
# C = case study
# D = preclinical


## drop unwanted columns
evidence <- unique(dplyr::select(evidence, variant_id, disease, drugs,  evidence_type, evidence_direction,evidence_level,clinical_significance,evidence_statement))

evidence <- as.data.frame(evidence)

## unnest the drugs column
evidence$drugs <- strsplit(x=evidence$drugs, split=",")
evidence <- unnest(data = evidence, cols = drugs, keep_empty = TRUE) 
evidence <- as.data.frame(evidence) ## convert to data frame
```

 
```{r create table of evidence}
## preview
formattable(head(evidence))

## create as a table in database
dbWriteTable(conn = con,name = "evidence", value = evidence, overwrite=TRUE)

## check it has saved
dbListTables(con)


## print a list of disease in evidence table, but not represented among condition synonyms
# setdiff(x=unique(evidence$disease), y=unique(conditionSynonyms$condition.synonyms))
```

**The following disease are listed in the evidence table, but are not represented among the cancer types and synonyms defined above:**  
  
  
`r setdiff(x=unique(evidence$disease), y=unique(conditionSynonyms$condition.synonyms))`  
  
#### **Download cancer study data from clinicaltrials.gov**  
     
  
```{r connect to clinicaltrialsgov}  
## specify user name and password for AACT account
## see https://aact.ctti-clinicaltrials.org/ for how to create an account

## load configuration data from JSON file
## configuration <- rjson::fromJSON(file = "trialMatchConfiguration.json")

## jsonlite is MIT
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password

# drv <- dbDriver("PostgreSQL")    ## need RPostgreSQL library to do this
# conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )



## connect via odbc 
## need PostgreSQL driver installation
# conn2 <- DBI::dbConnect(odbc::odbc(),
#                       Driver   = "PostgreSQL",
#                       Server   = "aact-db.ctti-clinicaltrials.org",
#                       Database = "aact",
#                       UID      = aact.username,
#                       PWD      = aact.password,
#                       Port     = 5432)

## connect via RPostgres (GPL-3 licence)
drv = RPostgres::Postgres()
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
```
 
 
```{r get study data}

## get country name specified in configuration file
country <- configuration$country
## get interventional studies for country specified in configuration file
## any indication
## with sites in specified country that have a status of "Recruiting" or "Not yet recruiting"

# form query
openStudiesQ <- paste0("SELECT s.nct_id, s.brief_title, s.overall_status, c.name AS condition, i.name AS interventions, f.name AS site_name,
f.city AS locations, f.zip AS postcode, f.status AS site_status,
fi.name as investigators,
fc.email AS contacts,
cc.email AS central_contacts 
FROM studies s
INNER JOIN facilities f ON f.nct_id = s.nct_id
INNER JOIN conditions c ON c.nct_id = s.nct_id
INNER JOIN interventions i ON i.nct_id = s.nct_id
LEFT JOIN central_contacts cc ON cc.nct_id = s.nct_id
LEFT JOIN facility_contacts fc ON f.id = fc.facility_id
LEFT JOIN facility_investigators fi ON f.id=fi.facility_id
WHERE f.country LIKE ('",
country,
"')
  AND s.study_type LIKE ('Interventional')
  AND s.overall_status IN ('Recruiting')
  AND f.status IN ('Recruiting')")

## OPTIONAL, could include sites with status of 'Not yet recruiting' and add a checkbox for users to choose whether to show/hide these sites

## get data from clinicaltrials.gov
openStudies <- dbGetQuery(conn2,openStudiesQ)

## add a column to indicate refresh date
openStudies$Refresh.date <- today

```
 

```{r loop through synonyms and look for matches against condition name}
## add a column to hold matching condition
openStudies$matching.condition <- NA
openStudies$TARGET.condition <- NA

## create an empty version to which matching rows will be added after looping through condition synonyms
cancerStudies <- openStudies[0, ]

# loop through condition synonyms
for(i in 1:nrow(conditionSynonyms)) {
  synonym <- as.character(conditionSynonyms$condition.synonyms[i])
  targetCondition <- as.character(conditionSynonyms$controlled.cancer.type[i])
  ## look for a match in condition name
  matching.rows <- grep(pattern = synonym, x=openStudies$condition, ignore.case = TRUE)
  ## create a temporary data frame to hold matches
  temp <- openStudies[matching.rows, ]
  if(nrow(temp)>0) {
    temp$matching.condition <- synonym
  temp$TARGET.condition <- targetCondition
  cancerStudies <- rbind(cancerStudies, temp)
  }
}

## overwrite openStudies with openStudies2
#openStudies <- openStudies2
## delete copy of openStudies to save memory
rm(openStudies)

## remove redundant rows, if any
cancerStudies <- unique(cancerStudies)

## add a column to hold link
cancerStudies$Link <- paste0("https://clinicaltrials.gov/ct2/show/", cancerStudies$nct_id)

## get eligibility criteria (before connection times out)
studyIDs <- unique(cancerStudies$nct_id)

## form SQL query
studyIDsForSQL <- paste0("\'",paste(studyIDs, collapse = "\',\'"), "\'")
getEligibilities <- paste0("select e.nct_id, e.criteria 
from eligibilities e
where e.nct_id in (",
"", studyIDsForSQL,
")")

## get criteria from clinicaltrials.gov
eligibilities <- dbGetQuery(conn2,getEligibilities)
```

```{r get latitude and longitude values for sites}



```



```{r get latitude and longitude values for sites based on postcode, warning=FALSE, message=FALSE}
## get lat and long for UK cities
## use postcodes where available
locations <- unique(dplyr::select(cancerStudies, postcode))
locations$postcode.lat <- NA
locations$postcode.long <- NA

for(i in 1:nrow(locations)) {
  postcode <- locations$postcode[i]
  tryCatch({
            lat = postcode_lookup(postcode)$latitude
            locations$postcode.lat[i] <- lat
            long = postcode_lookup(postcode)$longitude
            locations$postcode.long[i] <- long
            }, error=function(cond) {return(NA)})
}

## join to cancerStudies table
cancerStudies <- merge(x=cancerStudies, by.x="postcode", all.x=TRUE, y =locations, by.y ="postcode")

```

```{r get lat long values from city name using tidygeocoder}
## should be able to get lat and long values for about 85% of sites (90% of studies) based on city name alone

## try and fill values based on city name
# remove any commas and anything after a comma
cancerStudies$locations <- gsub(pattern = ",.*", replacement = "", x=cancerStudies$locations)

## use tidygeocoder (MIT licence)
## need append country from config file after city name...
cities <- as.data.frame(tidygeocoder::geo(address = unique(paste0(cancerStudies$locations, ", ", configuration$country)), method = 'osm'))
  
## trim off the suffix
cities$address <- gsub(pattern=paste0(", ", configuration$country), replacement = "", x=cities$address)

## join back on study location == address
cancerStudies <- merge(x=cancerStudies, by.x="locations", all.x=TRUE, y=dplyr::select(cities, address, lat, long), by.y="address")




```




```{r overwrite lat long based on postcode data where available}
## if postcode.lat is not NA, use that value to overwrite lat value
cancerStudies$lat[!is.na(cancerStudies$postcode.lat)] <- cancerStudies$postcode.lat[!is.na(cancerStudies$postcode.lat)]

## likewise for longitude
cancerStudies$long[!is.na(cancerStudies$postcode.long)] <- cancerStudies$postcode.long[!is.na(cancerStudies$postcode.long)]


```


 
#### **Get drug:mechanism and drug:target data**  
      
##### **Get mechanisms from NCI thesaurus**  
     

```{r download and create NCIthesaurus table}

tic("download, parse and write NCI thesaurus to file")

## specify URL for NCI thesaurus - this should always be the most recent? 
NCItURL <- "https://evs.nci.nih.gov/ftp1/NCI_Thesaurus/Thesaurus.FLAT.zip"

destFlatFilename <- "NCIt_FLAT.zip"
download.file(url=NCItURL,destfile = destFlatFilename)
unzip(zipfile = paste0(getwd(),"/",destFlatFilename))

NCIt <- read.table("Thesaurus.txt",header = FALSE, sep = "\t", comment.char = "", fill = TRUE, stringsAsFactors = FALSE, quote = "")
names(NCIt) <- c("ID","URL","ParentID","Synonyms","Description","PreferredTerm","Type","Class")

## a drug may have more than one class, so need to multiply rows
## split and unnest the Class column of NCIt
NCIt$Class <- strsplit(NCIt$Class, split = "\\|")
NCIt <- unnest(data = NCIt, Class)

## subset to retain only relevant classes
NCItPharmacologics <- NCIt[which(NCIt$Class %in% c("Pharmacologic Substance","Amino Acid, Peptide, or Protein","Immunologic Factor","Clinical Drug","Therapeutic or Preventive Procedure", "Health Care Activity")), ]

## additional classes related to prior therapy
#  "Therapeutic or Preventive Procedure", "Health Care Activity"


## one drug can have more than one parent, so need to split into multiple rows...
## split ParentID column on pipe symbol
NCItPharmacologics$ParentID <- strsplit(NCItPharmacologics$ParentID, split = "\\|")
## unnest the ID column to multiply rows
NCItPharmacologics <- unnest(data=NCItPharmacologics,ParentID)

## join parent synonyms
## first, get the synonyms and IDs for parents
NCItParents <- NCIt[which(NCIt$ID %in% NCItPharmacologics$ParentID), which(names(NCIt) %in% c("ID", "Synonyms"))]

## each parent term may have more than one synonym
## for simplicity, we will retain only the first synonym for each parent term
NCItParents$Synonyms <- gsub("\\|.*","",NCItParents$Synonyms)

## merge parents on entity ID = parent ID
NCItPharmacologics <- merge(x=NCItPharmacologics,y=NCItParents,by.x="ParentID",by.y="ID",all.x=TRUE)
## reorder and rename
NCItPharmacologics <- dplyr::select(NCItPharmacologics,ID,Class,PreferredTerm,Synonyms="Synonyms.x",Description,ParentTerm="Synonyms.y",ParentID)

## split the Synonyms column on pipe symbol
NCItPharmacologics$Synonyms <- strsplit(NCItPharmacologics$Synonyms, split="\\|")
## unnest the Synonyms column to multiply rows
NCItPharmacologics <- unnest(data = NCItPharmacologics,Synonyms)

## add a column with lower case drug synonyms for joining
NCItPharmacologics$SynonymsLower <- tolower(NCItPharmacologics$Synonyms)

## convert from tibble to data frame
NCIthesaurus <- as.data.frame(NCItPharmacologics)

## add a column to indicate date downloaded
NCIthesaurus$downloaded <- Sys.Date()

## drop redundant rows, if any
NCIthesaurus <- unique(NCIthesaurus)

toc()

## create as a table in database
dbWriteTable(conn = con,name = "NCIt", value = NCIthesaurus, overwrite=TRUE)


```
  
##### **Get targets from KEGG**  
     

```{r get molecular targets for cancerStudies interventions}
## first, get all interventions (note that there will be some redundancy due to case)
drugs.targets <- unique(dplyr::select(cancerStudies,interventions))
## keep interventions column as verbatim so can join later
## make a duplicate column
drugs.targets$interventions.processed <- drugs.targets$interventions


## split and unnest on " + "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\+ ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " plus "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " plus ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " and "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " and ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " & "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\& ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " or "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " or ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " (+) "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(\\+\\) ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " with "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " with ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

## also split on brackets
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# remove closing bracket
drugs.targets$interventions.processed <- gsub(pattern = "\\)", replacement = "", x=drugs.targets$interventions.processed)


## trim off anything related to dose
# pattern is (a number, with or without a decimal point) with/without a space, followed by "mg", anything after "mg is removed
drugs.targets$interventions.processed <- gsub(pattern = " \\d+\\.?\\d+ ?mg.*", replacement = "", x=drugs.targets$interventions.processed, ignore.case = T)


## join to NCIthesaurus so that any intervention not represented in the thesaurus is dropped
drugs.targets <- merge(x=drugs.targets, 
      by.x = "interventions.processed", 
      y= unique(dplyr::select(NCIthesaurus, Synonyms, Description, ParentTerm)), 
      by.y = "Synonyms")

## try to map each processed intervention to a Drug IDs from KEGG
## add an empty column to hold drug ID
drugs.targets$drugID <- NA
tic("get IDs for drugs")
for(i in 1:nrow(drugs.targets)) {
  drugid <- NA
  drugSynonym <- as.character(drugs.targets$interventions.processed[i])
  #print(drugSynonym)
  ## get (onlY) first drug ID
  tryCatch({drugid <- names(keggFind(database = "drug", query = drugSynonym))[1]},
             error=function(cond) {return(NA)})
  if(length(drugid)>0 ) {
    #print(drugid)
    drugs.targets$drugID[i] <- drugid}
}
toc()

## separate off drug IDs
targets <- as.data.frame(unique(dplyr::select(drugs.targets, drugID)))
## add a column to hold drug target ID
targets$drugTargetID <- NA
## add a column to hold Entrez symbol for drug target
targets$drugTargetSymbol <- NA
## drop rows without a drugID
targets <- targets[!is.na(targets$drugID),]

## use drug IDs to get gene IDs for target genes
for(i in 1:nrow(targets)) {
  drugid <- targets$drugID[i]
  geneid <- NA
  tryCatch({geneid <- keggGet(drugid)[[1]]$TARGET$TARGET},
             error=function(cond) {return(NA)})
  #print(geneid)
  if(length(geneid)>0) targets$drugTargetID[i] <- geneid
}

## parse the drugTargetID values - trim off extra characters and unnest where multiple targets per drug
## drop any columns that don't contain "HSA:"

#trim everything up to "HSA:"
targets$drugTargetID <- gsub(pattern = ".*\\HSA:", replacement = "", x=targets$drugTargetID)
# trim everything after square bracket
targets$drugTargetID  <- gsub(pattern = "\\].*", replacement = "", x=targets$drugTargetID )
# split on space into individual ids, where applicable
targets$drugTargetID <- strsplit(targets$drugTargetID, split = " ")
targets <- unnest(data = targets, drugTargetID)
targets <- as.data.frame(targets)
## drop rows where drugTargetID is NA
targets <- targets[!is.na(targets$drugTargetID), ]

# paste on a "hsa:"
targets$drugTargetID <- paste0("hsa:",targets$drugTargetID)

## use drugTargetId to get names (Entrez Symbols) for target genes
for(i in 1:nrow(targets)) {
  targetId <- targets$drugTargetID[i]
  #print(paste0("i= ", i, "; ID = ", targetId))
  name <- NA
  tryCatch({
    # name <- keggGet(targetId)[[1]]$NAME[1]
    # API has changed, NAME returns name instead of symbol... 
    name <- keggGet(targetId)[[1]]$SYMBOL[1]
    ## name is not normalised, multiple symbols separated by comma, we want the first one...
    name <- strsplit(name, split = ", ")[[1]][1]
    
    
    
    },error=function(cond) {return(NA)})
  if(length(targetId)>0) {
    #name <- keggGet(targetId)[[1]]$NAME[1]
    #print(name)
    targets$drugTargetSymbol[i] <- name
  }
}

## drugTargetSymbol may hold several comma separated values
## first value appears to be Entrez symbol
## trim off everything after first comma
targets$drugTargetSymbol <- gsub(pattern = ",.*", replacement = "", x=targets$drugTargetSymbol )

## join drugTargetSymbol values to drugs.targets table
drugs.targets <- merge(x=drugs.targets, by.x="drugID", all.x=TRUE,
                       y=unique(dplyr::select(targets, drugID, drugTargetSymbol)), by.y = "drugID")

## reorder columns
drugs.targets <- unique(dplyr::select(drugs.targets,"interventions.verbatim"= "interventions", interventions.processed, Description, ParentTerm, drugTargetSymbol))
```

##### **Write drugsTargets table to database**  
     

 
```{r create table of drugs and targets}
## preview
formattable(head(drugs.targets))

## create as a table in database
dbWriteTable(conn = con,name = "drugsTargets", value = drugs.targets, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
#### **Append mechanisms to cancerStudies table**  


```{r join mechanisms to cancerStudies}
## join on interventions.verbatim == interventions
cancerStudies <- merge(x=cancerStudies, by.x="interventions", all.x=TRUE, 
                       y=unique(dplyr::select(drugs.targets, interventions.verbatim, ParentTerm)), by.y="interventions.verbatim")



```

  
 
```{r create table of studies}
## preview
formattable(head(cancerStudies))

## create as a table in database
dbWriteTable(conn = con,name = "cancerStudies", value = cancerStudies, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
   
#### **Index eligibility criteria for cancer studies**  
      
  
```{r get eligibility criteria for cancer studies}
# studyIDs <- unique(cancerStudies$nct_id)
# 
# ## form SQL query
# studyIDsForSQL <- paste0("\'",paste(studyIDs, collapse = "\',\'"), "\'")
# getEligibilities <- paste0("select e.nct_id, e.criteria 
# from eligibilities e
# where e.nct_id in (",
# "", studyIDsForSQL,
# ")")
# 
# ## get criteria from clinicaltrials.gov
# eligibilities <- dbGetQuery(conn2,getEligibilities)

```

```{r retain individual eligibility criteria containing mutant pattern}


## add a column to indicate criterion type
eligibilities$criterion.type <- NA



## split into individual criteria
for(i in 1:length(eligibilities$criteria)) {
  criteria <- as.character(eligibilities$criteria[i])
  # criteria <- unlist(strsplit(criteria, split = "\n\n"))## split on double line breaks ( DEPRECATED)
  # criteria <- unlist(strsplit(criteria, split = "\r\n\r\n"))## split on double newline/carriage return
  criteria <- unlist(strsplit(criteria, split = "\n"))## split on single line breaks ( DEPRECATED)
  criteria <- criteria[criteria != ""] ## drop empty elements
  criteria <- trimws(x=criteria, which = "both")## trim whitespace from start and end
  criteria <- gsub(pattern = "\n", replacement = "", x= criteria)## remove single line breaks from each criterion
  criteria <- str_squish(string = criteria) ## squish repeated spaces within each criterion
  #criteria <- as.list(criteria)
  eligibilities$criteria[i] <- list(criteria)
}


## unnest
eligibilities <- as.data.frame(unnest(data = eligibilities, cols = criteria))
eligibilities$criterion.type[1] <- "INCLUSION"
```


```{r classify eligibility criteria}
## classify as either inclusion or exclusion
## tag start of inclusion criteria
eligibilities$criterion.type[grep(pattern = "inclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "INCLUSION"

## tag start of exclusion criteria
eligibilities$criterion.type[grep(pattern = "exclusion criteria:?$", x=eligibilities$criteria, ignore.case = TRUE)] <- "EXCLUSION"

## fill "down" using the tdiyr::fill() function
eligibilities <- tidyr::fill(data=eligibilities, criterion.type, .direction="down")


## add a column to indicate feature referenced by text 
eligibilities$feature <- NA
## add a column that will hold matching term (e.g. gene names)
eligibilities$match <- NA
```
  
```{r define indexing function}
indexOnPattern <- function(eligibilities, pattern, wordRange, featureLabel) {
  table <- eligibilities
  pattern <- pattern
  wordRange <- wordRange
  featureLabel <- featureLabel
  ## get indices containing specified pattern
  indices <- grep(pattern = pattern, x=table$criteria, ignore.case = T) 
  # subset table 
  table <- table[indices, ]
  # label nature of change
  table$feature <- featureLabel
  
  ## loop through each criterion that contains pattern
  for(i in 1:nrow(table)) {
    criterion <- table$criteria[i]
    # also create an alternative criterion for patterns such as "BRCA1/2"
    alternative.criterion <- gsub(pattern = "./", replacement = "", x=criterion)
    # concatenate
    criterion <- paste(criterion,alternative.criterion, sep = " " )
    # split into tokens
    criterion <- unlist(strsplit(x=criterion, split = " |\\(|\\)|,|-|/"))
    ## criterion is now a vector of tokens (words, but also some empty elements)
    ## remove any empty elements in criterion 
    criterion <- criterion[criterion!=""]
    
    ## get indices of match(es) against pattern (need to squish preceding space)
    indices <- grep(pattern = str_squish(pattern), x = criterion, ignore.case = TRUE)
    ## specify start and end point(s) based on specified word range
    starts <- indices - wordRange
    ends <- indices + wordRange
    range <- numeric(0)
    for(j in 1:length(starts)) { ## because there may be more than one match
      if(starts[j] <1) {starts[j] <- 1}
      range <- append(range,starts[j]:ends[j])
    } ## now range contains the indices of the words either side of the pattern, within specified word range
    range <- unique(range) ## if the ranges overlap, just get the unique elements
    ## range is the indices of words within the criterion that are within the specified wordRange from pattern (i.e. the ones we want to keep)
    ## subset the criterion retain only words within specified range
    criterion <- criterion[range]
    ## omit any NA values (i.e. where match is less than wordRange from end of sentence)
    criterion <- criterion[!is.na(criterion)]
    ## now subset and retain only words that are a valid gene alias
    criterion <- unique(criterion[criterion %in% humanGenes$Aliases])
    ## drop any aliases that are a single or 2 characters
    criterion <- criterion[nchar(criterion)>2]
    ## drop any matches against the word "not"
    criterion <- criterion[criterion != "not"]
    if(length(criterion)>0) table$match[i] <- list(criterion)
  }
  ## drop rows not indexed against a gene
  table <- table[!is.na(table$match), ]
  ## unnest
  table <- as.data.frame(unnest(table, cols = "match"))
  
  
  ## join to Entrez symbols from humanGenes
  table <- merge(x=table, by.x="match", y=humanGenes, by.y = "Aliases")
  
  ## rename Symbol to "controlled.match"
  # using rename gives unreliable results (?!)
  # see https://stackoverflow.com/questions/26371279/dplyr-0-3-0-2-rename-idiom-unstable-when-reshape-package-is-loaded
  #table <- rename(table, "controlled.match"="Symbol")
  table$controlled.match <- table$Symbol
  table <- dplyr::select(table, -Symbol)
  ## drop redundant rows
  table <- unique(table)
  ## return table
  return(table)
}




```

  
  
  
##### **Index on mutations**  
     
  
```{r index criteria on mutations}

## call indexing function
## exclude matches containing "positive" as these tend to be IHC, not mutation
## also exclude "loss" as this is included in rearrangementPattern

mutation.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "mutat|mutant|defect|deficien|alter|loss of function|loss-of-function", wordRange = 6, featureLabel = "mutation")

## preview
formattable(head(mutation.eligibilities))
```
  
##### **Index on fusions (not currently used)**  
     
  
```{r index criteria on fusions}

## NOT USED BECAUSE SUPERCEDED BY INDEX ON REARRANGEMENTS
fusion.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement", wordRange = 7, featureLabel = "fusion")

## preview
formattable(head(fusion.eligibilities))
```
  
##### **Index on rearrangements**  
     
  
```{r index criteria on rearrangements}

rearrangement.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " fusion|rearrangement|truncation|truncated|deletion|deleted|lost|duplication|duplicated", wordRange = 6, featureLabel = "rearrangement")

## preview
formattable(head(rearrangement.eligibilities))
```
    
##### **Index on copy number loss**  
     
  
```{r index criteria on copy number loss}
## NOTE USE WORD RANGE OF 2 FOR LOSS, OTHERWISE GET TOO MANY FALSE HITS (including "loss of function" etc, which is indexed as a mutation)
loss.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = "loss", wordRange = 2, featureLabel = "loss")

## preview
formattable(head(loss.eligibilities))

```
    

    
  
##### **Index on amplifications**  
     
  
```{r index criteria on amplifications}

amplification.eligibilities <- indexOnPattern(eligibilities = eligibilities, pattern = " amplification|overexpression", wordRange = 5, featureLabel = "amplification")

## preview
formattable(head(amplification.eligibilities))

```
  

##### **Index on performance status**  
  
<<not developed yet>>    

  
##### **Store criteria related to prior therapies**  
     
  
```{r index criteria on prior therapies}
## create a copy of eligibilities
therapy.eligibilities <- eligibilities

## filter to retain criteria with mention of "previous|prior"
# define pattern
therapyFilter <- "previous therapy|prior therapy|previous treatment|prior treatment"
# filter
therapy.eligibilities <- therapy.eligibilities[grep(pattern = therapyFilter, ignore.case = TRUE, x=therapy.eligibilities$criteria), ]
# set value for feature
therapy.eligibilities$feature <- "PRIOR_THERAPY"

## drop redundant rows, if any
therapy.eligibilities <- unique(therapy.eligibilities)

## since prior therapies tend to be a mixture of 2-word synonyms, 3-word synonyms etc, plus parent terms, best approach for now is to not try and match against a therapy

# add a controlled.match column for row binding only
therapy.eligibilities$controlled.match <- NA

## instead, in the UI, just show inclusion and exclusion criteria (separately) related to prior therapies

formattable(head(therapy.eligibilities))
```
      

##### **Write indexedEligibility table to database**  
  
  
```{r row bind indexed eligbility tables}
# indexed.eligibilities <- unique(rbind(mutation.eligibilities, fusion.eligibilities,  amplification.eligibilities, therapy.eligibilities))


indexed.eligibilities <- unique(rbind(mutation.eligibilities, rearrangement.eligibilities, loss.eligibilities, amplification.eligibilities, therapy.eligibilities))



```

```{r create table of indexed eligibility criteria}
## preview
#formattable(head(indexed.eligibilities))

## create as a table in database
dbWriteTable(conn = con,name = "indexedEligibility", value = indexed.eligibilities, overwrite=TRUE)

## check it has saved
dbListTables(con)

```

#### **Get pathway graph data from KEGG**  
  
  
```{r get edge list}


## download KGML file for Pathways In Cancer as KGML file
pathwaysInCancer_KGML <- get_KGML("hsa05200")
#class(pathwaysInCancer_KGML)

## expand mappings
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML, convert_KEGG_IDs = FALSE)
pathwaysInCancer_mappings <- expand_KEGG_mappings(pathwaysInCancer_KGML)
pathwaysInCancer_edges <- expand_KEGG_edges(pathwaysInCancer_KGML, pathwaysInCancer_mappings)

## create a simple edgelist
edgelist <- unique(dplyr::select(pathwaysInCancer_edges, "from"="entry1symbol", "to"="entry2symbol", specific_subtype, value))



#Modify existing data sets; specify as nodes and edges
pathwaysInCancer_node_mapping_info <- node_mapping_info(pathwaysInCancer_mappings)

pathwaysInCancer_edge_mapping_info <- edge_mapping_info(pathwaysInCancer_edges)

#Create an igraph object
pathwaysInCancer.igraph <- get_graph_object(pathwaysInCancer_node_mapping_info, pathwaysInCancer_edge_mapping_info)

## get edgelist
edges <- as_data_frame(pathwaysInCancer.igraph, what = c("edges"))

## retain only edges where "from" is a gene
edges <- unique(dplyr::filter(edges, entry1type=="gene"))

## drop unnecessary columns
# keep edge IDs fur use in graph analysis 
edges <- unique(dplyr::select(edges, "from"="entry1symbol", "to"="entry2symbol",edgeID, specific_subtype, tooltip))


## unnest the from and to columns
edges$from <- strsplit(edges$from, split = ",")
edges <- unnest(edges, cols = "from")

edges$to <- strsplit(edges$to, split = ",")
edges <- unnest(edges, cols = "to")

## convert back to dataframe
edges <- as.data.frame(edges)


```

  

```{r create table of edges}
## preview
formattable(head(edges))

## create as a table in database
dbWriteTable(conn = con,name = "edges", value = edges, overwrite=TRUE)

## check it has saved
dbListTables(con)

```
  
  
#### **Score matches against trials**  
  
```{r score matches on gene intervention target}

## start with studies and their interventions
targetMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
## join to drugs.targets on intervention name (verbatim)
targetMatches <- merge(x=targetMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
## drop rows where drugTargetSymbol is NA
targetMatches <- targetMatches[!is.na(targetMatches$drugTargetSymbol), ]

## drop unnecessary columns
targetMatches <- unique(dplyr::select(targetMatches, nct_id, interventions.processed, drugTargetSymbol))

## add rationale column
targetMatches$intervention_rationale <- paste0("Study drug (", targetMatches$interventions.processed, ") targets ", targetMatches$drugTargetSymbol)

## drop intervention column
targetMatches <- unique(dplyr::select(targetMatches, -interventions.processed))

## rename drugTargetSymbol column
#targetMatches <- rename(targetMatches,"symbol"= "drugTargetSymbol")
targetMatches$symbol <- targetMatches$drugTargetSymbol
targetMatches <- dplyr::select(targetMatches, -drugTargetSymbol)

## add a score
targetMatches$intervention_score <- 2

```

```{r score matches on pathway}
## start with studies and their interventions
pathwayMatches <- unique(dplyr::select(cancerStudies, nct_id, interventions))
## join to drugs.targets on intervention name (verbatim)
pathwayMatches <- merge(x=pathwayMatches, by.x="interventions", y=drugs.targets, by.y="interventions.verbatim" )
## drop rows where drugTargetSymbol is NA
pathwayMatches <- pathwayMatches[!is.na(pathwayMatches$drugTargetSymbol), ]
## drop unnecessary columns
pathwayMatches <- unique(dplyr::select(pathwayMatches, nct_id, interventions.processed, drugTargetSymbol))

## join to edges, where drugTargetSymbol == to
## i.e. intervention targets the downstream node
pathwayMatches <- merge(x=pathwayMatches, by.x="drugTargetSymbol", y=edges, by.y="to")

## select and rename columns
pathwayMatches <- unique(dplyr::select(pathwayMatches,nct_id, interventions.processed, "downstream"="drugTargetSymbol","upstream"="from" ))

## where an intervention targets >1 gene, aggregate
pathwayMatches <- as.data.frame(pathwayMatches %>%
                group_by(nct_id, interventions.processed, upstream) %>%
                summarise(
                  downstream = paste(unique(downstream), collapse = ", ")
                ))

## add rationale column
pathwayMatches$intervention_rationale <- paste0("Study drug (", pathwayMatches$interventions.processed, ") targets downstream gene(s) (", pathwayMatches$downstream, ")")

## drop intervention column
pathwayMatches <- unique(dplyr::select(pathwayMatches, -c(interventions.processed, downstream)))

## rename upstream column to drugTargetSymbol to match targetMatches
#pathwayMatches <- rename(pathwayMatches, "symbol"="upstream")
pathwayMatches$symbol <- pathwayMatches$upstream
pathwayMatches <- dplyr::select(pathwayMatches, -upstream)


## add a score
pathwayMatches$intervention_score <- 1

```

```{r row bind target and pathway matches}

scoredMatches <- rbind(targetMatches, pathwayMatches)

## for genes that don't have a match in eligilityMatches, we want to be able to match on gene alone, regardless of variant_type... 
scoredMatches$variant_type <- list(c("mutation", "rearrangement", "loss", "amplification"))

## unnest to multiply rows
scoredMatches <- data.frame(unnest(scoredMatches, cols = "variant_type"))

```




```{r score matches on inclusion criteria}
## start with indexed eligibilities
eligibilityMatches <- unique(dplyr::select(indexed.eligibilities, nct_id,"gene"="controlled.match",criterion.type, feature, criteria ))

## filter out matches against exclusion criteria
eligibilityMatches <- filter(eligibilityMatches, criterion.type=="INCLUSION")

## filter out matches against prior therapy
eligibilityMatches <- filter(eligibilityMatches, feature!="PRIOR_THERAPY")

## concatenate gene and feature
# eligibilityMatches$gene <- paste(eligibilityMatches$gene, eligibilityMatches$feature, sep = " ")

## add rationale column
eligibilityMatches$eligibility_rationale <- paste0("Enrolling subjects with ", eligibilityMatches$gene, " ", eligibilityMatches$feature)



## add a score
eligibilityMatches$eligibility_score <- 3

## where multiple criteria, aggregate
eligibilityMatches <- as.data.frame(eligibilityMatches %>%
                group_by(nct_id, gene, criterion.type, feature, eligibility_rationale, eligibility_score) %>%
                summarise(
                  criteria = paste(unique(criteria), collapse = "\n\n")
                ))


## select and rename columns to match targetMatches and pathwayMatches
eligibilityMatches <- unique(dplyr::select(eligibilityMatches, nct_id, "symbol"="gene", "variant_type" = "feature", eligibility_rationale, "matching_criteria"="criteria", eligibility_score))


```

```{r join eligibility matches to scored matches}
scoredMatches <- merge(x=scoredMatches, by.x=c("nct_id", "symbol", "variant_type"), all.x=TRUE, 
      y=eligibilityMatches, by.y = c("nct_id", "symbol", "variant_type"), all.y=TRUE)

## add a combined score
scoredMatches$combined_score <- rowSums(scoredMatches[,c("intervention_score", "eligibility_score")], na.rm=TRUE)

## conatenate symbol and variant_type columns to get <gene name> <variant_type>, e.g. "EGFR mutation"
scoredMatches$gene_variant_type <- paste(scoredMatches$symbol, scoredMatches$variant_type, sep=" ")

## select and reorder columns
scoredMatches <- unique(dplyr::select(scoredMatches, symbol, variant_type,gene_variant_type, nct_id, intervention_rationale, eligibility_rationale, matching_criteria, combined_score))

## order on combined_score descending
scoredMatches <- scoredMatches[order(scoredMatches$combined_score, decreasing = TRUE), ]


```


```{r create table of scored matches}
## preview
formattable(head(scoredMatches,10))

## create as a table in database
dbWriteTable(conn = con,name = "scoredMatches", value = scoredMatches, overwrite=TRUE)

## check it has saved
dbListTables(con)

```


```{r score matches on variant sensitivity}
## start with evidence data
variantMatches <- unique(dplyr::select(evidence, variant_id, drugs, evidence_type, evidence_direction, clinical_significance))

## join variant info
variantMatches <- merge(x=variantMatches, by.x="variant_id", y=dplyr::select(variants, variant_id, gene, variant), by.y="variant_id")

## drop rows where drugs == NA
variantMatches <- variantMatches[!is.na(variantMatches$drugs), ]

## drop rows where evidence_direction does not support
variantMatches <- variantMatches[variantMatches$evidence_direction=="Supports", ]

## drop unnecessary columns
variantMatches <- unique(dplyr::select(variantMatches, gene, variant, clinical_significance, drugs))

## apply underscore consistently for mutations, amplifications, fusions
variantMatches$variant[grep(pattern = "mutation", x=variantMatches$variant, ignore.case = T)] <- "mutation"
variantMatches$variant[grep(pattern = "amplification", x=variantMatches$variant, ignore.case = T)] <- "amplification"
variantMatches$variant[grep(pattern = "fusion", x=variantMatches$variant, ignore.case = T)] <- "fusion"





## if more than one interpretation for a gene-variant-drug combination, aggregate
variantMatches <- as.data.frame(variantMatches %>%
                  group_by(gene,variant, drugs) %>%
                  summarise(
                      clinical_significance = paste(unique(clinical_significance), collapse = ", ")
                  ))
# drop those rows that have >1 interpretation (based on presence of comma)
variantMatches <- variantMatches[-grep(pattern = ",", x=variantMatches$clinical_significance), ]

## join to intervention names as per clinicaltrials.gov
variantMatches <- merge(x=variantMatches, by.x="drugs", y=unique(dplyr::select(drugs.targets, interventions.verbatim, interventions.processed)), by.y="interventions.processed")

## add rationale column
variantMatches$rationale <- paste0(variantMatches$gene, " ", variantMatches$variant, " predicts ", variantMatches$clinical_significance, " to study intervention (", variantMatches$drugs, ")")

## add score column
variantMatches$score <- ifelse(variantMatches$clinical_significance=="Sensitivity/Response", yes=3, no=-3)


## join to cancerStudies
variantMatches <- merge(x=variantMatches, 
      by.x="interventions.verbatim", 
      y=unique(dplyr::select(cancerStudies, nct_id, interventions)), 
      by.y="interventions")

## create gene_variant values
variantMatches$gene_variant <- paste(variantMatches$gene, variantMatches$variant, sep = " ")

## select and rename columns to match targetMatches etc
variantMatches <- unique(dplyr::select(variantMatches, nct_id, "symbol"="gene_variant", rationale, score))
```

```{r row bind scored matches}
# scoredMatches <- rbind(eligibilityMatches, targetMatches, pathwayMatches)
# 
# ## aggregate where mutliple lines of rationale per gene-study
# scoredMatches <- as.data.frame(scoredMatches %>%
#                 group_by(nct_id, symbol) %>%
#                 summarise(
#                   rationale = paste(unique(rationale), collapse = ", "), 
#                   score = sum(score)
#                 ))

```



```{r disconnect from  database}

# disconnect from clincialtrials.gov
dbDisconnect(conn2)

# Disconnect from SQLite database
dbDisconnect(con)


```
  
`r knitr::knit_exit()`    
  

