---
title: "Treatment decision support options"
output: html_document
---


```{r copyright notice, include=FALSE}
 # 
 # This file is part of the cancer-trial-match distribution (https://github.com/digital-ECMT/cancer-trial-match).
 # Copyright (C) 2021 digital ECMT
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3 or later.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.width=48, fig.height=48)
require(flexdashboard)      ## MIT
require(dplyr)              ## MIT
require(tidyr)              ## MIT
require(kableExtra)         ## MIT
require(shinyWidgets)       ## GPL-3
require(leaflet)            ## GPL-3
require(htmltools)          ## GPL-2 | GPL-3
require(jsonlite)           ## MIT
require(RSQLite)            ## LGPL-2.1 | LGPL-3
require(DT)                 ## GPL-3
require(DBI)                ## LGPL-2.1 | LGPL-3
require(ggplot2)
require(stringr)
require(formattable)

## load configuration data from JSON file
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")
# configuration <- rjson::fromJSON(file = "trialMatchConfiguration.json")

rm(list=ls())
```
  
  
```{r define function to show kable}
showKable <- function(dataframe) {
  kbl(dataframe, format = "html",escape = FALSE) %>%
kable_styling(fixed_thead = T, bootstrap_options = c("striped", "hover", "condensed")) %>%
scroll_box(width = "125%", height = "600px")
}


```
  
<!-- add custom CSS to display plots with scroll bars when needed    -->
<style>
  .superbigimage{
      overflow-x:scroll;
      overflow-y:scroll;
      white-space: nowrap;
  }

  .superbigimage img{
     max-width: none;
     max-height: none;
  }


</style>  
    
## **Objectives**  
<br>

* Describe limitations of current version of trial finder  
* List potential ways to address limitations  
* Evaluate potential data sources  
  * Utility  
  * Limitations  
  * Presentation options  
<br>
<br>
 
## **Example scenario**  
  
* Soft tissue sarcoma  
* PTEN loss; ARID1A mutation, AR mutation, BCOR mutation  
<br>
<br>

`r knitr::include_graphics("sarcoma_mapview.PNG")`  
<br>
<br>
 
* **There are many trials recruiting sarcoma patients (inc solid tumour trials)**  
<br>

* **Which trial is the best option and why?**  
<br>

## **Current solution**  

<br>

* These trials are pushed to top of results  
* Why?  
  * Study recruiting patients with one or more of these genetic alterations *implies confidence in rationale for study intervention*  
  * One or more study drug targets one of the altered genes  

<br>
<br>
`r knitr::include_graphics("sarcoma_tableview.PNG")`  
<br>
<br>

* Currently, tool does not offer any support with:  
  * **Which of these options is best?**     
  * **What about BCOR?**  
  * **Would one of the other ~100 studies be a better match?**  
  * **Would a licensed treatment be a better option?**  
<br>
<br>

## **A: Empirical approaches**  

* *based on, concerned with, or verifiable by observation or experience rather than pure logic*  

  
### **A1. Clinicaltrials.gov results**  

```{r connect to SQLite DB}
# Create an RSQLite database
#con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

## connect to DB generated by indexTrialData.Rmd
con <- dbConnect(RSQLite::SQLite(), "indexedTrialData.sqlite")
```
   
```{r load study data}
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")

## squish any extra whitespace in controlled cancer type values
cancerStudies$controlled_cancer_type <- str_squish(cancerStudies$controlled_cancer_type)

## drop unnecessary columns
cancerStudies <- unique(dplyr::select(cancerStudies, nct_id, brief_title, controlled_cancer_type))

number_cancer_studies <- length(unique(cancerStudies$nct_id))
```

```{r specify cancer type of interest}
cancer_type <- "Sarcoma: Soft Tissue"
# cancer_type <- "Breast"

cancer_type_study_IDs <- unique(cancerStudies$nct_id[cancerStudies$controlled_cancer_type==cancer_type])  
```
  
```{r specify alterations of interest}
alterations <- c("PTEN_loss", "BCOR_mutation", "ARID1A_mutation", "AR_mutation")


# alterations <- c("BRCA2_mutation", "ERBB2_amplification")


## just get the gene names
gene_names <- gsub(pattern = "_.*", replacement = "", x=alterations)
```

* Considering all cancer studies globally, data are available for **`r length(unique(cancerStudies$nct_id))` studies**:  
  * **`r length(cancer_type_study_IDs)` studies included patients with `r cancer_type`**  

<!-- `r showKable(head(cancerStudies))`   -->

```{r get outcomes}
PFS <- dbGetQuery(con, "SELECT * FROM PFS")
## select columns
PFS <- unique(dplyr::select(PFS, nct_id, result_group_id, ctgov_group_code, title, outcome_controlled, param_type, param_value_num, units, dispersion_type, dispersion_lower_limit, dispersion_upper_limit))

overall_survival <- dbGetQuery(con, "SELECT * FROM overall_survival")
## select same columns as for PFS
overall_survival <- unique(dplyr::select(overall_survival, names(PFS)))

## rowbind into tall format
outcomes <- unique(rbind(PFS, overall_survival))
## sort on nct id
outcomes <- arrange(outcomes, nct_id)
## specify factor order for outcomes (so faceted plots render nicely)
outcomes$outcome_controlled <- factor(x=outcomes$outcome_controlled, levels = c("Progression free survival", "Overall survival"))


number_studies_with_survival_data <- length(intersect(outcomes$nct_id, cancerStudies$nct_id))
percent_studies_with_survival_data <- 100*number_studies_with_survival_data/number_cancer_studies


```

* **Only `r length(intersect(outcomes$nct_id, cancerStudies$nct_id))` (`r round(percent_studies_with_survival_data, digits = 0)`%) of these studies have PFS and/or OS data available**  
<br>

<!-- `r showKable(head(outcomes))`        -->

```{r join cancer types to outcomes}

cancerStudies_outcomes <- merge(x=cancerStudies, by.x = "nct_id", y=outcomes, by.y = "nct_id")


```
  
```{r plot distribution of cancer types with results}
# ggplot(data=cancerStudies_outcomes, aes(x=controlled_cancer_type, y=param_value_num, colour = outcome_controlled)) +
#   geom_point(alpha=0.5) +
#     coord_flip(ylim = c(0, 100)) +
#     labs(title = "Survival according to cancer type", x="result group", y="survival, months", colour = "outcome") +
#   facet_grid(.~outcome_controlled)


# ggplot(data=filter(cancerStudies_outcomes, controlled_cancer_type %in% c("Sarcoma: Soft Tissue", "Solid")), aes(x=controlled_cancer_type, y=param_value_num, colour = outcome_controlled)) +
#   geom_point(alpha=0.5) +
#     coord_flip(ylim = c(0, 100)) +
#     labs(title = "Survival according to cancer type", x="result group", y="survival, months", colour = "outcome") +
#   facet_grid(.~outcome_controlled)


```

  
#### **Outcomes in studies including `r cancer_type` patients**  


* **`r length(intersect(outcomes$nct_id, cancer_type_study_IDs))` studies with survival data included patients with `r cancer_type`**  
* **Note that these studies may have included other cancer types as well**  
<br>
<div class="superbigimage">
```{r plot_it , echo = FALSE, fig.width=24,fig.height=12}
ggplot(data=filter(cancerStudies_outcomes, controlled_cancer_type %in% c(cancer_type)), aes(x=brief_title, y=param_value_num, colour = outcome_controlled)) +
  geom_point(alpha=0.5) +
    coord_flip() +
    labs(title = paste0("Outcomes for ", cancer_type), x="result group", y="survival, months", colour = "outcome") 
```
</div>
<br>

#### **Outcomes in patients with relevant alterations (all cancer types)** <br>

```{r load mappings from result groups to design groups}

predictions <- dbGetQuery(con, "SELECT * FROM predictions")
predictions <- unique(dplyr::select(predictions, nct_id, "dg_id"="predicted_design_group", rg_id))
```

```{r load population_features}
population_features <- dbGetQuery(con, "SELECT * FROM population_features")

population_features <- dplyr::filter(population_features, id_type != "EXCLUSION")
population_features <- dplyr::filter(population_features, feature != "prior therapy")


population_features$controlled_match_feature <- paste(population_features$controlled_match, population_features$feature, sep = "_")

population_features <- unique(dplyr::select(population_features, nct_id, id_type, id, match, controlled_match, feature, controlled_match_feature))

```

* Considering the alterations `r paste(alterations, collapse = ", ")`, the number of relevant studies that have evaluated these alterations (all cancer types, with or without outcome data) is as follows:  
<br>
```{r summary table studies by feature}
# population_features %>%
#   filter(controlled_match_feature %in% alterations) %>%
#   group_by(controlled_match_feature) %>%
#   summarise(
#     count_of_studies = length(unique(nct_id))
#   ) %>%
#   as.data.frame() %>%
#   showKable()


population_features %>%
  filter(controlled_match_feature %in% alterations) %>%
  group_by(controlled_match_feature) %>%
  summarise(
    count_of_studies = length(unique(nct_id)), 
    count_studies_outcomes = length(unique(nct_id[nct_id %in% outcomes$nct_id]))
  ) %>%
  as.data.frame() %>%
  showKable()
```
<br>

```{r join features to result groups}
## where features are derived from inclusion criteria, assign those features to all result groups for that study
study_features <- unique(merge(x=predictions, by.x = "nct_id", y=dplyr::select(population_features, nct_id, match, controlled_match, feature), by.y = "nct_id"))

## where features are derived from design group description, assign those features to all result groups mapped to those design groups
dg_features <- unique(merge(x=predictions, by.x = "dg_id", y=dplyr::select(population_features, id, match, controlled_match, feature), by.y = "id"))

## finally, where features are derived from result group descriptions, assign those features only to those result groups
rg_features <- unique(merge(x=predictions, by.x = "rg_id", y=dplyr::select(population_features, id, match, controlled_match, feature), by.y = "id"))

## rowbind into a single table
## select only unique rows
features <- unique(rbind(study_features, dg_features, rg_features))

```

* Note that the results may include patients with other mutations in addition to / instead of those specified.  
<br>  
```{r join features to outcomes}
features_outcomes <- unique(merge(x=dplyr::select(features, nct_id, rg_id, controlled_match, feature), by.x=c("nct_id", "rg_id"), all.x=FALSE, y=outcomes, by.y = c("nct_id", "result_group_id"), all.y = FALSE))

features_outcomes$controlled_match_feature <- paste(features_outcomes$controlled_match, features_outcomes$feature, sep = "_")

## join brief titles
features_outcomes <- merge(x=unique(dplyr::select(cancerStudies, nct_id, brief_title)), by.x="nct_id", y=features_outcomes, by.y="nct_id")

features_outcomes <- arrange(features_outcomes, desc(param_value_num))

## get IDs for studies with those features and outcomes
study_IDs_features_outcomes <- unique(features_outcomes$nct_id[features_outcomes$controlled_match_feature %in% alterations])
# showKable(head(features_outcomes,20))
# 
features_outcomes %>%
  filter(nct_id %in% study_IDs_features_outcomes) %>%
  arrange(desc(param_value_num)) %>%
  dplyr::select(nct_id, "study title"="brief_title", "gene"="controlled_match", "alteration"="feature", "outcome"="title", param_type, param_value_num, units, dispersion_type, dispersion_lower_limit, dispersion_upper_limit) %>%
  showKable()
```

```{r exploratory plots features vs outcomes}
## exploratory plots
# ggplot(data=filter(features_outcomes, controlled_match == "PTEN" & feature == "loss"), aes(x=factor(rg_id), y=param_value_num, colour=outcome_controlled)) +
#     geom_point(alpha=0.5) +
#     geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
#     coord_flip(ylim = c(0, 100)) +
#     labs(title = "Outcomes in populations with PTEN loss", x="result group", y="survival, months", colour = "outcome")
# 
# ## select example studies
# ggplot(data=filter(features_outcomes, nct_id %in% c("NCT01802320", "NCT00894504", "NCT01575522") ), aes(x=controlled_match_feature, y=param_value_num, colour=outcome_controlled)) +
#     geom_point(alpha=0.5) +
#     geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.05, alpha=0.3) +
#     coord_flip(ylim = c(0, 50)) +
#     labs(title = "Outcomes in studies with PTEN loss", x="feature", y="survival, months", colour = "outcome")
```



### **A2. [CIVIC database](https://civicdb.org/home)**  

* *an open access, open source, community-driven web resource for Clinical Interpretation of Variants in Cancer.*  
* Considering only alterations in the specified genes (any cancer type), CIViC database includes the following evidence:  
<br>
```{r load evidence table}
evidence <- dbGetQuery(con, "SELECT * FROM evidence")

evidence %>%
  filter(gene %in% gene_names) %>%
  filter(evidence_type == "Predictive") %>%
  filter(evidence_direction == "Supports") %>%
  arrange(gene, drugs) %>%
  showKable()


```

  
### **A3. PubMed**  
  
<br>
  
## **B: Deductive approaches**  
  
* *derived from the application of logic to other known facts*  
<br>

  
### **B1. Reasoning over biological pathways**  

* e.g. [KEGG Pathways in Cancer](https://www.genome.jp/pathway/hsa05200)  
<br>
<br>

`r knitr::include_graphics("pathwaysInCancer.png")`  
<br>
<br>
        
* Full pathway is complex, and hard to interpret  
  * If we connect drugs to gene nodes, complexity further increased  
  * If we then connect studies to drug nodes, further still  
* Some kind of reasoning over pathway is required  
  * Show only the most relevant nodes, linkages  
* **How should an algorithm reason over a network?**  
<br>
1. **Drug directly reverses effect of genetic alteration**  
  * EGFR T790M -> activation of EGFR  
  * Osimertinib -> inhibition of EGFR  
2. **Drug counteracts downstream effect of genetic alteration**  
  * PTEN inhibits PIP3  
  * PI3K (PIK3CA/B/D) activates PIP3  
  * PTEN loss -> loss of PIP3 inhibition  
  * Alpelisib -> inhibition of PI3K -> reduce activity of PIP3  
3. **Synthetic lethality**  
  * BRCA1/2 -> DNA DSB repair  
  * BRCA1/2 loss of function -> loss of DNA DSB repair  
  * PARP -> DNA SSB repair  
  * Olaparib -> inhibition of PARP -> DNA DSB accumulation  
  * DNA DSB accumulation -> cell death  
4. **???** 
  * ARID1A mutation -> -> sensitivity to p300/CBP inhibition  
  * SETD2 mutation -> -> sensitivity to ATR inhibition  
<br>


  
```{r load a list of pathway ids}
pathways <- read.csv("keggPathways.csv", stringsAsFactors = FALSE, colClasses = "character")
## add prefix to pathway ids
pathways$pathwayId <- paste0("hsa0", pathways$pathwayId)
```

  
```{r get tables from database}


humanGenes <- dbGetQuery(con, "SELECT * FROM humanGenes")
NCIt <- dbGetQuery(con, "SELECT * FROM NCIt")
```

  
  
```{r get pathways as node and edge lists, message=FALSE}
## create empty dataframes that will hold nodes and edges
edgelist <- data.frame("from"=character(0), 
                       "to"=character(0), 
                       "label"=character(0), 
                       "title" = character(0), 
                       "pathway" = character(0))

nodelist <- data.frame("id"=character(0), 
                       "Symbol"=character(0))

for(i in 1:nrow(pathways)) {
  id <- pathways$pathwayId[i]
  name <- pathways$pathwayName[i]
  # print(id)
  # print(name)
  tryCatch({kgml <- KEGGlincs::get_KGML(id)},
             error=function(cond) {return(NA)})
  if(is.na(kgml)) next
  #print(name)
  
  mappings <- expand_KEGG_mappings(kgml, convert_KEGG_IDs = FALSE)
  edges <- expand_KEGG_edges(kgml, mappings)

  ## create edges based on individual members of nodes
  edges <- unique(dplyr::select(edges, "from"="entry1accession", "to"="entry2accession", "title"="subtype1"))
  ## add pathway name to edge list
  edges$pathway <- name
  ## bind to edgelist
  edgelist <- rbind(edgelist, edges)
  ## get nodes from mappings table
  nodes <- data.frame("id" = unique(dplyr::select(mappings, "id" = entryACCESSION )))
  # nodes <- unique(dplyr::select(mappings, "id" = "entryACCESSION"))
  ## unnest nodes
  nodes <- unique(as.data.frame(unnest(data=nodes, cols = c("id"))))
  
  ## join Entrez Symbols
  nodes <- unique(merge(x=nodes, by.x="id", all.x=TRUE, y=unique(dplyr::select(humanGenes, GeneID, Symbol)), by.y="GeneID"))
  ## drop any nodes without an id
  nodes <- nodes[!is.na(nodes$id), ]
  
  ## test it works
  #igraph::graph_from_data_frame(d=edges,vertices=nodes, directed=T)
  ## bind to nodelist
  nodelist <- rbind(nodelist, nodes)
}

nodelist <- unique(nodelist)
edgelist <- unique(edgelist)

nodelist$label <- nodelist$Symbol
```


  
  
`r knitr::knit_exit()`  

  
  
  
  

```{r get interventions}
interventions <- dbGetQuery(con, "SELECT * FROM interventions")
```

```{r get info to link interventions to design groups from ctgov}
## load configuration data from JSON file
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password

## connect to ct.gov
drv = RPostgres::Postgres()
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )

## get list of nct ids
study_ids <- unique(outcomes$nct_id)
## format for SQL query
studyIDsForSQL <- paste0("\'",paste(study_ids, collapse = "\',\'"), "\'")
## get design group interventions
get_dgi <- paste0("select *
from design_group_interventions
where nct_id in (",
"", studyIDsForSQL,
")")

## get data from clinicaltrials.gov
dgi <- dbGetQuery(conn2,get_dgi)

```

```{r join interventions to design groups}
## join to design groups
interventions <- unique(merge(x=dplyr::select(dgi, nct_id, design_group_id, intervention_id), by.x = c("nct_id", "intervention_id"), y= interventions, by.y = c("nct_id", "intervention_id")))

```

* There are a total of `r length(unique(interventions$intervention_name))` unique intervention names  
  * After mapping to preferred terms in NCI thesaurus, these represent `r length(unique(interventions$PreferredTerm))` distinct interventions across `r length(unique(interventions$Mechanism))` mechanisms  
  
    
`r formattable(head(interventions))`  
  

```{r aggregate interventions by result group}
interventions_agg <- interventions %>%
  group_by(nct_id, design_group_id ) %>%
  summarise(
    interventions = paste(sort(unique(intervention_name)), collapse = " + "), 
    preferred_terms = paste(sort(unique(PreferredTerm)), collapse = " + "), 
    mechanisms = paste(sort(unique(Mechanism)), collapse = " + "), 
    targets = paste(sort(unique(target_symbol)), collapse = " + ")
  ) %>%
  as.data.frame()

```
  
* Some study arms include >1 intervention:  
  
`r formattable(head(interventions_agg))`  
  


```{r join interventions to result groups}
outcomes_interventions <- unique(merge(x=interventions, by.x=c("nct_id", "design_group_id"), y=predictions, by.y = c("nct_id", "dg_id")))

outcomes_interventions <- unique(merge(x=outcomes_interventions, by.x = c("nct_id", "rg_id"), y=outcomes, by.y = c("nct_id", "result_group_id")))

```
  
`r formattable(head(outcomes_interventions))`  
  
  
```{r plot distribution of interventions with results}
ggplot(data=outcomes_interventions, aes(x=controlled_cancer_type, y=param_value_num, colour = outcome_controlled)) +
  geom_point(alpha=0.5) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival according to cancer type", x="result group", y="survival, months", colour = "outcome") +
  facet_grid(.~outcome_controlled)
```




```{r join interventions to cancer types}


outcomes_interventions <- unique(merge(x=outcomes_interventions, by.x = "nct_id", y=cancerStudies, by.y = "nct_id"))

ggplot(data=filter(outcomes_interventions, controlled_cancer_type %in% c("Sarcoma: Soft Tissue", "Solid")), aes(x=PreferredTerm, y=param_value_num, colour = outcome_controlled)) +
  geom_point(alpha=0.5) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival according to cancer type", x="result group", y="survival, months", colour = "outcome") +
  facet_grid(.~controlled_cancer_type)




```

  
```{r join interventions agg to results}
## join to outcomes
outcomes_interventions_agg <- unique(merge(x=interventions_agg, by.x=c("nct_id", "design_group_id"), y=predictions, by.y = c("nct_id", "dg_id")))

outcomes_interventions_agg <- unique(merge(x=outcomes_interventions_agg, by.x = c("nct_id", "rg_id"), y=outcomes, by.y = c("nct_id", "result_group_id")))

outcomes_interventions_agg <- unique(merge(x=outcomes_interventions_agg, by.x = "nct_id", y=cancerStudies, by.y = "nct_id"))

ggplot(data=filter(outcomes_interventions_agg, controlled_cancer_type %in% c("Sarcoma: Soft Tissue", "Solid")), aes(x=PreferredTerm, y=param_value_num, colour = outcome_controlled)) +
  geom_point(alpha=0.5) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival according to cancer type", x="result group", y="survival, months", colour = "outcome") +
  facet_grid(.~outcome_controlled)

```
  
  
`r formattable(head(outcomes_interventions_agg))`  
    
   

### **CIViC database**  
  
  
```{r load evidence}
evidence <- dbGetQuery(con, "SELECT * FROM evidence")

formattable(head(evidence))



# formattable(head(filter(evidence, disease == "Cancer")))
# "Solid Tumor"
# "Sarcoma"
# "Liposarcoma" 
# "Synovial Sarcoma"

formattable(filter(evidence, gene %in% c("PTEN", "ARID1A", "AR", "BCOR") & evidence_type == "Predictive"))
```
    


### **KEGG**  
  
  
```{r load edges}
edges <- dbGetQuery(con, "SELECT * FROM edges")

```
    


```{r disconnect from SQLite DB}
dbDisconnect(con)
```

`r knitr::knit_exit()`  










 









```{r exploratory outcome plots}
# ggplot(data=outcomes, aes(x=factor(result_group_id), y=param_value_num, colour=outcome_controlled)) +
#     geom_point(alpha=0.5) +
#     # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
#     coord_flip(ylim = c(0, 100)) +
#     labs(title = "Survival data, all studies", x="result group", y="survival, months", colour = "outcome") +
#     theme(axis.text.y = element_blank())

```




### **Outcomes, soft tissue sarcoma**  

* There are a total of `r length(unique(cancerStudies$nct_id[cancerStudies$controlled_cancer_type == "Sarcoma: Soft Tissue"]))` studies that have recruited patients with soft tissue sarcoma.    


```{r get IDs for studies recruiting on solid tumour}

solid_nct_ids <- unique(cancerStudies$nct_id[cancerStudies$controlled_cancer_type == "Solid"])

```

```{r get IDs for sarcoma studies}
## get IDs for all studies that include soft tissue sarcoma
sarcoma_nct_ids <- unique(cancerStudies$nct_id[cancerStudies$controlled_cancer_type == "Sarcoma: Soft Tissue"])

## include matches on solid tumour
# sarcoma_nct_ids <- unique(c(sarcoma_nct_ids, solid_nct_ids))

```
  
* If we include matches on solid tumour, this number increases to `r length(sarcoma_nct_ids)` studies.  
```{r filter and retain outcome data for sarcoma studies}
sarcoma_outcomes <- filter(outcomes, nct_id %in% sarcoma_nct_ids)

sarcoma_outcomes_interventions <- filter(outcomes_interventions, nct_id %in% sarcoma_nct_ids)

```
  
* `r length(unique(sarcoma_outcomes$nct_id))` of these sarcoma/solid tumour studies have survival data available.  
  
```{r outcome plots for sarcoma studies}

ggplot(data=sarcoma_outcomes, aes(x=factor(result_group_id), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, sarcoma studies (inc solid tumour)", x="result group", y="survival, months", colour = "outcome") +
    theme(axis.text.y = element_blank())

```  


```{r outcome plots for sarcoma cancer studies by intervention}

ggplot(data=sarcoma_outcomes_interventions, aes(x=reorder(PreferredTerm, -param_value_num), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Survival data, sarcoma studies (excluding solid tumour)", x="Intervention", y="survival, months", colour = "outcome") +
    facet_grid(.~outcome_controlled)


ggplot(data=sarcoma_outcomes_interventions, aes(x=reorder(Mechanism, -param_value_num), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Survival data, sarcoma studies (excluding solid tumour)", x="Intervention mechanism", y="survival, months", colour = "outcome")+
    facet_grid(.~outcome_controlled) 


ggplot(data=sarcoma_outcomes_interventions, aes(x=reorder(target_symbol, -param_value_num), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Survival data, sarcoma studies (excluding solid tumour)", x="Intervention target", y="survival, months", colour = "outcome")+
    facet_grid(.~outcome_controlled)

```
  
* Note that, in many cases, patients received >1 intervention...  
  

```{r outcome plots for sarcoma studies by intervention aggregated}
ggplot(data=filter(interventions_agg, nct_id %in% sarcoma_nct_ids), aes(x=factor(interventions), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Survival data, sarcoma studies (excluding solid tumour)", x="Interventions", y="survival, months", colour = "outcome") 

ggplot(data=filter(interventions_agg, nct_id %in% sarcoma_nct_ids), aes(x=mechanisms, y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Survival data, sarcoma studies (excluding solid tumour)", x="Interventions", y="survival, months", colour = "outcome") 

ggplot(data=filter(interventions_agg, nct_id %in% sarcoma_nct_ids), aes(x=targets, y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Survival data, sarcoma studies (excluding solid tumour)", x="Interventions", y="survival, months", colour = "outcome") +
    # theme_bw() +
    facet_grid(.~outcome_controlled)


ggplot(data=filter(interventions_agg, nct_id %in% sarcoma_nct_ids), aes(x=preferred_terms, y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Survival data, sarcoma studies (excluding solid tumour)", x="Intervention PTs", y="survival, months", colour = "outcome") +
    # theme_bw() +
    facet_grid(.~outcome_controlled)

```
  





```{r get AE totals}
AE_totals <- dbGetQuery(con, "SELECT * FROM AE_totals")
```  
  
```{r get AE counts}
AE_counts <- dbGetQuery(con, "SELECT * FROM AE_counts")

## join predicted design groups
AE_counts <- unique(merge(x=AE_counts, by.x = c("nct_id", "result_group_id"), y=predictions, by.y = c("nct_id","rg_id")))

## just get serious AE_counts
serious_AE_counts <- dplyr::filter(AE_counts, event_type == "serious")

## filter and retain only sarcoma studies with outcomes
serious_AE_counts <- filter(serious_AE_counts, nct_id %in% unique(sarcoma_outcomes$nct_id))

## filter and retain only most common SAE per result group
most_serious_AEs <- serious_AE_counts %>%
         group_by(nct_id, result_group_id, dg_id) %>%
         arrange(desc(percent_affected)) %>%
         summarise(
             most_common_SAE = head(adverse_event_term, 1), 
             percent_affected = head(percent_affected, 1)
         ) %>%
         as.data.frame()

```

```{r join most serious SAEs to interventions agg}
interventions_agg <- unique(merge(x=interventions_agg, by.x = c("nct_id", "design_group_id"), y=most_serious_AEs, by.y = c("nct_id", "dg_id")))

ggplot(data=filter(interventions_agg, nct_id %in% sarcoma_nct_ids), aes(x=preferred_terms, y=percent_affected, colour=most_common_SAE)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 60)) +
    labs(title = "Most common SAE, sarcoma studies (excluding solid tumour)", x="Intervention PTs", y="most common SAE, percent") +
    guides(colour = FALSE)

```

  
  
  
  
  
  
  
  
  
  
  
  

```{r disconnect from  databases}

# disconnect from clinicaltrials.gov
dbDisconnect(conn2)

# Disconnect from SQLite database
dbDisconnect(con)

```
    

`r knitr::knit_exit()`  






















  

  
```{r filter and retain outcome data for breast cancer studies}

## get IDs for all studies that include breast cancer
breast_cancer_nct_ids <- unique(cancerStudies$nct_id[cancerStudies$controlled_cancer_type == "Breast"])

breast_cancer_outcomes <- filter(outcomes, nct_id %in% breast_cancer_nct_ids)

# breast_cancer_outcomes_interventions <- filter(outcomes_interventions, nct_id %in% breast_cancer_nct_ids)


```


  
```{r outcome plots for breast cancer studies}

ggplot(data=filter(outcomes, nct_id %in% breast_cancer_nct_ids), aes(x=factor(result_group_id), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, breast cancer studies", x="result group", y="survival, months", colour = "outcome") +
    theme(axis.text.y = element_blank())

```

### **Outcomes, breast cancer studies grouped by intervention mechanism**  

```{r outcome plots for breast cancer studies by intervention}

ggplot(data=filter(outcomes_interventions, nct_id %in% breast_cancer_nct_ids), aes(x=factor(PreferredTerm), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, breast cancer studies", x="Intervention", y="survival, months", colour = "outcome") 

ggplot(data=filter(outcomes_interventions, nct_id %in% breast_cancer_nct_ids), aes(x=factor(Mechanism), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, breast cancer studies", x="Intervention mechanism", y="survival, months", colour = "outcome") 

ggplot(data=filter(outcomes_interventions, nct_id %in% breast_cancer_nct_ids), aes(x=factor(target_symbol), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, breast cancer studies", x="Intervention target", y="survival, months", colour = "outcome") 

```
  
* Note that, in many cases, patients received >1 intervention...  

```{r outcome plots for breast cancer studies by intervention aggregated}

ggplot(data=filter(interventions_agg, nct_id %in% breast_cancer_nct_ids), aes(x=factor(interventions), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, breast cancer studies", x="Interventions", y="survival, months", colour = "outcome") 

ggplot(data=filter(interventions_agg, nct_id %in% breast_cancer_nct_ids), aes(x=factor(mechanisms), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, breast cancer studies", x="Intervention mechanisms", y="survival, months", colour = "outcome") 

ggplot(data=filter(interventions_agg, nct_id %in% breast_cancer_nct_ids), aes(x=factor(targets), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, breast cancer studies", x="Intervention targets", y="survival, months", colour = "outcome") 
```
  
* Considering only breast cancer studies that included one or more HER2-directed therapies...  
  
```{r get study IDs for anti-HER2 breast cancer studies}  

her2_nct_ids <- unique(interventions$nct_id[interventions$target_symbol=="ERBB2"])

breast_cancer_nct_ids_her2 <- intersect(breast_cancer_nct_ids, her2_nct_ids)

```

* There are `r length(unique(breast_cancer_nct_ids_her2))` studies that included breast cancer patients and at least one HER2-directed intervention...   
  

```{r outcome plots for HER2 breast cancer studies by intervention aggregated}

ggplot(data=filter(interventions_agg, nct_id %in% breast_cancer_nct_ids_her2), aes(x=factor(interventions), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, HER2-directed breast cancer studies", x="Interventions", y="survival, months", colour = "outcome") 

ggplot(data=filter(interventions_agg, nct_id %in% breast_cancer_nct_ids_her2), aes(x=factor(mechanisms), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, HER2-directed breast cancer studies", x="Intervention mechanisms", y="survival, months", colour = "outcome") 

ggplot(data=filter(interventions_agg, nct_id %in% breast_cancer_nct_ids_her2), aes(x=factor(targets), y=param_value_num, colour=outcome_controlled)) +
    geom_point(alpha=0.5) +
    # geom_errorbar(aes(ymin=dispersion_lower_limit, ymax=dispersion_upper_limit), width=.2) +
    coord_flip(ylim = c(0, 100)) +
    labs(title = "Survival data, HER2-directed breast cancer studies", x="Intervention targets", y="survival, months", colour = "outcome") 
```
   









`r knitr::knit_exit()`  


```{r read cancer study data into memory}
## read cancerStudies table into memory
#cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")
cancerStudies <- dbGetQuery(con, "SELECT * FROM open_cancerStudies_view")

## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)

## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
#  [1] "interventions"      "locations"          "postcode"           "nct_id"            
#  [5] "brief_title"        "overall_status"     "condition"          "site_name"         
#  [9] "site_status"        "investigators"      "contacts"           "central_contacts"  
# [13] "Refresh.date"       "matching.condition" "TARGET.condition"   "Link"              
# [17] "postcode.lat"       "postcode.long"      "lat"                "long"              
# [21] "ParentTerm" 
# no columns are aggregated

## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")

## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))

## rename parentTerm column as "Mechanism"
cancerStudies <- dplyr::rename(cancerStudies, "Mechanism"="ParentTerm")

## read conditions and synonyms into memory
conditionSynonyms <- dbGetQuery(con, "SELECT * FROM conditionSynonyms")
```

```{r get a full set of all study locations}
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
```


```{r add flag for sites not yet recruiting}
cancerStudies$locations[cancerStudies$site_status=="Not yet recruiting"] <- paste0(cancerStudies$locations[cancerStudies$site_status=="Not yet recruiting"], " (in setup)")



```




```{r aggregate cancerStudies into compact form}
## aggregating interventions was causing some study:intervention combinations to be missed out
# cancerStudies <- cancerStudies %>%
#        group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts,central_contacts, lat, long, Refresh.date))) %>%
#        summarize(locations = toString(sort(unique(na.omit(locations)))),
#                  sites = toString(sort(unique(na.omit(site_name)))),
#                  conditions = toString(sort(unique(na.omit(condition)))),
#                  investigators = toString(sort(unique(na.omit(investigators)))),
#                  central_contacts = toString(sort(unique(na.omit(central_contacts)))),
#                  contacts = toString(sort(unique(na.omit(contacts))))) %>%
#        as.data.frame()
```

```{r get prior tx exclusions}
## read indexed eligibilities table into memory
# indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexed_eligibilities_view")


## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")

## filter for prior therapy
# excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")
excludedTX <- filter(excludedTX, feature=="prior therapy")

## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))

## aggregate into single row per study
excludedTX <- excludedTX %>%
       group_by(nct_id) %>%
       summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
       as.data.frame()

## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")

```

```{r read studies scored on match against genes of interest}
## read cancerStudies table into memory
# scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches_view")


## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest

## column names are
# [1] "symbol"                 "variant_type"           "nct_id"                
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [7] "combined_score"

```

# (data refreshed `r refresh.date`)  

Inputs {.sidebar}
-----------------------------------------------------------------------

**Filter studies on cancer type**    

```{r define a reactive value that will hold parameters from url}
## define a reactive value that will hold cancer type from URL, if any
urlValues <- reactiveValues()

```

```{r parse cancer type from URL}
observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['cancerType']])) {
        urlValues$CancerType <- query[['cancerType']]
      } 
})
```

```{r display cancer type dropdown}
available.cancer.types <- sort(unique(cancerStudies$TARGET.condition))

output$reactiveCancerFilter <- renderUI({
  ## multiple = TRUE allows user to start typing 
  selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = urlValues$CancerType, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
  
})
# display filter
shiny::renderUI({
   uiOutput("reactiveCancerFilter")
})

## can test when running locally by manually changing URL to e.g. http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast

```

```{r include matches on solid tumour}

checkboxInput(inputId="solidTumourFilter", label="Include matches on solid tumour?", value = TRUE, width = NULL)


```



```{r define a reactive value that will hold selected cancer type}

## if solid tumours selected, solid is added as an additional cancer type
selectedCancerTypes <- reactive({
  if(input$solidTumourFilter==FALSE) {cancer.types <- input$cancerTypeFilter}
  else {cancer.types <- c(input$cancerTypeFilter, "Solid")}
  
  ## print to console to aid development... 
  #print(paste0("selectedCancerTypes value: ", cancer.types))
  
  ## return value
  cancer.types
})

```

```{r define reactive cancerStudies table}
reactiveCancerStudies <- reactive({
   cancer.types <- selectedCancerTypes()

   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)
   
   ## if hiding studies in setup, filter table
   if(input$inSetupFilter==FALSE) {table <- filter(table, site_status == "Recruiting")}
   
   ## aggregate into compact form
   table <- table %>%
       group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts,central_contacts, lat, long, Refresh.date))) %>%
       summarize(locations = toString(sort(unique(na.omit(locations)))),
                 sites = toString(sort(unique(na.omit(site_name)))),
                 conditions = toString(sort(unique(na.omit(condition)))),
                 investigators = toString(sort(unique(na.omit(investigators)))),
                 central_contacts = toString(sort(unique(na.omit(central_contacts)))),
                 contacts = toString(sort(unique(na.omit(contacts))))) %>%
       as.data.frame()
   
   
   
   
   
   
   
   
   
   
   
   ## print to console to aid development... 
   #print(paste0("head of reactiveCancerStudies1: ", head(table)))
   
   ## append central contacts to front of site contact
   table$contacts <- paste(na.omit(table$central_contacts), na.omit(table$contacts))
   ## return table
   return(unique(table))
})

## names of reactiveCancerStudies are
#  [1] "nct_id"             "interventions"      "brief_title"        "overall_status"    
#  [5] "matching.condition" "TARGET.condition"   "Link"               "Mechanism"         
#  [9] "locations"          "sites"              "conditions"         "investigators"     
# [13] "central_contacts"   "contacts"           "Exclusions"

```
 
```{r define reactive synonymsLabel to hold cancer type synonyms}
## this value will be passed to downloaded report as a record of synonyms included in search
synonymsLabel <- reactive({
   synonyms <- paste(unique(conditionSynonyms$condition.synonyms[conditionSynonyms$controlled.cancer.type==input$cancerTypeFilter]), collapse = ", ")
   synonyms
})


```

**Rank matching studies based on genetic alterations**    

```{r parse alterations from URL}
## try this on command line
# parseQueryString("http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation")

observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['alterations']])) {
        # get alterations from url
        alterations <- query[['alterations']]
        
        urlValues$alterations <- alterations
      } 
})

```

```{r define reactive value to hold alterations from url}
## if alterations have been passed as URL arguments, get values, else set to NULL
urlAlterations <- reactive({
    if(!is.null(urlValues$alterations)) {
    alterations <- unlist(strsplit(urlValues$alterations, split=","))
    
    ## strip out surplus argument details
    # for mutations
    alterations <- gsub(pattern = "SV .*", replacement = "mutation", x=alterations, ignore.case = TRUE)
    # for rearrangements
    alterations <- gsub(pattern = "rearrangement .*", replacement = "rearrangement", x=alterations, ignore.case = TRUE)
    # for CNA amplification
    alterations <- gsub(pattern = "CNA .*amplification", replacement = "amplification", x=alterations, ignore.case = TRUE)
    # for CNA loss
    alterations <- gsub(pattern = " CNA ", replacement = " ", x=alterations, ignore.case = TRUE)
    # drop repeated alterations
    alterations <- unique(alterations)
    
    } else alterations = NULL
    
    
    ## return value
  return(alterations)
})

## test eTARGET integration with the following URL
# http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2 CNA amplification,EGFR CNA partial_amplification,PTEN CNA loss,ABL1 rearrangement duplication,ABL1 rearrangement duplication,KRAS SV c.34G>T p.(G12C),ERBB2 amplification,EP300 rearrangement duplication,EP300 rearrangement duplication 
```

```{r display gene filter}
## having reactive list of alterations means only those with matching studies are shown, but if toggle solid tumour on/off, the UI reacts and selected values are reset to the url arguments...

## define how filter values will be populated
# output$reactiveGeneFilter <- renderUI({
#    ## uncomment to enable reactive gene filter
#    # cancer.types <- selectedCancerTypes()
#    # table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types) 
#    # table <- merge(x=table, by.x="nct_id", y=scoredMatches, by.y = "nct_id")
#    # gene_variant_type.list <- sort(unique(table$gene_variant_type))
#    
#    gene_variant_type.list <- sort(unique(scoredMatches$gene_variant_type))
#    
#    selectInput(inputId = "geneFilter", label=NULL, choices = gene_variant_type.list, selected = intersect(urlAlterations(),gene_variant_type.list), multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
#    
# })
```



```{r display reactive gene filter inc all urlAlterations}

## display all URL alterations, even if no match
## define how filter values will be populated
output$reactiveGeneFilter <- renderUI({
   gene_variant_type.list <- sort(unique(scoredMatches$gene_variant_type))
   selectInput(inputId = "geneFilter", label=NULL, choices = unique(c(gene_variant_type.list,urlAlterations())), selected = urlAlterations(), multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
   
})


## test e.g. with http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation,NONSENSE%20mutation

# display filter
shiny::renderUI({
   uiOutput("reactiveGeneFilter") 
})
```

```{r define reactive value to hold selected alterations}

# if url values passed, these are stored
# however, if url values are added/deleted from geneFilter, this reactive value is updated accordingly
selectedAlterations <- reactive({
  ## just return value of input$geneFilter
  ## if URL alterations have been passed, these will be preselected in the filter
  ## if nothing is selected, NULL is returned
  alterations <- input$geneFilter
  
  ## print to console to aid development... 
  #print(paste0("selectedAlterations value: ", alterations))
  
  ## return value
  return(alterations)
})

```
(Use Entrez symbol, e.g. ERBB2 instead of HER2)  


**Filter matching studies on study drug mechanisms**    

```{r define reactive mechanism filter}
## dropdown should display all mechanisms available for selected cancer type, regardless of which alterations have been selected
## if matches on solid tumour have been excluded, mechanisms for those matches should not be displayed

## define how filter values will be populated
output$reactive.mechanism.filter <- renderUI({
   cancer.types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)   
   mechanism.list <- sort(unique(table$Mechanism))

   selectInput(inputId = "mechanismFilter", label=NULL, choices = mechanism.list, selected = NULL, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
})

# display filter
shiny::renderUI({
   uiOutput("reactive.mechanism.filter") 
})
```

```{r display cancer type alone filter}
checkboxInput(inputId="confidenceFilter", label="Hide matches on cancer type alone?", value = FALSE, width = NULL)
```




```{r hide matches to sites in setup}

checkboxInput(inputId="inSetupFilter", label="Show sites still in setup?", value = TRUE, width = NULL)


```




```{r filter scoredMatches table}
reactiveScoredMatches <- reactive({
   table <- scoredMatches

   ## filter based on selectedAlterations
   ## if null, a table with no rows is returned
   ## if selectedAlterations not in gene_variant_type, get a table with header but no rows
   table <- dplyr::filter(table, gene_variant_type %in% selectedAlterations())
   
   ## return table
   return(unique(table))
})


## names of reactiveScoredMatches are
# [1] "symbol"                 "variant_type"           "gene_variant_type"     
# [4] "nct_id"                 "intervention_rationale" "eligibility_rationale" 
# [7] "matching_criteria"      "combined_score"   

```
 
```{r define reactive mergedStudyTable}

mergedStudyTable <-  reactive({
  ## get cancerStudies filtered on cancer type 
  cancerstudies <- reactiveCancerStudies()
  ## get scoredMatches filtered on alterations
  scoredmatches <- reactiveScoredMatches()
  ## left join, i.e. keep matches on cancer type alone
  ## if scoredMatches is empty, will just get empty columns
  table <- merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE, 
                     y=scoredmatches, by.y=c("nct_id"))
  ## display error message if table is empty 
  shiny::validate(
            need(nrow(table)>0, "No results based on selections")
        )
  
   ## if combined_score is NA, set value to zero
   table$combined_score[is.na(table$combined_score)] <- 0
   ## if a mechanism has been selected, filter table
   if(!is.null(input$mechanismFilter)) {
     tryCatch({
       table <- dplyr::filter(table, Mechanism %in% input$mechanismFilter)
       table$intervention_rationale <- paste0( "Match on selected mechanism (", table$interventions, "; ", table$Mechanism, ")")
       ## set confidence score so these matches are retained even if excluding matches on cancer type alone
       table$combined_score <- 1
       },error=function(cond) {return(NA)})
   }
   ## if excluding matches on cancer type alone, filter table
   if(input$confidenceFilter==TRUE) {table <- filter(table, combined_score >0)}
   
   
   
   
   
  ## display error message if table is empty 
  shiny::validate(
            need(nrow(table)>0, "No results based on selections")
            #need(!is.null(table), "table is NULL")
        )
   
   ## add some html code to brief_title value with relevant link
   table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
   
   ## return table
   return(unique(table))
})


## names of mergedStudyTable are 
#  [1] "nct_id"                 "interventions"          "brief_title"           
#  [4] "overall_status"         "matching.condition"     "TARGET.condition"      
#  [7] "Link"                   "Mechanism"              "locations"             
# [10] "sites"                  "conditions"             "investigators"         
# [13] "central_contacts"       "contacts"               "Exclusions"            
# [16] "symbol"                 "variant_type"           "gene_variant_type"     
# [19] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [22] "combined_score"  
  

## mergedStudyTable is the master set of data, all info for all matching studies based on user selections
## locations and sites are aggregated

```

  
Row {.tabset}
-----------------------------------------------------------------------

### Map view of sites

```{r print a map with study sites indicated}

## zoomed based on lat and long values in configuration file
## NOTE: layerIds must be unique (i.e. one study would only appear once)
## need to use combination of study ID and location to make layerIds unique
output$studiesmap <- renderLeaflet({
   studies <- unique(dplyr::select(mergedStudyTable(), nct_id, brief_title))
   locations <- merge(x=studies,by.x="nct_id", y=cancer.study.locations, by.y="nct_id")
   locations$uniqueId <- paste(locations$nct_id, locations$lat, locations$long, sep = "_")
   if(nrow(locations)>0) {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6) %>%
         addMarkers(data=locations, 
                    lat = ~lat,
                 lng = ~long,
                 popup = ~brief_title,
                 layerId = ~uniqueId, 
                 clusterOptions = markerClusterOptions())
  } else {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6)
  }
})

## render reactive map
shiny::renderUI({
   leafletOutput("studiesmap")
   
})

## create a reactive variable that will hold ID of a study selected on map
map.selection <- reactiveValues(id = NA)

## detect clicks on markers and use them to get study ID for marker that was clicked
observeEvent(input$studiesmap_marker_click, { 
   map.selection$id <- input$studiesmap_marker_click$id
   map.selection$id <- gsub(pattern = "_.*", replacement = "", x=map.selection$id)
  })

## detect click on map and use them to reset value of map.selection
observeEvent(input$studiesmap_click, {
   map.selection$id <- NA
  })
```
  
### Study details  

```{r define reactive formattedTable catch error for empty}

## render as datatable
formattedTable <- reactive({
  table <- mergedStudyTable()
  ## display error message if table is empty 
  shiny::validate(
            need(nrow(table)>0, "No matching studies based on selected options")
        )
  ## if a study has been selected on map, just display that study
  if(!is.na(map.selection$id )) {
      table <- dplyr::filter(table, nct_id == map.selection$id )
   }
   
   table <- arrange(table, desc(combined_score)) 
   table <- aggregate(table, by=table['nct_id'], function(x) {paste(unique(na.omit(x)), collapse = ";\n")})
   
   ## aggregate leads to duplication of nct_id column, so create a duplicate column called StudyID, then drop the nct_id column... 
   table$StudyID <- table$nct_id
   ## now drop nct_id column
   table <- dplyr::select(table, -nct_id)
   ## now rename back to nct_id
   table <- rename(table, nct_id = StudyID)
   ## sort of ranking score descending
   table <- arrange(table, desc(combined_score))
   ## drop redundant rows, if any
   table <- unique(table)

   return(table)
})

## names of formattedTable are same as mergedStudyTable... 
#  [1] "nct_id"                 "interventions"          "brief_title"           
#  [4] "overall_status"         "matching.condition"     "TARGET.condition"      
#  [7] "Link"                   "Mechanism"              "locations"             
# [10] "sites"                  "conditions"             "investigators"         
# [13] "central_contacts"       "contacts"               "Exclusions"            
# [16] "symbol"                 "variant_type"           "gene_variant_type"     
# [19] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [22] "combined_score"  
## but formattedTable may be subsetted based on map clicks (without losing full set of data from mergedStudyTable)

```

```{r define output for main results table}

## increase width of brief title column to 500 pixels
output$datatable <- DT::renderDT(dplyr::select(formattedTable(),
                            # combined_score,
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                            # "Matching inclusion criteria" = "matching_criteria",
                            # "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                            # "Centres" = "sites",
                            # "Investigators" = "investigators",
                            # "Central contacts" = "central_contacts",
                            "Contacts" = "contacts"
                            # "StudyID" = nct_id,
                            # "Overall status" = "overall_status",
                            # "Interventions" = "interventions",
                            # Mechanism
                            ),
                  rownames=FALSE, escape = 4, 
                  options = list(ordering=F,
                                 paging = TRUE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 columnDefs = list(list(width = '500px', targets = list(4)))
                                )
 )


## UNUSED CODE FOR OTHER OPTIONS...

## add ellipsis to locations, lose ID and contacts columns
# output$datatable <- DT::renderDT(dplyr::select(formattedTable(), -c(ID,Contacts)), escape = 5, options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE, columnDefs = list(list(
#   targets = 6,
#   render = JS(
#     "function(data, type, row, meta) {",
#     "return type === 'display' && data.length > 6 ?",
#     "'<span title=\"' + data + '\">' + data.substr(0, 6) + '...</span>' : data;",
#     "}")
# ))), callback = JS('table.page(3).draw(false);'))



## no ellipsis, keep contacts
# output$datatable <- DT::renderDT(dplyr::select(formattedTable(), -ID), escape = 5, 
#                                  options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE) 
#                                  )

```

```{r layout results table with download and shortlist buttons}

fillCol(height = 600, flex = c(NA, 1), 
        #shiny::renderPrint('printMsg'), 
        #DT::DTOutput("datatable"), 
        inputPanel(shiny::renderUI({
          downloadButton("report", "Download table", class = "btn-primary")
          }), 
          shiny::renderUI({
          actionButton("addToShortlist", "Shortlist selected studies", class = "btn-primary")
          })
          ),
        DT::DTOutput("datatable") 
        )


```

```{r detect selection of rows}
## see also https://yihui.shinyapps.io/DT-proxy/ 

## NOTE: if datatable is sorted, row indices may not match those of formattedTable()

## detect clicks on results table
proxy = dataTableProxy('datatable')
observeEvent(input$select1, {
  selectRows(proxy = proxy, selected = as.numeric(input$rows))
  })

## define reactive value that will hold indices of selected rows
indicesSelectedRows <- reactive({
  return(input$datatable_rows_selected)
})

```

```{r download handler for full results}
## see also https://shiny.rstudio.com/articles/generating-reports.html 

output$report <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)

        table=mergedStudyTable()

          if(!is.na(map.selection$id )) {
            table <- dplyr::filter(table, nct_id == map.selection$id )
         }
        
        ## if parameters (cancer type as minimum) have been passed in the URL, record studies when full table is dowloaded
        if(!is.null(urlValues$CancerType)) {
        ## get timestamp
        datetime <- Sys.time()
        ## get cancer type passed in url
        urlCancerType <- urlValues$CancerType
        ## get alterations (if any) passed in url
        urlAlterations <- NA
        if(!is.null(urlValues$alterations)) {
          urlAlterations <- urlValues$alterations
        }
        
        ## create a separate table that will be written to database
        fullResultsTable <- table 
        ## capture date and time downloaded
        fullResultsTable$datetime <- datetime
        ## capture the cancer type passed in url
        fullResultsTable$urlCancerType <- urlCancerType
        ## capture the alterations (if any) that have been passed in url
        fullResultsTable$urlAlterations <- urlAlterations
        
        ## append to dedicated table in database (if table doesn't exist, it is created)
        con3 <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
        dbWriteTable(conn = con3,name = "allDownloaded", value = fullResultsTable, append=TRUE)
        dbDisconnect(con3)
        ## use existing connection to database
        # dbWriteTable(conn = con,name = "allDownloaded", value = fullResultsTable, append=TRUE)


        }
        
        table[is.na(table)] <- "-"
        # table=rjson::toJSON(table)
        table = jsonlite::toJSON(table)
        
       
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       synonyms = synonymsLabel(), 
                       include_solid= input$solidTumourFilter, 
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       #genes=input$geneFilter,
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table,
                       ## pass configuration items
                       privacy_statement = configuration$privacy.statement,
                       contact_email = configuration$contact.email,
                       country = configuration$country,
                       about_us = configuration$about.us
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)


```

  
  
### Shortlist (`r renderText(nrow(shortlist()))` studies)


```{r define reactive shortlist}
## based on https://stackoverflow.com/questions/52427281/add-and-delete-rows-of-dt-datatable-in-r-shiny

## create an empty shortlist...
## first, get names to match those of mergedStudyTable
shortlistNames <- names(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE, 
                     y=scoredMatches, by.y=c("nct_id")))

## next, create an empty dataframe with correct number of columns, no rows
shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0))
## next, assign the column names
names(shortlist) <- shortlistNames

## define as a reactive value
shortlist <- reactiveVal(shortlist)

## observe and act on clicks on addToShortlist button
observeEvent(input$addToShortlist, {
    ## add selected rows
    t = rbind(shortlist(), formattedTable()[indicesSelectedRows(), ])
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })

```




```{r define output for shortlist table}

output$shortlistTable <- DT::renderDT(unique(dplyr::select(shortlist(),
                            # combined_score,
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                            "Matching inclusion criteria" = "matching_criteria",
                            "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                            # "Centres" = "sites",
                            # "Investigators" = "investigators",
                            # "Central contacts" = "central_contacts",
                            "Contacts" = "contacts"
                            # "StudyID" = nct_id,
                            # "Overall status" = "overall_status",
                            # "Interventions" = "interventions",
                            # Mechanism
                            )),
                  rownames=FALSE, escape = 4, 
                  options = list(ordering=F,
                                 paging = TRUE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 columnDefs = list(list(width = '500px', targets = list(4)))
                                )
  )
```

 
```{r layout shortlist with download button}

fillCol(height = 600, flex = c(NA, 1), 
        inputPanel(
          shiny::renderUI({downloadButton("downloadShortlist", "Download shortlist", class = "btn-primary")}),
          actionButton(inputId="removeSelected", "Remove selected studies", class = "btn-primary"),
          actionButton(inputId="clearShortlist", "Clear shortlist", class = "btn-primary")
          ),
        DT::DTOutput("shortlistTable") 
        )

```
 
```{r detect clicks on remove selected}
## detect clicks on shortlist

proxy2 = dataTableProxy('shortlistTable')

observeEvent(input$select1, {
    proxy2 %>% selectRows(as.numeric(input$rows))
  })


## define reactive value that will hold indices of selected rows
indicesRowsToDelete <- reactive({
  return(input$shortlistTable_rows_selected)
})


observeEvent(input$removeSelected, {
    ## add selected rows
    t = shortlist()
    if(!is.null(indicesRowsToDelete())) {
      ## drop selected rows
      t = t[-indicesRowsToDelete(), ]
  
    }
    
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


## observe clicks on clearShortlist button
observeEvent(input$clearShortlist, {
    
    ## drop all rows
    t = shortlist()[0, ]
  
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


``` 

 
 
```{r download handler for shortlist}

output$downloadShortlist <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)
        ## pass the shortlist
        table <- shortlist()
        
        
        ## if parameters (cancer type as minimum) have been passed in the URL, record which studies were shortlisted
        if(!is.null(urlValues$CancerType)) {
              ## get timestamp
              datetime <- Sys.time()
              ## get cancer type passed in url
              urlCancerType <- urlValues$CancerType
              ## get alterations (if any) passed in url
              urlAlterations <- NA
              if(!is.null(urlValues$alterations)) {
                urlAlterations <- urlValues$alterations
                }
        
              ## create a separate table that will be written to database
              shortlistTable <- table 
              ## capture date and time downloaded
              shortlistTable$datetime <- datetime
              ## capture the cancer type passed in url
              shortlistTable$urlCancerType <- urlCancerType
              ## capture the alterations (if any) that have been passed in url
              shortlistTable$urlAlterations <- urlAlterations
        
        
              ## in addition, save a copy of the full set of results obtained
              ## left join, i.e. keep matches on cancer type alone
              ## if scoredMatches is empty, will just get empty columns
              fullTable <- merge(x=reactiveCancerStudies(), by.x=c("nct_id"), all.x=TRUE, 
                           y=reactiveScoredMatches(), by.y=c("nct_id"))  
              ## aggregate interventions column
              fullTable <- fullTable %>%
                  group_by(across(c(-interventions))) %>%
                  summarise("interventions" = paste(na.omit(unique(interventions)), collapse = ", ")) %>%
                  as.data.frame()
              
              fullTable$datetime <- datetime
              fullTable$urlCancerType <- urlCancerType
              fullTable$urlAlterations <- urlAlterations
        
        
        
              ## append to dedicated table in database (if table doesn't exist, it is created)
              con2 <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
              dbWriteTable(conn = con2,name = "shortlisted", value = shortlistTable, append=TRUE)
              dbWriteTable(conn = con2,name = "fullresults", value = fullTable, append=TRUE)
              dbDisconnect(con2)
              
              ## use existing database connection
              # dbWriteTable(conn = con,name = "shortlisted", value = shortlistTable, append=TRUE)
              # dbWriteTable(conn = con,name = "fullresults", value = fullTable, append=TRUE)

        }
        

        table[is.na(table)] <- "-"
        ## table=rjson::toJSON(table)
        table = jsonlite::toJSON(table)

        
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       include_solid= input$solidTumourFilter, 
                       synonyms = synonymsLabel(), 
                       #genes=input$geneFilter,
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table,
                       ## pass configuration items
                       privacy_statement = configuration$privacy.statement,
                       contact_email = configuration$contact.email,
                       country = configuration$country,
                       about_us = configuration$about.us
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)


```
  
  

```{r disconnect from database}
dbDisconnect(con) 

```

  

     

### About  
  
#### About us  

`r configuration$about.us`.    


We would be grateful for feedback as to utility of this tool – if you have any feedback, or you would like to know more detail about this tool, please contact `r configuration$contact.email`.  

#### What does this tool do?  
  
The digital ECMT cancer trial matching tool is intended to support clinicians in the matching of people with cancer to clinical trials based on their cancer type, genetic alterations and/or trial drug mechanism. This is an early version that could possibly change.  
  
  
Potential matching trials are ranked according to the following order:   
  
  
1.	Study is enrolling patients with specified genetic alterations, AND specified gene is targeted by a study drug.  

2.	Study is enrolling patients with specified genetic alterations, AND a study drug targets a gene immediately downstream.  

3.	Study is enrolling patients with specified genetic alterations.  

4.	Study drug targets gene of interest.  

5.	Study drug targets a gene immediately downstream of specified genetic alteration.  

6.	Match on cancer type alone.  
  
  
#### Data sources  
  
* Trial data are sourced exclusively from clinicaltrials.gov via the Clinical Trials Transformation Initiative (https://www.ctti-clinicaltrials.org/ ).   

* Data regarding mechanisms of trial interventions are sourced from the NCI Thesaurus: https://ncithesaurus.nci.nih.gov/ncitbrowser/  

* Data regarding biological pathways are sourced from KEGG (https://www.kegg.jp/kegg/) using the R BioConductor package: https://www.bioconductor.org/  
  
* Contains Ordnance Survey data © Crown copyright and database right 2021  
  
* Contains Royal Mail data © Royal Mail copyright and database right 2021  
  
* Source: Office for National Statistics licensed under the Open Government Licence v.3.0  
  
#### Limitations  
  
* **Please note that it is not a comprehensive source of information about clinical trials, and its utility not been validated for use in clinical decision making.**  

* Trials that are not included in clinicaltrials.gov will not be included in the search.  
  
  
* Only studies with at least one site in `r configuration$country` are included. If you are interested in hosting a site for other countries, please contact `r configuration$contact.email`.  
  

* Data are refreshed daily, but clinicians are advised to contact the relevant investigators to confirm recruitment status.  

* Study eligibility criteria are tagged with the relevant genetic alterations based on natural language processing – some criteria may be incorrectly tagged, and some relevant criteria may be missed.  
  
  
### Legal  
  
  
    
* The University of Manchester digital ECMT team’s cancer trial matching tool includes content intended for use only by healthcare professionals. This tool does not give professional advice; physicians and other healthcare professionals who use this tool should exercise their own clinical judgment as to the information it provides. Individuals with any type of medical condition are specifically cautioned to seek professional medical advice before beginning any sort of health treatment. For medical concerns, including decisions about medications and other treatments, non-medical users should always consult their physician or other qualified healthcare professional.  


*	We do not give medical advice, nor do we provide medical or diagnostic services. Medical information changes rapidly. Neither we nor our content providers guarantee that the content of this tool covers all possible uses, directions, precautions, drug interactions, or adverse effects that may be associated with any therapeutic treatments.  

*	In the absence of any negligence or other breach of duty by us: (1) your reliance upon information and content obtained by you at or through this site is solely at your own risk; and (2) neither we nor our content providers are responsible for any damage or injury (including death) to you, other persons, or property arising from any use of any product, information, idea, or instruction in the content of the tool.  
  
#### Privacy  
  
`r configuration$privacy.statement`.  
 
  
  

```{r exit script }
knitr::knit_exit()
```
 
  
