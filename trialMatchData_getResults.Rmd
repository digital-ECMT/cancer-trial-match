---
title: "Get results to show in trial finder"
author: "digital ECMT"
date: "19/11/2021"
output: html_document
---


```{r copyright notice}
 # 
 # This file is part of the cancer-trial-match distribution (https://github.com/digital-ECMT/cancer-trial-match).
 # Copyright (C) 2021 digital ECMT
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3 or later.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #


```




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
##NOTE: the following packages are required to run this script, but should be installed (e.g. using code snippets below) before runnning the script, NOT as part of the script itself
# options(repos = "http://cran.us.r-project.org")
# install.packages("BiocManager")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("KEGGREST")
# BiocManager::install("KEGGlincs")
# BiocManager::install("hgu133a.db")
require(KEGGlincs)        ## GPL-3
require(KEGGgraph)        ## GPL >= 2
require(org.Hs.eg.db)     ## Artistic-2.0
require(KEGGREST)         ## Artistic 2.0
require(DBI)              ## LGPL-2.1 | LGPL-3 
require(RODBC)            ## GPL-2 | GPL-3
require(RPostgres)        ## GPL-3
require(RSQLite)          ## LGPL-2.1 | LGPL-3
require(jsonlite)         ## MIT
require(dplyr)            ## MIT
require(tidyr)            ## MIT
require(formattable)      ## MIT
require(kableExtra)       ## MIT
require(stringr)          ## MIT
require(splitstackshape)  ## GPL-3
require(reshape2)         ## MIT
require(tictoc)           ## Apache License (== 2.0
require(leaflet)          ## GPL-3
require(PostcodesioR)     ## GPL-3
require(igraph)           ## GPL-2 | GPL-3
require(tidygeocoder)     ## MIT

## clean up first
rm(list=ls())

##get today's date
today <- format(Sys.Date(), format = "%d %B %Y")
```


**Date of data refresh: `r today`**  
  
  
```{r connect to SQLite DB} 
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

dbListTables(con)

```
  
#### **Get controlled terms and synonyms for cancer types**  
  
      
```{r read cancer type synonyms into memory}

conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")


```

#### **Get human gene names and synonyms**  
  
```{r read human genes table into memory}

humanGenes <- dbGetQuery(con, "SELECT * FROM genes")


```

  
#### **Get NCI thesaurus**  
  
```{r read NCIt into memory}

NCIthesaurus <- dbGetQuery(con, "SELECT * FROM NCIt")


```

  
#### **Connect to clinicaltrials.gov**  
  
  
```{r connect to clinicaltrialsgov}  
## specify user name and password for AACT account
## see https://aact.ctti-clinicaltrials.org/ for how to create an account

## load configuration data from JSON file
## configuration <- rjson::fromJSON(file = "trialMatchConfiguration.json")

## jsonlite is MIT
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")
aact.username <- configuration$aact.username
aact.password <- configuration$aact.password


## connect via RPostgres (GPL-3 licence)
drv = RPostgres::Postgres()
conn2 <- dbConnect(drv, dbname="aact",host="aact-db.ctti-clinicaltrials.org", port=5432, user=aact.username, password=aact.password )
```
 
  
#### **Get cancer studies with results**  
  
 
```{r get study data}

## get data for all cancer studies that have reported results
cancerStudiesResults_query <- "SELECT s.nct_id, s.brief_title, c.name AS condition, i.name AS interventions 
FROM studies s
INNER JOIN conditions c ON c.nct_id = s.nct_id
INNER JOIN interventions i ON i.nct_id = s.nct_id
inner join calculated_values cv on cv.nct_id = s.nct_id
WHERE s.study_type LIKE ('Interventional')
and (c.downcase_name like '%cancer%'
or c.downcase_name like '%neoplasm%'
or c.downcase_name like '%carcinoma%'
or c.downcase_name like '%tumo%')"



## get data from clinicaltrials.gov
cancerStudiesResults <- dbGetQuery(conn2,cancerStudiesResults_query)

## add a column to indicate refresh date
cancerStudiesResults$Refresh.date <- today

```
 
#### **Map verbatim condition names to controlled set of cancer types**  
  
  
```{r tokenise and join to condition synonyms}
## we can't just join to condition synonyms as condition may include extra words
## such as "Stage IV Lung Cancer AJCC v8" and "Metastatic Lung Non-Small Cell Carcinoma"

## we will provide condition synonyms as custom tokens, then tokenise, unnest and perform the join
custom_tokens <- unique(conditionSynonyms$condition.synonyms)

cancerStudiesResults$word <- as.list(corpus::text_tokens(x=cancerStudiesResults$condition,                                                filter= corpus::text_filter(combine = custom_tokens, map_case=TRUE, connector="_", drop_punct=TRUE )))


## unnest
cancerStudiesResults <- as.data.frame(unnest(data = cancerStudiesResults, word)) 
## this function does insist on replacing whitespace with a character (here, underscore), so need to swap that back to whitespace
cancerStudiesResults$word <- gsub(pattern = "_", replacement = " ", x=cancerStudiesResults$word)


## join on cancerStudiesResults$word = conditionSynonyms$condition.synonyms
cancerStudiesResults <- unique(merge(x=cancerStudiesResults, by.x = "word", y=conditionSynonyms, by.y="condition.synonyms"))

## drop the word column
cancerStudiesResults <- unique(dplyr::select(cancerStudiesResults, -c(word)))


```
  
  
#### **Map interventions to molecular targets**  
  

```{r get molecular targets for cancerStudies interventions}
## first, get all interventions (note that there will be some redundancy due to case)
drugs.targets <- unique(dplyr::select(cancerStudiesResults,nct_id,interventions))

## keep interventions column as verbatim so can join later
## make a duplicate column
drugs.targets$interventions.processed <- drugs.targets$interventions


## split and unnest on " + "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\+ ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " plus "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " plus ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unneston the word " and "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " and ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " & "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\& ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " or "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " or ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " (+) "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(\\+\\) ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

# also split and unnest on  " with "
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " with ")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)

## also split on brackets
drugs.targets$interventions.processed <- strsplit(drugs.targets$interventions.processed, split = " \\(")
drugs.targets <- unnest(data = drugs.targets, interventions.processed)
# remove closing bracket
drugs.targets$interventions.processed <- gsub(pattern = "\\)", replacement = "", x=drugs.targets$interventions.processed)


## trim off anything related to dose
# pattern is (a number, with or without a decimal point) with/without a space, followed by "mg", anything after "mg is removed
drugs.targets$interventions.processed <- gsub(pattern = " \\d+\\.?\\d+ ?mg.*", replacement = "", x=drugs.targets$interventions.processed, ignore.case = T)

## convert to lowercase
drugs.targets$interventions.processed <- tolower(drugs.targets$interventions.processed)

drugs.targets <- as.data.frame(drugs.targets)



## join to NCIthesaurus 
## drop rows without a match 
drugs.targets <- merge(x=drugs.targets, 
      by.x = "interventions.processed", 
      all.x = FALSE,
      y= unique(dplyr::select(NCIthesaurus, "NCI_ID"="ID", SynonymsLower, PreferredTerm, ParentTerm)), 
      by.y = "SynonymsLower")



# convert empty cells to NA
drugs.targets$PreferredTerm[drugs.targets$PreferredTerm==""] <- NA

## drop the interventions processed column
drugs.targets <- unique(dplyr::select(drugs.targets, -c(interventions.processed)))

## drop any rows that don't have a preferred term
#drugs.targets <- unique(drugs.targets[!is.na(drugs.targets$PreferredTerm), ])


## reduce number of rows
drugs.targets <-unique(dplyr::select(drugs.targets, interventions, PreferredTerm,NCI_ID))

## map preferred terms to drug IDs in KEGG
# drugs.targets.preferred <- unique(dplyr::select(drugs.targets, PreferredTerm))
```


```{r define function to map drug names to KEGG drug IDs}

# test using "1-methyl-D-tryptophan", aka "Indoximod"

getDrugID <- function(drugName){
  if(is.na(drugName)) return(NA)
  ## get drug ID
  drugid <- tryCatch({names(keggFind(database = "drug", query = drugName))},
             error=function(cond) {return(NA)})
  if(is.null(drugid)) return(NA)
  if(is.na(drugid)) return(NA)
  drugid <- as.list(drugid)
  return(drugid)
}

```


```{r get drug ids based on intervention name}
## add an empty column to hold drug ID
drugs.targets$drugID <- NA

tic("get drug IDs based on intervention name")
for(i in 1:nrow(drugs.targets)) {
  print(i)
  drugName <- drugs.targets$interventions[i]
  preferred <- drugs.targets$PreferredTerm[i]
  print(drugName)
  drugID <- getDrugID(drugName)
  if(is.na(drugID)) {
    drugID <- getDrugID(preferred)
  }
  
  drugs.targets$drugID[i] <- drugID
  print(drugs.targets$drugID[i])
}  
toc()

## unnest
drugs.targets <- as.data.frame(unnest(data = drugs.targets, drugID, keep_empty = TRUE))


```

```{r define function to get drug target IDs from KEGG}

getDrugTargetID <- function(drugID){
  if(is.na(drugID)) return(NA)
  geneid <- tryCatch({keggGet(drugID)[[1]]$TARGET$TARGET},
             error=function(cond) {return(NA)})
  if(is.null(geneid)) return(NA)
  if(is.na(geneid)) return(NA)
  ## parse the drugTargetID values - trim off extra characters and unnest where multiple targets per drug
  #trim everything up to "HSA:"
  geneid <- gsub(pattern = ".*\\HSA:", replacement = "", x=geneid) 
  # trim everything after square bracket
  geneid <- gsub(pattern = "\\].*", replacement = "", x=geneid) 
  # split on space into individual ids, where applicable
  geneid <- strsplit(geneid, split = " ")
  # unlist
  geneid <- unlist(geneid)
  # paste on a "hsa:"
  geneid <- paste0("hsa:",geneid)
  geneid <- as.list(geneid)
  return(geneid)
}



```



```{r map each drug ID to a target gene ID}
# drugs.targets$target_id <- NA

# drugs.targets$PreferredTerm[drugs.targets$drugID=="dr:D10231"]

temp_table <- data.frame(drugID= unique(na.omit(drugs.targets$drugID)), 
                         target_id = NA)


for(i in 1:nrow(temp_table)) {
  print(i)
  drugid <- as.character(temp_table$drugID[i])
  print(drugid)
  target_id <- getDrugTargetID(drugid)
  print(target_id)
  temp_table$target_id[i] <- list(target_id)
}


## unnest
temp_table <- as.data.frame(unnest(data = temp_table, target_id, keep_empty = FALSE))
temp_table$target_id <- as.character(temp_table$target_id)
## drop any null rows
temp_table <- temp_table[temp_table$target_id != "NULL", ]
```





```{r define function to get drug target symbols from KEGG via API}}
# keggGet("hsa:3620")[[1]]$SYMBOL[1]


getDrugTargetSymbol <- function(targetID){
  if(is.na(targetID)) return(NA)
  geneSymbol <- tryCatch({
    keggGet(targetID)[[1]]$SYMBOL[1]
    }, error=function(cond) {return(NA)})
  if(is.null(geneSymbol)) return(NA)
  if(is.na(geneSymbol)) return(NA)
  ## parse value
  ## multiple symbols separated by comma, we want the first one...
  geneSymbol <- gsub(pattern = ",.*", replacement = "", x=geneSymbol)
  
  return(geneSymbol)
}
```



```{r get drug symbols using function}
temp_table$target_symbol <- NA

tic("get drug target symbols")
for(i in 1:nrow(temp_table)) {
  print(i)
  targetID <- temp_table$target_id[i]
  print(targetID)
  temp_table$target_symbol[i] <- getDrugTargetSymbol(targetID)
  print(temp_table$target_symbol[i])
}
toc()


# temp_table[temp_table$target_symbol != "NA", ]
temp_table <- temp_table[complete.cases(temp_table), ]


# 
# ## reorder columns
# drugs.targets <- unique(dplyr::select(drugs.targets,"interventions.verbatim"= "interventions", interventions.processed, Description, ParentTerm, drugTargetSymbol))
```
  


```{r join target name to interventions}
drugs.targets <- unique(merge(x=drugs.targets, by.x="drugID", all.x=TRUE, y=temp_table, by.y = "drugID"))



```

```{r join mechanisms from NCIt}
drugs.targets <- unique(merge(x=drugs.targets, by.x="NCI_ID", all.x=TRUE, y=unique(dplyr::select(NCIthesaurus, ID, Class, ParentTerm)), by.y = "ID"))

```

```{r join drugs targets back to nct_id}

cancerStudiesResults_interventions <- unique(merge(x=unique(dplyr::select(cancerStudiesResults, nct_id, interventions)), by.x = "interventions", y=drugs.targets, by.y="interventions"))



cancerStudiesResults
```




```{r disconnect from  database}

# disconnect from clincialtrials.gov
dbDisconnect(conn2)

# Disconnect from SQLite database
dbDisconnect(con)


```
  
`r knitr::knit_exit()`    
  
   
   