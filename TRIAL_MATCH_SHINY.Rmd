---
title: "digital ECMT cancer trial matching tool"
output: 
  flexdashboard::flex_dashboard:
    #source_code: embed
    orientation: rows
    logo: digitalECMTlogo48px.PNG
    theme: spacelab
    # includes:
    #    in_header: JS/matomo.js
runtime: shiny

---

```{r copyright notice}
 # 
 # This file is part of the cancer-trial-match distribution (https://github.com/digital-ECMT/cancer-trial-match).
 # Copyright (C) 2021 digital ECMT
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3 or later.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #


# start_time <- Sys.time()
```

```{r setup, include=FALSE}

require(rmarkdown)
require(flexdashboard)      ## MIT
require(dplyr)              ## MIT
require(tidyr)              ## MIT
require(kableExtra)         ## MIT
require(shinyWidgets)       ## GPL-3
require(leaflet)            ## GPL-3
require(htmltools)          ## GPL-2 | GPL-3
require(jsonlite)           ## MIT
require(RSQLite)            ## LGPL-2.1 | LGPL-3
require(DT)                 ## GPL-3
require(DBI)                ## LGPL-2.1 | LGPL-3
require(stringr)            ## MIT
# require(plyr)

## load configuration data from JSON file
configuration <- jsonlite::fromJSON(txt = "trialMatchConfiguration.json")

# message(print(paste0("loaded libraries: ", Sys.time() - start_time)))

```
  
```{r connect to SQLite DB}
## connect to DB generated by indexTrialData.Rmd
sqlite_con <- DBI::dbConnect(RSQLite::SQLite(), "indexedTrialData.sqlite")

```

```{r read cancer study data into memory}
## read cancerStudies table into memory
cancerStudies <- DBI::dbGetQuery(sqlite_con, "SELECT * FROM cancerStudies")

## explicitly convert dates to numeric
cancerStudies$last_update_posted_date <- as.numeric(cancerStudies$last_update_posted_date)
cancerStudies$primary_completion_date <- as.numeric(cancerStudies$primary_completion_date)


## convert dates from numeric to date class
cancerStudies$last_update_posted_date <- as.Date(cancerStudies$last_update_posted_date, origin = "1970-01-01")

cancerStudies$primary_completion_date <- as.Date(cancerStudies$primary_completion_date, origin = "1970-01-01")

## format dates  
cancerStudies$last_update_posted_date <- format(cancerStudies$last_update_posted_date, format = "%d %b %Y")

cancerStudies$primary_completion_date <- format(cancerStudies$primary_completion_date, format = "%d %b %Y")


## get refresh date
# refresh.date <- unique(cancerStudies$Refresh.date)
refresh_date <- cancerStudies$refresh_date[1]     ## for speed

## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")

## ensure lat and long values are numeric
cancerStudies$latitude <- as.numeric(cancerStudies$latitude)
cancerStudies$longitude <- as.numeric(cancerStudies$longitude)

## rename parentTerm column as "Mechanism"
# cancerStudies <- dplyr::rename(cancerStudies, "Mechanism"="ParentTerm")

cancerStudies$condition_PT <- stringr::str_squish(cancerStudies$condition_PT)

## read conditions and synonyms into memory
conditionSynonyms <- DBI::dbGetQuery(sqlite_con, "SELECT * FROM conditionSynonyms")
```

```{r get a full set of all study locations}
cancer_study_locations <- unique(dplyr::select(cancerStudies, nct_id, latitude, longitude))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP (BUT WILL BE IN THE TABLE)
cancer_study_locations <- cancer_study_locations[complete.cases(cancer_study_locations), ]

# message(print(paste0("got study locations: ", Sys.time() - start_time)))

```

```{r add flag for sites not yet recruiting}
cancerStudies$city[cancerStudies$site_status=="Not yet recruiting"] <- paste0(cancerStudies$city[cancerStudies$site_status=="Not yet recruiting"], " (in setup)")

# message(print(paste0("added not yet recruiting flag: ", Sys.time() - start_time)))

```

```{r get prior tx exclusions (MOVED TO INDEXTRIALDATA.Rmd)}
# ## read indexed eligibilities table into memory
# indexedEligibility <- DBI::dbGetQuery(con, "SELECT * FROM indexed_eligibilities_view")
# 
# ## filter for exclusions
# excludedTX <- dplyr::filter(indexedEligibility, criterion.type=="EXCLUSION")
# 
# ## filter for prior therapy
# excludedTX <- dplyr::filter(excludedTX, feature=="prior therapy")
# 
# ## drop unnecessary columns
# excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))
# 
# ## aggregate into single row per study
# excludedTX <- excludedTX %>%
#        dplyr::group_by(nct_id) %>%
#        dplyr::summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
#        as.data.frame()
# 
# ## join to cancerStudies
# # cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")
# cancerStudies <- plyr::join(x=cancerStudies, y=excludedTX, by = "nct_id", type = "left")    ## plyr::join is faster than merge
# 
# # message(print(paste0("got prior tx exclusions: ", Sys.time() - start_time)))

```

```{r read studies scored on match against genes of interest}
## read cancerStudies table into memory
scored_matches <- DBI::dbGetQuery(sqlite_con, "SELECT * FROM scored_matches")

##  contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest

```

```{r load interventions table}

interventions <- DBI::dbGetQuery(sqlite_con, "SELECT * FROM interventions") %>%
    dplyr::mutate(intervention_name = ifelse(test = intervention_pt != "", yes = intervention_pt, no = intervention_name))    ## if there is a pt for intervention, use it...


```



# (data refreshed `r refresh_date`)  

Inputs {.sidebar}
-----------------------------------------------------------------------

**Filter studies on cancer type**    

```{r define a reactive value that will hold parameters from url}
## define a reactive value that will hold cancer type from URL, if any
urlValues <- shiny::reactiveValues()

```

```{r parse cancer type from URL}
shiny::observe({
      query <- shiny::parseQueryString(session$clientData$url_search)
      if (!is.null(query[['cancerType']])) {
        urlValues$CancerType <- query[['cancerType']]
      } 
})
```

```{r display cancer type dropdown}
available_cancer_types <- sort(unique(cancerStudies$condition_PT))

output$reactiveCancerFilter <- shiny::renderUI({
  ## multiple = TRUE allows user to start typing 
  shiny::selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available_cancer_types, selected = urlValues$CancerType, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
  
})
# display filter
shiny::renderUI({
   shiny::uiOutput("reactiveCancerFilter")
})

## can test when running locally by manually changing URL to e.g. http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast

```

```{r include matches on solid tumour}

shiny::checkboxInput(inputId="solidTumourFilter", label="Include matches on solid tumour?", value = TRUE, width = NULL)

```

```{r define a reactive value that will hold selected cancer type}

## if solid tumours selected, solid is added as an additional cancer type
selectedCancerTypes <- shiny::reactive({
  if(input$solidTumourFilter==FALSE) {cancer_types <- input$cancerTypeFilter}
  else {cancer_types <- c(input$cancerTypeFilter, "Solid")}
  
  ## print to console to aid development... 
  #print(paste0("selectedCancerTypes value: ", cancer_types))
  
  ## return value
  cancer_types
})

```

```{r define reactive cancerStudies table}
reactiveCancerStudies <- shiny::reactive({
   cancer_types <- selectedCancerTypes()

   table <- dplyr::filter(cancerStudies, condition_PT %in% cancer_types)
   
   ## if hiding studies in setup, filter table
   if(input$inSetupFilter==FALSE) {table <- dplyr::filter(table, site_status == "Recruiting")}
   
   ## aggregate into compact form
   table <- table %>%
       dplyr::group_by_at(dplyr::vars(-c( city, condition, site_status, site_contacts,central_contacts, latitude, longitude, refresh_date))) %>%
       dplyr::summarize(locations = toString(sort(unique(na.omit(city)))),
                 conditions = toString(sort(unique(na.omit(condition)))),
                 central_contacts = toString(sort(unique(na.omit(central_contacts)))),
                 contacts = toString(sort(unique(na.omit(site_contacts))))) %>%
       as.data.frame()
   

   ## print to console to aid development... 
   #print(paste0("head of reactiveCancerStudies1: ", head(table)))
   
   ## append central contacts to front of site contact
   table$contacts <- paste(na.omit(table$central_contacts), na.omit(table$contacts))
   ## return table
   return(unique(table))
})



```
 
```{r define reactive synonymsLabel to hold cancer type synonyms}
## this value will be passed to downloaded report as a record of synonyms included in search
synonymsLabel <- shiny::reactive({
   synonyms <- paste(unique(conditionSynonyms$condition_synonyms[conditionSynonyms$controlled_cancer_type==input$cancerTypeFilter]), collapse = ", ")
   synonyms
})


```

**Rank matching studies based on genetic alterations**    

```{r parse alterations from URL}
## try this on command line
# parseQueryString("http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation")

shiny::observe({
      query <- shiny::parseQueryString(session$clientData$url_search)
      if (!is.null(query[['alterations']])) {
        # get alterations from url
        alterations <- query[['alterations']]
        
        urlValues$alterations <- alterations
      } 
})

```

```{r define reactive value to hold alterations from url}
## if alterations have been passed as URL arguments, get values, else set to NULL
urlAlterations <- shiny::reactive({
    if(!is.null(urlValues$alterations)) {
    alterations <- unlist(strsplit(urlValues$alterations, split=","))
    
    ## strip out surplus argument details
    # for mutations
    alterations <- gsub(pattern = "SV .*", replacement = "mutation", x=alterations, ignore.case = TRUE)
    # for rearrangements
    alterations <- gsub(pattern = "rearrangement .*", replacement = "rearrangement", x=alterations, ignore.case = TRUE)
    # for CNA amplification
    alterations <- gsub(pattern = "CNA .*amplification", replacement = "amplification", x=alterations, ignore.case = TRUE)
    # for CNA loss
    alterations <- gsub(pattern = " CNA ", replacement = " ", x=alterations, ignore.case = TRUE)
    # drop repeated alterations
    alterations <- unique(alterations)
    
    } else alterations = NULL
    
    
    ## return value
  return(alterations)
})

## test eTARGET integration with the following URL
# http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2 CNA amplification,EGFR CNA partial_amplification,PTEN CNA loss,ABL1 rearrangement duplication,ABL1 rearrangement duplication,KRAS SV c.34G>T p.(G12C),ERBB2 amplification,EP300 rearrangement duplication,EP300 rearrangement duplication 
```

```{r display reactive gene filter inc all urlAlterations}

## display all URL alterations, even if no match
## define how filter values will be populated
output$reactiveGeneFilter <- shiny::renderUI({
   gene_alteration_type_list <- sort(unique(scored_matches$gene_alteration_type))
   shiny::selectInput(inputId = "geneFilter", label=NULL, choices = unique(c(gene_alteration_type_list,urlAlterations())), selected = urlAlterations(), multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
   
})

## test e.g. with http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation,NONSENSE%20mutation

# display filter
shiny::renderUI({
   shiny::uiOutput("reactiveGeneFilter") 
})
```

```{r define reactive value to hold selected alterations}

# if url values passed, these are stored
# however, if url values are added/deleted from geneFilter, this reactive value is updated accordingly
selectedAlterations <- shiny::reactive({
  ## just return value of input$geneFilter
  ## if URL alterations have been passed, these will be preselected in the filter
  ## if nothing is selected, NULL is returned
  alterations <- input$geneFilter
  
  ## print to console to aid development... 
  #print(paste0("selectedAlterations value: ", alterations))
  
  ## return value
  return(alterations)
})

```
(Use Entrez symbol, e.g. ERBB2 instead of HER2)  


**Filter matching studies on study drug mechanisms**    

```{r define reactive mechanism filter}
## dropdown should display all mechanisms available for selected cancer type, regardless of which alterations have been selected
## if matches on solid tumour have been excluded, mechanisms for those matches should not be displayed

## define how filter values will be populated
output$reactive_mechanism_filter <- shiny::renderUI({
   cancer_types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, condition_PT %in% cancer_types) %>%
     merge(by.x = "nct_id", y = unique(dplyr::select(interventions, nct_id, "Mechanism" = "Parent_synonym")), by.y = "nct_id")
   mechanism_list <- sort(unique(table$Mechanism))

   shiny::selectInput(inputId = "mechanismFilter", label=NULL, choices = mechanism_list, selected = NULL, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
})

# display filter
shiny::renderUI({
   shiny::uiOutput("reactive_mechanism_filter") 
})
```

```{r display cancer type alone filter}
shiny::checkboxInput(inputId="confidenceFilter", label="Hide matches on cancer type alone?", value = FALSE, width = NULL)
```

```{r hide matches to sites in setup}
shiny::checkboxInput(inputId="inSetupFilter", label="Show sites still in setup?", value = TRUE, width = NULL)
```

```{r filter scored_matches table}
reactivescored_matches <- shiny::reactive({
   table <- scored_matches

   ## filter based on selectedAlterations
   ## if null, a table with no rows is returned
   ## if selectedAlterations not in gene_alteration_type, get a table with header but no rows
   table <- dplyr::filter(table, gene_alteration_type %in% selectedAlterations())
   
   ## return table
   return(unique(table))
})

```
 
```{r define reactive mergedStudyTable}

mergedStudyTable <-  shiny::reactive({
  ## get cancerStudies filtered on cancer type 
  ## get scored_matches filtered on alterations
  ## left join, i.e. keep matches on cancer type alone
  ## if scored_matches is empty, will just get empty columns
  table <- plyr::join(x=reactiveCancerStudies(), y=reactivescored_matches(), by = "nct_id", type = "left")   ## join is faster than merge
  

  ## display error message if table is empty 
  shiny::validate(
            need(nrow(table)>0, "No results based on selections")
        )
  
   ## if combined_score is NA, set value to zero
   table$combined_score[is.na(table$combined_score)] <- 0
   ## if a mechanism has been selected, filter table
   if(!is.null(input$mechanismFilter)) {
     filtered_interventions <- interventions %>%
       dplyr::filter(Parent_synonym %in% input$mechanismFilter) %>%
       dplyr::select(nct_id, intervention_name, Parent_synonym) %>%
       unique()
     
     tryCatch({
       table <- plyr::join(x=reactiveCancerStudies(), y=scored_matches, by = "nct_id", type = "left") %>%
         merge(by.x = "nct_id", y = filtered_interventions, by.y = "nct_id") %>%
         dplyr::mutate(intervention_rationale = paste0( "Match on selected mechanism (", intervention_name, "; ", Parent_synonym, ")")) %>%
         dplyr::select(table, -c(intervention_name, Parent_synonym)) %>% 
         dplyr::mutate(combined_score = 1)   %>%     ## set confidence score so these matches are retained even if excluding matches on cancer type alone
         unique()

       },error=function(cond) {return(NA)})
   }
   ## if excluding matches on cancer type alone, filter table
   if(input$confidenceFilter==TRUE) {table <- filter(table, combined_score >0)}
   
  ## display error message if table is empty 
  shiny::validate(
            need(nrow(table)>0, "No results based on selections")
            #need(!is.null(table), "table is NULL")
        )
   
   ## add some html code to brief_title value with relevant link
   table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
   
   ## return table
   return(unique(table))
})


## mergedStudyTable is the master set of data, all info for all matching studies based on user selections
## locations and sites are aggregated

```

Row {.tabset}
-----------------------------------------------------------------------

### Map view of sites

```{r print a map with study sites indicated}

## zoomed based on lat and long values in configuration file
## NOTE: layerIds must be unique (i.e. one study would only appear once)
## need to use combination of study ID and location to make layerIds unique
output$studiesmap <- renderLeaflet({
   studies <- unique(dplyr::select(mergedStudyTable(), nct_id, brief_title))
   # locations <- merge(x=studies,by.x="nct_id", y=cancer.study.locations, by.y="nct_id")
   locations <- plyr::join(x=studies, y=cancer_study_locations, by = "nct_id", type = "inner")   ## join is faster than merge
   locations$uniqueId <- paste(locations$nct_id, locations$latitude, locations$longitude, sep = "_")
   if(nrow(locations)>0) {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6) %>%
         addAwesomeMarkers(data=locations, 
                    lat = ~latitude,
                 lng = ~longitude,
                 popup = ~brief_title,
                 layerId = ~uniqueId, 
                 icon = awesomeIcons(),
                 clusterOptions = markerClusterOptions())
  } else {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6)
  }
})

## render reactive map
shiny::renderUI({
   leafletOutput("studiesmap")
   
})

## create a reactive variable that will hold ID of a study selected on map
map.selection <- shiny::reactiveValues(id = NA)

## detect clicks on markers and use them to get study ID for marker that was clicked
shiny::observeEvent(input$studiesmap_marker_click, { 
   map.selection$id <- input$studiesmap_marker_click$id
   map.selection$id <- gsub(pattern = "_.*", replacement = "", x=map.selection$id)
  })

## detect click on map and use them to reset value of map.selection
shiny::observeEvent(input$studiesmap_click, {
   map.selection$id <- NA
  })
```
  
### Study details  

```{r define reactive formattedTable catch error for empty}

## render as datatable
formattedTable <- shiny::reactive({
  table <- mergedStudyTable()
  ## display error message if table is empty 
  shiny::validate(
            need(nrow(table)>0, "No matching studies based on selected options")
        )
  ## if a study has been selected on map, just display that study
  if(!is.na(map.selection$id )) {
      table <- dplyr::filter(table, nct_id == map.selection$id )
   }
   
   table <- dplyr::arrange(table, desc(combined_score)) 
   table <- aggregate(table, by=table['nct_id'], function(x) {paste(unique(na.omit(x)), collapse = ";\n")})
   
   ## aggregate leads to duplication of nct_id column, so create a duplicate column called StudyID, then drop the nct_id column... 
   table$StudyID <- table$nct_id
   ## now drop nct_id column
   table <- dplyr::select(table, -nct_id)
   ## now rename back to nct_id
   table <- dplyr::rename(table, nct_id = StudyID)
   ## sort of ranking score descending
   table <- dplyr::arrange(table, desc(combined_score))
   ## drop redundant rows, if any
   table <- unique(table)

   return(table)
})


## but formattedTable may be subsetted based on map clicks (without losing full set of data from mergedStudyTable)

```

```{r define output for main results table}

## add ellipsis to locations
output$datatable <- DT::renderDT(dplyr::select(formattedTable(),
                            "Brief title" = "brief_title",
                            "Matching alteration(s)" = "gene_alteration_type",
                            "Matching cancer type(s)" = "condition_PT",
                            "Eligibility" = "eligibility_rationale",
                            "Drug rationale" = "intervention_rationale",
                            "Est. completion date" = "primary_completion_date",
                            "Last updated" = "last_update_posted_date",
                            "Locations" = "locations",
                            "Contacts" = "contacts"
                            ),
                  rownames=FALSE, escape = 4,
                  options = list(ordering=F,
                                 paging = FALSE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 columnDefs = list(list(width = '500px', targets = list(0)),
                                                   list(targets = 7,
                                                        render = htmlwidgets::JS("function(data, type, row, meta) {",
    "return type === 'display' && data.length > 20 ?",
    "'<span title=\"' + data + '\">' + data.substr(0, 20) + '<br><b>(see more ...)</b></span>' : data;",
    "}"  )
    ))
    # ,     callback = JS('table.page(3).draw(false);'))
))


# message(print(paste0("defined output for main results table: ", Sys.time() - start_time)))

```

```{r layout results table with download and shortlist buttons}

shiny::fillCol(height = 600, flex = c(NA, 1), 
        shiny::inputPanel(shiny::renderUI({
          shiny::downloadButton(outputId = "report", label = "Download table", class = "btn-primary")
          }), 
          shiny::renderUI({
          shiny::actionButton(inputId = "addToShortlist", label = "Shortlist selected studies", class = "btn-primary")
          })
          ),
        DT::DTOutput("datatable") 
    )
```

```{r detect selection of rows}
## see also https://yihui.shinyapps.io/DT-proxy/ 

## NOTE: if datatable is sorted, row indices may not match those of formattedTable()

## detect clicks on results table
proxy = DT::dataTableProxy('datatable')
shiny::observeEvent(input$select1, {
  DT::selectRows(proxy = proxy, selected = as.numeric(input$rows))
  })

## define reactive value that will hold indices of selected rows
indicesSelectedRows <- shiny::reactive({
  return(input$datatable_rows_selected)
})

# message(print(paste0("detect selection of rows: ", Sys.time() - start_time)))
```

```{r download handler for full results}
## see also https://shiny.rstudio.com/articles/generating-reports.html 

output$report <- shiny::downloadHandler(
      filename = "trial_report.html",      # For PDF output, change this to "report.pdf"
      content = function(file) {           # A function that takes a single argument file that is a file path (string) of a nonexistent temp file, and writes the content to that file path. 
        
        # Copy report file to a temporary directory before processing, in case we don't have write permissions to the current working dir (which can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")         
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)    
        
        ## get mergedStudyTable
        table=mergedStudyTable()

          if(!is.na(map.selection$id )) {
            table <- dplyr::filter(table, nct_id == map.selection$id )
         }

        ## change NA to dash for appearance
        table[is.na(table)] <- "-"
        # table=rjson::toJSON(table)
        table = jsonlite::toJSON(table)
 
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       synonyms = synonymsLabel(), 
                       include_solid= input$solidTumourFilter, 
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       #genes=input$geneFilter,
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table,
                       ## pass configuration items
                       privacy_statement = configuration$privacy.statement,
                       contact_email = configuration$contact.email,
                       country = configuration$country,
                       about_us = configuration$about.us
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)

# message(print(paste0("defined download handler for full results: ", Sys.time() - start_time)))

```

### Shortlist (`r renderText(nrow(shortlist()))` studies)

```{r define reactive shortlist}
## based on https://stackoverflow.com/questions/52427281/add-and-delete-rows-of-dt-datatable-in-r-shiny

## create an empty shortlist...
## first, get names to match those of mergedStudyTable
# shortlistNames <- names(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE, 
#                      y=scored_matches, by.y=c("nct_id")))


#shortlistNames <- unique(c(names(scored_matches), names(cancerStudies)))
shortlistNames <- c("nct_id", "brief_title", "condition_PT", "gene_alteration_type", "eligibility_rationale", "intervention_rationale", "primary_completion_date", "last_update_posted_date", "matching_criteria", "tx_exclusions", "locations", "contacts")
#shortlistNames <- formattedTable() %>% names()

## next, create an empty dataframe with correct number of columns, no rows
shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0))
## next, assign the column names
names(shortlist) <- shortlistNames

## define as a reactive value
shortlist <- shiny::reactiveVal(
  shortlist 
  )

## observe and act on clicks on addToShortlist button
shiny::observeEvent(input$addToShortlist, {
    ## add selected rows
    t = shortlist() %>%
      dplyr::select(all_of(shortlistNames)) %>%
      #unique() %>%
      rbind(formattedTable()[indicesSelectedRows(), ])
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


## for speed, define a function outside observeEvent to add rows to shortlist 
## Note that the <<- operator is used instead of <- to update the non-reactive shortlist data frame within the addRowsToShortlist function. This is because shortlist is defined outside of the function's scope.

## add selected rows outside of observeEvent
# addRowsToShortlist <- function() {
#   ## add selected rows
#   t = rbind(shortlist, formattedTable()[indicesSelectedRows(), ])
#   ## drop duplicated rows
#   t = unique(t)
#   # update shortlist with new value
#   shortlist <<- t
# }
# 
# ## observe and act on clicks on addToShortlist button
# observeEvent(input$addToShortlist, {
#   addRowsToShortlist()
# })

# message(print(paste0("defined reactive shortlist: ", Sys.time() - start_time)))

```

```{r define output for shortlist table}

# output$shortlistTable <- DT::renderDT(unique(dplyr::select(shortlist(),
#                             "Brief title" = "brief_title",
#                             "Matching alteration(s)" = "gene_alteration_type",
#                             "Matching cancer type(s)" = "matching.condition",
#                             "Eligibility" = "eligibility_rationale",
#                             "Drug rationale" = "intervention_rationale",
#                             "Est. completion date" = "primary_completion_date",
#                             "Last updated" = "last_update_posted_date",
#                             "Matching inclusion criteria" = "matching_criteria",
#                             "Prior Therapy exclusions" = Exclusions,
#                             "Locations" = "locations",
#                             "Contacts" = "contacts"
#                             )),
#                   rownames=FALSE, escape = 4, 
#                   options = list(ordering=F,
#                                  paging = TRUE,
#                                  scrollX = TRUE,
#                                  scrollY = "60vh",
#                                  scrollCollapse = TRUE,
#                                  autoWidth = TRUE,
#                                  columnDefs = list(list(width = '500px', targets = list(4)))
#                                 )
#   )

## show tooltips
output$shortlistTable <- DT::renderDT(unique(dplyr::select(shortlist(),
                            "Brief title" = "brief_title",
                            "Matching alteration(s)" = "gene_alteration_type",
                            "Matching cancer type(s)" = "condition_PT",
                            "Eligibility" = "eligibility_rationale",
                            "Drug rationale" = "intervention_rationale",
                            "Est. completion date" = "primary_completion_date",
                            "Last updated" = "last_update_posted_date",
                            "Matching inclusion criteria" = "matching_criteria",
                            "Prior Therapy exclusions" = "tx_exclusions",
                            "Locations" = "locations",
                            "Contacts" = "contacts"
                            )),
                  rownames=FALSE, escape = 4, 
                  options = list(ordering=F,
                                 paging = TRUE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 columnDefs = list(list(width = '500px', targets = list(0)),
                                                   list(width = '250px', targets = list(7,8,9), 
                                                       render = htmlwidgets::JS("function(data, type, row, meta) {
                                                           if (type === 'display' && data.length > 200) {
                                                               return '<span title=\"'+data+'\">'+data.substr(0, 200)+'<br><b>(see more ...)</b></span>';
                                                           } else {
                                                               return data;
                                                           }
                                                       }")))
                                )
  )




```

```{r layout shortlist with download button}

shiny::fillCol(height = 600, flex = c(NA, 1), 
        shiny::inputPanel(
          shiny::renderUI({downloadButton("downloadShortlist", "Download shortlist", class = "btn-primary")}),
          shiny::actionButton(inputId="removeSelected", "Remove selected studies", class = "btn-primary"),
          shiny::actionButton(inputId="clearShortlist", "Clear shortlist", class = "btn-primary")
          ),
        DT::DTOutput("shortlistTable") 
        )

```
 
```{r detect clicks on remove selected}
## detect clicks on shortlist

proxy2 = DT::dataTableProxy('shortlistTable')

observeEvent(input$select1, {
    proxy2 %>% DT::selectRows(as.numeric(input$rows))
  })


## define reactive value that will hold indices of selected rows
indicesRowsToDelete <- shiny::reactive({
  return(input$shortlistTable_rows_selected)
})


shiny::observeEvent(input$removeSelected, {
    ## add selected rows
    t = shortlist()
    if(!is.null(indicesRowsToDelete())) {
      ## drop selected rows
      t = t[-indicesRowsToDelete(), ]
  
    }
    
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


## observe clicks on clearShortlist button
shiny::observeEvent(input$clearShortlist, {
    
    ## drop all rows
    t = shortlist()[0, ]
  
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


``` 

```{r download handler for shortlist}

output$downloadShortlist <- shiny::downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)
        ## pass the shortlist
        table <- shortlist()
        
        
        # ## if parameters (cancer type as minimum) have been passed in the URL, record which studies were shortlisted
        # if(!is.null(urlValues$CancerType)) {
        #       ## get timestamp
        #       datetime <- Sys.time()
        #       ## get cancer type passed in url
        #       urlCancerType <- urlValues$CancerType
        #       ## get alterations (if any) passed in url
        #       urlAlterations <- NA
        #       if(!is.null(urlValues$alterations)) {
        #         urlAlterations <- urlValues$alterations
        #         }
        # 
        #       ## create a separate table that will be written to database
        #       shortlistTable <- table 
        #       ## capture date and time downloaded
        #       shortlistTable$datetime <- datetime
        #       ## capture the cancer type passed in url
        #       shortlistTable$urlCancerType <- urlCancerType
        #       ## capture the alterations (if any) that have been passed in url
        #       shortlistTable$urlAlterations <- urlAlterations
        #       ## in addition, save a copy of the full set of results obtained
        #       ## left join, i.e. keep matches on cancer type alone
        #       ## if scored_matches is empty, will just get empty columns
        #       fullTable <- merge(x=reactiveCancerStudies(), by.x=c("nct_id"), all.x=TRUE, 
        #                    y=reactivescored_matches(), by.y=c("nct_id"))  
        #       ## aggregate interventions column
        #       fullTable <- fullTable %>%
        #           group_by(across(c(-interventions))) %>%
        #           summarise("interventions" = paste(na.omit(unique(interventions)), collapse = ", ")) %>%
        #           as.data.frame()
        #       
        #       fullTable$datetime <- datetime
        #       fullTable$urlCancerType <- urlCancerType
        #       fullTable$urlAlterations <- urlAlterations
        #       ## append to dedicated table in database (if table doesn't exist, it is created)
        #       con2 <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
        #       dbWriteTable(conn = con2,name = "shortlisted", value = shortlistTable, append=TRUE)
        #       dbWriteTable(conn = con2,name = "fullresults", value = fullTable, append=TRUE)
        #       dbDisconnect(con2)
        #       
        #       ## use existing database connection
        #       # dbWriteTable(conn = con,name = "shortlisted", value = shortlistTable, append=TRUE)
        #       # dbWriteTable(conn = con,name = "fullresults", value = fullTable, append=TRUE)
        # 
        # }
        

        table[is.na(table)] <- "-"
        ## table=rjson::toJSON(table)
        table = jsonlite::toJSON(table)

        
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       include_solid= input$solidTumourFilter, 
                       synonyms = synonymsLabel(), 
                       #genes=input$geneFilter,
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table,
                       ## pass configuration items
                       privacy_statement = configuration$privacy.statement,
                       contact_email = configuration$contact.email,
                       country = configuration$country,
                       about_us = configuration$about.us
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)


```

```{r disconnect from database}
DBI::dbDisconnect(sqlite_con) 


# message(print(paste0("disconnected from DB: ", Sys.time() - start_time)))

```


### About  
  
#### About us  

`r configuration$about.us`.    


We would be grateful for feedback as to utility of this tool – if you have any feedback, or you would like to know more detail about this tool, please contact `r configuration$contact.email`.  

#### What does this tool do?  
  
The digital ECMT cancer trial matching tool is intended to support clinicians in the matching of people with cancer to clinical trials based on their cancer type, genetic alterations and/or trial drug mechanism. This is an early version that could possibly change.  
  
  
Potential matching trials are ranked according to the following order:   
  
  
1.	Study is enrolling patients with specified genetic alterations, AND specified gene is targeted by a study drug.  

2.	Study is enrolling patients with specified genetic alterations, AND a study drug targets a gene immediately downstream.  

3.	Study is enrolling patients with specified genetic alterations.  

4.	Study drug targets gene of interest.  

5.	Study drug targets a gene immediately downstream of specified genetic alteration.  

6.	Match on cancer type alone.  
  
  
#### Data sources  
  
* Trial data are sourced exclusively from clinicaltrials.gov via the Clinical Trials Transformation Initiative (https://www.ctti-clinicaltrials.org/ ).   

* Data regarding mechanisms of trial interventions are sourced from the NCI Thesaurus: https://ncithesaurus.nci.nih.gov/ncitbrowser/  
  
* Drug-target information is sourced from ChEMBL and The IUPHAR/BPS Guide to PHARMACOLOGY (citations below):  
  * A. Gaulton, L. Bellis, J. Chambers, M. Davies, A. Hersey, Y. Light, S. McGlinchey, R. Akhtar, A.P. Bento, B. Al-Lazikani, D. Michalovich, & J.P. Overington (2012) *‘ChEMBL: A Large-scale Bioactivity Database For Chemical Biology and Drug Discovery’* Nucleic Acids Res. Database Issue, 40 D1100-1107. DOI:10.1093/nar/gkr777 PMID:21948594  
  * A.P. Bento, A. Gaulton, A. Hersey, L.J. Bellis, J. Chambers, M. Davies, F.A. Krüger, Y. Light, L. Mak, S. McGlinchey, M. Nowotka, G. Papadatos, R. Santos & J.P. Overington (2014) *‘The ChEMBL bioactivity database: an update’* Nucleic Acids Res. Database Issue, 42 1083-1090. DOI:10.1093/nar/gkt103 PMID: 24214965  
  * Harding SD, Armstrong JF, Faccenda E, Southan C, Alexander SPH, Davenport AP, Pawson AJ, Spedding M, Davies JA; NC-IUPHAR. (2021) *The IUPHAR/BPS guide to PHARMACOLOGY in 2022: curating pharmacology for COVID-19, malaria and antibacterials.* Nucl. Acids Res. 2022. 50(D1) D1282-D1294. doi: 10.1093/nar/gkab1010. [Full text]. PMID: 34718737.  
  
  
* Data regarding biological pathways are sourced from KEGG (https://www.kegg.jp/kegg/) using the R BioConductor package: https://www.bioconductor.org/  
  
* Contains Ordnance Survey data © Crown copyright and database right 2021  
  
* Contains Royal Mail data © Royal Mail copyright and database right 2021  
  
* Source: Office for National Statistics licensed under the Open Government Licence v.3.0  
  
#### Limitations  
  
* **Please note that it is not a comprehensive source of information about clinical trials, and its utility not been validated for use in clinical decision making.**  

* Trials that are not included in clinicaltrials.gov will not be included in the search.  
  
  
* Only studies with at least one site in `r configuration$country` are included. If you are interested in hosting a site for other countries, please contact `r configuration$contact.email`.  
  

* Data are refreshed daily, but clinicians are advised to contact the relevant investigators to confirm recruitment status.  

* Study eligibility criteria are tagged with the relevant genetic alterations based on natural language processing – some criteria may be incorrectly tagged, and some relevant criteria may be missed.  
  
  
### Legal  
  
  
    
* The University of Manchester digital ECMT team’s cancer trial matching tool includes content intended for use only by healthcare professionals. This tool does not give professional advice; physicians and other healthcare professionals who use this tool should exercise their own clinical judgment as to the information it provides. Individuals with any type of medical condition are specifically cautioned to seek professional medical advice before beginning any sort of health treatment. For medical concerns, including decisions about medications and other treatments, non-medical users should always consult their physician or other qualified healthcare professional.  


*	We do not give medical advice, nor do we provide medical or diagnostic services. Medical information changes rapidly. Neither we nor our content providers guarantee that the content of this tool covers all possible uses, directions, precautions, drug interactions, or adverse effects that may be associated with any therapeutic treatments.  

*	In the absence of any negligence or other breach of duty by us: (1) your reliance upon information and content obtained by you at or through this site is solely at your own risk; and (2) neither we nor our content providers are responsible for any damage or injury (including death) to you, other persons, or property arising from any use of any product, information, idea, or instruction in the content of the tool.  
  
#### Privacy  
  
`r configuration$privacy.statement`.  
 
  
  

```{r exit script }


knitr::knit_exit()
```
 
  
