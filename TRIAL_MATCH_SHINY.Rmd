---
title: "digital ECMT cancer trial matching tool"
output: 
  flexdashboard::flex_dashboard:
    #source_code: embed
    orientation: rows
    logo: digitalECMTlogo48px.PNG
    theme: spacelab
    # includes:
    #    in_header: JS/matomo.js
runtime: shiny

---
```{r setup, include=FALSE}
require(flexdashboard)
require(dplyr)
require(tidyr)
require(kableExtra)
require(shinyWidgets)
require(leaflet)
require(htmltools)
require(rjson)
require(RSQLite)
require(DT)

#require(DT)


## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
```
  
```{r connect to SQLite DB}
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

```

  
```{r read cancer study data into memory}
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")



## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
# [1] "interventions"      "locations"          "postcode"          
#  [4] "nct_id"             "brief_title"        "overall_status"    
#  [7] "condition"          "site_name"          "site_status"       
# [10] "investigators"      "contacts"           "Refresh.date"      
# [13] "matching.condition" "TARGET.condition"   "Link"              
# [16] "postcode.lat"       "postcode.long"      "lat"               
# [19] "long"               "ParentTerm"  
# no columns are aggregated

## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")

## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))

## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")

## read conditions and synonyms into memory
# conditionSynonyms <- read.csv(file="conditionSynonyms4.csv", header = TRUE, stringsAsFactors = FALSE)
```

```{r get a full set of all study locations}
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
```


```{r aggregate cancerStudies into compact form}
## aggregating interventions was causing some study:intervention combinations to be missed out
cancerStudies <- cancerStudies %>%
       group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts, lat, long, Refresh.date))) %>%
       summarize(locations = toString(sort(unique(na.omit(locations)))),
                 sites = toString(sort(unique(na.omit(site_name)))),
                 conditions = toString(sort(unique(na.omit(condition)))),
                 investigators = toString(sort(unique(na.omit(investigators)))),
                 contacts = toString(sort(unique(na.omit(contacts))))) %>%
       as.data.frame()
```

```{r get prior tx exclusions}
## read indexed eligibilities table into memory
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")

## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")

## filter for prior therapy
excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")

## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))

## aggregate into single row per study
excludedTX <- excludedTX %>%
       group_by(nct_id) %>%
       summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
       as.data.frame()

## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")

```

```{r read studies scored on match against genes of interest}
## read cancerStudies table into memory
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")

## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest

## column names are
# [1] "symbol"                 "variant_type"           "nct_id"                
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [7] "combined_score"

```



Inputs {.sidebar}
-----------------------------------------------------------------------

**Filter studies on cancer type**    

```{r define a reactive value that will hold parameters from url}
## define a reactive value that will hold cancer type from URL, if any
urlValues <- reactiveValues()

```

```{r parse cancer type from URL}

#urlCancerType <- reactive({
observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['cancerType']])) {
        urlValues$CancerType <- query[['cancerType']]
        #updateTextInput(session, "cancerType", value = urlValues$CancerType)
      } 
})
```

```{r display cancer type dropdown}
available.cancer.types <- sort(unique(cancerStudies$TARGET.condition))

output$reactiveCancerFilter <- renderUI({
  ## multiple = TRUE allows user to start typing 
  selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = urlValues$CancerType, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
  
})
# display filter
shiny::renderUI({
   uiOutput("reactiveCancerFilter")
})

## can test when running locally by manually changing URL to e.g. http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast

```

```{r static cancer type filter}
## display filter for cancer type
# selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = NULL, multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL)
```

```{r include matches on solid tumour}

checkboxInput(inputId="solidTumourFilter", label="Include matches on solid tumour?", value = TRUE, width = NULL)


```

```{r define a reactive value that will hold selected cancer type}
selectedCancerTypes <- reactive({
  if(input$solidTumourFilter==FALSE) {cancer.types <- input$cancerTypeFilter}
  else {cancer.types <- c(input$cancerTypeFilter, "Solid")}
  ## return value
  cancer.types
})

```

```{r define reactive cancerStudies table}
reactiveCancerStudies <- reactive({
   cancer.types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)
   ## return table
   return(unique(table))
})
```
 



**Rank matching studies based on genetic alterations**    

```{r parse alterations from URL}
observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['alterations']])) {
        urlValues$alterations <- query[['alterations']]
        urlValues$alterations <- urlValues$alterations
        #updateTextInput(session, "alterations", value = urlValues$alterations)
      } 
})


## can test when running locally by manually changing URL to e.g. 
##  http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2 amplification
## or http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation

```

```{r define reactive value to hold alterations from url}
## if alterations have been passed as URL arguments, get values, else set to NULL
urlAlterations <- reactive({
    if(!is.null(urlValues$alterations)) {
    alterations <- unlist(strsplit(urlValues$alterations, split=","))
    } else alterations = NULL
  ## return value
  return(alterations)
})


```

```{r display gene filter}
## having reactive list of alterations means only those with matching studies are shown, but if toggle solid tumour on/off, the UI reacts and selected values are reset to the url arguments...

## define how filter values will be populated
output$reactiveGeneFilter <- renderUI({
   ## uncomment to enable reactive gene filter
   # cancer.types <- selectedCancerTypes()
   # table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types) 
   # table <- merge(x=table, by.x="nct_id", y=scoredMatches, by.y = "nct_id")
   # gene_variant_type.list <- sort(unique(table$gene_variant_type))
   
   gene_variant_type.list <- sort(unique(scoredMatches$gene_variant_type))
   
   selectInput(inputId = "geneFilter", label=NULL, choices = gene_variant_type.list, selected = urlAlterations(), multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)

})

# display filter
shiny::renderUI({
   uiOutput("reactiveGeneFilter") 
})
```

```{r define reactive value to hold selected alterations}

# if url values passed, these are stored
# however, if url values are added/deleted from geneFilter, this reactive value is updated accordingly
selectedAlterations <- reactive({
  
  if(!is.null(urlAlterations()) & is.null(input$geneFilter)) {
    alterations <-urlAlterations()
  } else if(!is.null(input$geneFilter)) {
    alterations <- input$geneFilter
  } else {alterations <- NULL}
  
  ## return value
  return(alterations)
})

```
(Use Entrez symbol, e.g. ERBB2 instead of HER2)  


**Filter matching studies on study drug mechanisms**    

```{r define reactive mechanism filter}
## dropdown should display all mechanisms available for selected cancer type, regardless of which alterations have been selected
## if matches on solid tumour have been excluded, mechanisms for those matches should not be displayed


## define how filter values will be populated
output$reactive.mechanism.filter <- renderUI({
   cancer.types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)   
   mechanism.list <- sort(unique(table$Mechanism))

   selectInput(inputId = "mechanismFilter", label=NULL, choices = mechanism.list, selected = NULL, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
})

# display filter
shiny::renderUI({
   uiOutput("reactive.mechanism.filter") 
})
```

```{r display cancer type alone filter}
checkboxInput(inputId="confidenceFilter", label="Hide matches on cancer type alone?", value = FALSE, width = NULL)
```
      
```{r download button}

# display button
# shiny::renderUI({
#    downloadButton("report", "Download table") 
# })

```

```{r filter scoredMatches table}
reactiveScoredMatches <- reactive({
   table <- scoredMatches
   table <- dplyr::filter(table, gene_variant_type %in% selectedAlterations())
   ## return table
   return(unique(table))
})
```
 
```{r create reactive merged table}

mergedStudyTable <-  reactive({
  ## get cancerStudies filtered on cancer type 
  cancerstudies <- reactiveCancerStudies()
  ## get scoredMatches filtered on alterations
  scoredmatches <- reactiveScoredMatches()
  ## left join, i.e. keep matches on cancer type alone
  ## if scoredMatches is empty, will just get empty columns
  table <- merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE, 
                     y=scoredmatches, by.y=c("nct_id"))

   ## if combined_score is NA, set value to zero
   table$combined_score[is.na(table$combined_score)] <- 0
   ## if a mechanism has been selected, filter table
   if(!is.null(input$mechanismFilter)) {
     tryCatch({
       table <- dplyr::filter(table, Mechanism %in% input$mechanismFilter)
       table$intervention_rationale <- paste0( "Match on selected mechanism (", table$interventions, "; ", table$Mechanism, ")")
       ## set confidence score so these matches are retained even if excluding matches on cancer type alone
       table$combined_score <- 1
       },error=function(cond) {return(NA)})
   }
   ## if excluding matches on cancer type alone, filter table
   if(input$confidenceFilter==TRUE) {table <- filter(table, combined_score >0)}
   ## return table
   return(unique(table))
})
  
```

  
Row {.tabset}
-----------------------------------------------------------------------

### Map view of sites

```{r print a map with study sites indicated}

## zoomed based on lat and long values in configuration file
## NOTE: layerIds must be unique (i.e. one study would only appear once)
## need to use combination of study ID and location to make layerIds unique
output$studiesmap <- renderLeaflet({
   studies <- unique(dplyr::select(mergedStudyTable(), nct_id, brief_title))
   locations <- merge(x=studies,by.x="nct_id", y=cancer.study.locations, by.y="nct_id")
   locations$uniqueId <- paste(locations$nct_id, locations$lat, locations$long, sep = "_")
   if(nrow(locations)>0) {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6) %>%
         addMarkers(data=locations, 
                    lat = ~lat,
                 lng = ~long,
                 popup = ~brief_title,
                 layerId = ~uniqueId, 
                 clusterOptions = markerClusterOptions())
  } else {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6)
  }
})

## render reactive map
shiny::renderUI({
   leafletOutput("studiesmap")
   
})

## create a reactive variable that will hold ID of a study selected on map
map.selection <- reactiveValues(id = NA)

## detect clicks on markers and use them to get study ID for marker that was clicked
observeEvent(input$studiesmap_marker_click, { 
   map.selection$id <- input$studiesmap_marker_click$id
   map.selection$id <- gsub(pattern = "_.*", replacement = "", x=map.selection$id)
  })

## detect click on map and use them to reset value of map.selection
observeEvent(input$studiesmap_click, {
   map.selection$id <- NA
  })
```
  
  

### Study details  


```{r render reactive kable}

# ## render as kable
# shiny::renderUI({
#    table <- mergedStudyTable()
#    table[is.na(table)] <- "-"
#    if(!is.na(map.selection$id )) {
#       table <- dplyr::filter(table, nct_id == map.selection$id )
#    }
#    if(nrow(table)>0) {
#    HTML(table %>%
#             mutate(brief_title = cell_spec(x=table$brief_title,format="html", link = table$Link, new_tab = TRUE )) %>%
#             dplyr::select(-c(Link, TARGET.condition, conditions)) %>%
#             mutate(locations = cell_spec(x=table$locations,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#           mutate(sites = cell_spec(x=table$sites,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(investigators = cell_spec(x=table$investigators,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(contacts = cell_spec(x=table$contacts,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(criteria = cell_spec(x=table$matching_criteria,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#           aggregate( by=table['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
#           #arrange( desc(combined_score)) %>% ## sort on score desc
#           #as.data.frame() %>%
#           dplyr::select(combined_score, 
#                         "Matching cancer type(s)" = "matching.condition",
#                          "Matching alteration(s)" = "gene_variant_type",
#                          "Drug rationale" = "intervention_rationale",
#                          "Eligibility" = "eligibility_rationale",
#                          "Brief title" = "brief_title",
#                         # "Matching inclusion criteria" = "criteria",
#                         # "Prior Therapy exclusions" = Exclusions,
#                          "Locations" = "locations",
#                         # "Centres" = "sites",
#                         # "Investigators" = "investigators",
#                          "Contacts" = "contacts",
#                         # "Study ID" = nct_id
#                          #"Overall status" = "overall_status"
#    #                      "Interventions" = "interventions",
#    #                      Mechanism
#                          ) %>%
#             arrange( desc(combined_score)) %>% ## sort on score desc
#             dplyr::select(-combined_score) %>%
#             unique() %>%
#             kable("html", escape = FALSE) %>%
#             # kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
#             kable_styling(bootstrap_options = c("hover", "condensed", "responsive")) %>%
#             #collapse_rows(columns = c(1,2,4,5), valign = "middle") %>%
#             #row_spec(row=3, hline_after = TRUE) %>%
#             kable_styling(fixed_thead = T))
# 
#    } else print("No matching studies fround")
# })
```

```{r define function to add buttons to table}
buttonInput <- function(FUNCTION, length, id, ...) {
    ## create an empty character vector of specified length
    inputs <- character(length)
    ## loop through vector
    for (i in seq_len(length)) {
      ## call the specified function with id and i as arguments
      inputs[i] <- as.character(FUNCTION(paste0(id, i), ...))
    }
    return(inputs)
  }

```




```{r render reactive datatable catch error for empty}

## render as datatable

formattedTable <- reactive({
  table <- mergedStudyTable()
   validate(
            need(nrow(table)>0, "No matching studies based on selected options")
        )
   table[is.na(table)] <- "-"
   if(!is.na(map.selection$id )) {
      table <- dplyr::filter(table, nct_id == map.selection$id )
   }
        table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
        table$ID <- table$nct_id
        table <- aggregate(table, by=table['nct_id'], function(x) {paste(unique(x), collapse = ";\n")})
        table <- unique(dplyr::select(table, 
                            combined_score, 
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                          # "Matching inclusion criteria" = "criteria",
                          # "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                          # "Centres" = "sites",
                          # "Investigators" = "investigators",
                            "Contacts" = "contacts",
                          ID
                          # "StudyID" = nct_id
                          #"Overall status" = "overall_status"
   #                      "Interventions" = "interventions",
   #                      Mechanism
                               ))
        table <- arrange(table, desc(combined_score))
        table <- dplyr::select(table, -combined_score)
        
        
        ## action buttons in column of table
        # table$Action = buttonInput(
        #         FUNCTION = actionButton,
        #         length = nrow(table),
        #         id = 'button_',
        #         label = "Add to shortlist",
        #         class = "btn-primary",
        #         onclick = 'Shiny.onInputChange(\"lastClick\",  this.id)'
        #       )
        
        return(table)
})



output$datatable <- DT::renderDT(formattedTable(), escape = 5, options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE))



```

```{r observe button clicks in results table}
## for example, see https://community.rstudio.com/t/add-a-button-into-a-row-in-a-datatable/18651/2 

# printText <- reactiveValues(id = '')
# 
# observeEvent(input$lastClick, {
#     selectedRow <- as.numeric(strsplit(input$lastClick, "_")[[1]][2])
#     table <- formattedTable()
#     printText$id <<- paste('clicked on ',table$ID[selectedRow,1])
#   })
# 
# 
# 
# output$printMsg <- renderText({
#     printText$id
#   })
```



```{r layout results table with download button}

fillCol(height = 600, flex = c(NA, 1), 
        #shiny::renderPrint('printMsg'), 
        #DT::DTOutput("datatable"), 
        inputPanel(shiny::renderUI({downloadButton("report", "Download table", class = "btn-primary")})),
        DT::DTOutput("datatable") 
        )
```

```{r download handler for full results}
## see also https://shiny.rstudio.com/articles/generating-reports.html 


output$report <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        #file.copy("trial_report.Rmd", overwrite = TRUE)
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)

        table=mergedStudyTable()
        
        ## filter and retain only studies on the shortlist
        # shortlist = shortlist()
        # table <- dplyr::filter(table, nct_id %in% shortlist$ID)

          if(!is.na(map.selection$id )) {
            table <- dplyr::filter(table, nct_id == map.selection$id )
         }
        
        table[is.na(table)] <- "-"
        table=toJSON(table)
        
       
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       include_solid= input$solidTumourFilter, 
                       genes=input$geneFilter,
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)





```

  
  
### Selected studies (`r renderText(countSelectedRows())`)



```{r create an empty shortlist}

## define function
createEmptyShortlist <- function() {
  ## get column names from a merge of cancerStudies and scoredMatches
  #shortlistNames <- unique(c(names(cancerStudies), names(scoredMatches)))
  
  ## get column names from formattedTable
  shortlistNames <- names(formattedTable())
  
  ## create empty dataframe
  shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=list(NULL, shortlistNames)))
  
  ## return empty shortlist
  return(shortlist)
}

## call the function to create empty shortlist
#shortlist <-createEmptyShortlist()

```

  
```{r define reactive shortlist}

shortlist <- reactive({
  table <- formattedTable()
  indices <- input$datatable_rows_selected
  table <- table[indices, ]
  return(table)
  
  ## create an empty shortlist and actions will add rows
  #shortlist <-createEmptyShortlist()


  
  # filter and retain only studies on the shortlist
  # shortlist = shortlist()
  # table <- dplyr::filter(table, nct_id %in% shortlist$ID)
  

  #shortlist <- unique(rbind(shortlist, table))
  #return(shortlist)
})

```

   
  
    
```{r detect selection of rows}
## see also https://yihui.shinyapps.io/DT-proxy/ 

proxy = dataTableProxy('datatable')

  observeEvent(input$select1, {
    proxy %>% selectRows(as.numeric(input$rows))
    
    ## add selected rows to shortlist
    # table <- formattedTable()
    # indices <- input$datatable_rows_selected
    # table <- table[indices, ]
    # 
    # shortlist() <- unique(rbind(shortlist(), table))
  })

  
  
output$info = renderPrint({
  input$datatable_rows_selected
  })



## define a reactive value that will hold number selected rows
countSelectedRows <- reactive({
  count <- length(input$datatable_rows_selected)
  ## return value
  count
})


```
 
 

  
  
```{r define shortlist output}
#verbatimTextOutput('info')
#renderPrint(length(input$datatable_rows_selected))


output$shortlistTable <- DT::renderDT(shortlist(), escape = 5, options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE))

```
   
```{r layout shortlist with download button}

fillCol(height = 600, flex = c(NA, 1), 
        #DT::DTOutput("shortlistTable"),
        inputPanel(
          shiny::renderUI({downloadButton("downloadShortlist", "Download selecetd studies", class = "btn-primary")})
          #actionButton(inputId="clearShortlist", "Clear shortlist", class = "btn-dark")
          ),
        DT::DTOutput("shortlistTable") 
        )

```
 
```{r download handler for shortlist}

output$downloadShortlist <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        #file.copy("trial_report.Rmd", overwrite = TRUE)
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)

        table=mergedStudyTable()
        
        ## filter and retain only studies on the shortlist
        shortlist = shortlist()
        table <- dplyr::filter(table, nct_id %in% shortlist$ID)
        

          if(!is.na(map.selection$id )) {
            table <- dplyr::filter(table, nct_id == map.selection$id )
         }
        
        table[is.na(table)] <- "-"
        table=toJSON(table)
        
       

        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       include_solid= input$solidTumourFilter, 
                       genes=input$geneFilter,
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)






```

     
<!-- ### URL parameters -->
  
```{r access parameters from URL}
# textInput("cancerType", "Cancer type", "no cancer type in URL")
# textInput("alterations", "Genetic alterations", "none specified in URL")
## see also https://stackoverflow.com/questions/32872222/how-do-you-pass-parameters-to-a-shiny-app-via-url


```


### Study ranking details  

  
* Studies are filtered on cancer type, plus/minus solid tumour.  
  
* If one or more drug mechanisms are selected, only studies that include one or more matching interventions are displayed.  
  
* If one or more genetic alterations are selected, only studies relevant for those alterations are displayed, matches are ranked based on:  

    * Study is enrolling patients with specified genetic alterations, and specified gene is targeted by a study drug.  

    * Study is enrolling patients with specified genetic alterations, and a study drug targets a gene immediately downstream.   
  
  
    * Study is enrolling patients with specified genetic alterations.   
  
  
    * Study drug targets gene of interest.  
  
  
    * Study drug targets a gene immediately downstream of specified genetic alteration.  
  
  

  
### Acknowledgements
  
`r configuration$about.us`  
   
   
`r configuration$privacy.statement`  

  
INTENDED USE: This tool is a prototype, intended for research use by Medical Professionals. Please note that it is not a comprehensive source of information about clinical trials, and is not for use in clinical decision making. If you have any questions, please contact `r configuration$contact.email` for more information.  
  
    
DATA SOURCES:  
  
  
* Trial data are sourced from clinicaltrials.gov via the Clinical Trials Transformation Initiative: https://www.ctti-clinicaltrials.org/  
  
* Data regarding mechanisms of trial interventions are sourced from the NCI Thesaurus: https://ncithesaurus.nci.nih.gov/ncitbrowser/  
  
* Data regarding biological pathways are sourced from KEGG (https://www.kegg.jp/kegg/) using the R BioConductor package: https://www.bioconductor.org/  
  
  
  

```{r disconnect from database}
dbDisconnect(con) 

```

  


```{r exit script }
knitr::knit_exit()
```
  
  

<!-- **Cancer types included in search:**   -->

```{r reactive label}
# synonymsLabel <- reactive({
#    synonyms <- paste(unique(conditionSynonyms$condition.synonyms[conditionSynonyms$controlled.cancer.type==input$cancerTypeFilter]), collapse = ", ")
#    synonyms
# })

## uncomment this line if you want to show synonyms included in matches for each cancer type
# shiny::renderText({
#    paste(synonymsLabel(), collapse = "\n")
# })


```

    
  
  
  