---
title: "digital ECMT cancer trial matching tool"
output: 
  flexdashboard::flex_dashboard:
    #source_code: embed
    orientation: rows
    logo: digitalECMTlogo48px.PNG
    theme: spacelab
    # includes:
    #    in_header: JS/matomo.js
runtime: shiny

---
```{r setup, include=FALSE}
require(flexdashboard)
require(dplyr)
require(tidyr)
require(kableExtra)
require(shinyWidgets)
require(leaflet)
require(htmltools)
require(rjson)
require(RSQLite)
require(DT)
require(DBI)

## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
```
  
```{r connect to SQLite DB}
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

```

```{r read cancer study data into memory}
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")

## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)

## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
#  [1] "interventions"      "locations"          "postcode"           "nct_id"            
#  [5] "brief_title"        "overall_status"     "condition"          "site_name"         
#  [9] "site_status"        "investigators"      "contacts"           "central_contacts"  
# [13] "Refresh.date"       "matching.condition" "TARGET.condition"   "Link"              
# [17] "postcode.lat"       "postcode.long"      "lat"                "long"              
# [21] "ParentTerm" 
# no columns are aggregated

## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")

## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))

## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")

## read conditions and synonyms into memory
conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")
```

```{r get a full set of all study locations}
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
```

```{r aggregate cancerStudies into compact form}
## aggregating interventions was causing some study:intervention combinations to be missed out
cancerStudies <- cancerStudies %>%
       group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts,central_contacts, lat, long, Refresh.date))) %>%
       summarize(locations = toString(sort(unique(na.omit(locations)))),
                 sites = toString(sort(unique(na.omit(site_name)))),
                 conditions = toString(sort(unique(na.omit(condition)))),
                 investigators = toString(sort(unique(na.omit(investigators)))),
                 central_contacts = toString(sort(unique(na.omit(central_contacts)))),
                 contacts = toString(sort(unique(na.omit(contacts))))) %>%
       as.data.frame()
```

```{r get prior tx exclusions}
## read indexed eligibilities table into memory
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")

## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")

## filter for prior therapy
excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")

## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))

## aggregate into single row per study
excludedTX <- excludedTX %>%
       group_by(nct_id) %>%
       summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
       as.data.frame()

## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")

```

```{r read studies scored on match against genes of interest}
## read cancerStudies table into memory
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")

## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest

## column names are
# [1] "symbol"                 "variant_type"           "nct_id"                
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [7] "combined_score"

```

# (data refreshed `r refresh.date`)  

Inputs {.sidebar}
-----------------------------------------------------------------------

**Filter studies on cancer type**    

```{r define a reactive value that will hold parameters from url}
## define a reactive value that will hold cancer type from URL, if any
urlValues <- reactiveValues()

```

```{r parse cancer type from URL}
observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['cancerType']])) {
        urlValues$CancerType <- query[['cancerType']]
      } 
})
```

```{r display cancer type dropdown}
available.cancer.types <- sort(unique(cancerStudies$TARGET.condition))

output$reactiveCancerFilter <- renderUI({
  ## multiple = TRUE allows user to start typing 
  selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = urlValues$CancerType, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
  
})
# display filter
shiny::renderUI({
   uiOutput("reactiveCancerFilter")
})

## can test when running locally by manually changing URL to e.g. http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast

```

```{r include matches on solid tumour}

checkboxInput(inputId="solidTumourFilter", label="Include matches on solid tumour?", value = TRUE, width = NULL)


```

```{r define a reactive value that will hold selected cancer type}

## if solid tumours selected, solid is added as an additional cancer type
selectedCancerTypes <- reactive({
  if(input$solidTumourFilter==FALSE) {cancer.types <- input$cancerTypeFilter}
  else {cancer.types <- c(input$cancerTypeFilter, "Solid")}
  
  ## print to console to aid development... 
  #print(paste0("selectedCancerTypes value: ", cancer.types))
  
  ## return value
  cancer.types
})

```

```{r define reactive cancerStudies table}
reactiveCancerStudies <- reactive({
   cancer.types <- selectedCancerTypes()

   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)
   ## print to console to aid development... 
   #print(paste0("head of reactiveCancerStudies1: ", head(table)))
   
   ## append central contacts to front of site contact
   table$contacts <- paste(na.omit(table$central_contacts), na.omit(table$contacts))
   ## return table
   return(unique(table))
})

## names of reactiveCancerStudies are
#  [1] "nct_id"             "interventions"      "brief_title"        "overall_status"    
#  [5] "matching.condition" "TARGET.condition"   "Link"               "Mechanism"         
#  [9] "locations"          "sites"              "conditions"         "investigators"     
# [13] "central_contacts"   "contacts"           "Exclusions"

```
 
```{r define reactive synonymsLabel to hold cancer type synonyms}
## this value will be passed to downloaded report as a record of synonyms included in search
synonymsLabel <- reactive({
   synonyms <- paste(unique(conditionSynonyms$condition.synonyms[conditionSynonyms$controlled.cancer.type==input$cancerTypeFilter]), collapse = ", ")
   synonyms
})


```

**Rank matching studies based on genetic alterations**    

```{r parse alterations from URL}
## try this on command line
# parseQueryString("http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation")

observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['alterations']])) {
        # get alterations from url
        alterations <- query[['alterations']]
        
        urlValues$alterations <- alterations
      } 
})

```

```{r define reactive value to hold alterations from url}
## if alterations have been passed as URL arguments, get values, else set to NULL
urlAlterations <- reactive({
    if(!is.null(urlValues$alterations)) {
    alterations <- unlist(strsplit(urlValues$alterations, split=","))
    
    ## strip out surplus argument details
    # for mutations
    alterations <- gsub(pattern = "SV .*", replacement = "mutation", x=alterations, ignore.case = TRUE)
    # for rearrangements
    alterations <- gsub(pattern = "rearrangement .*", replacement = "rearrangement", x=alterations, ignore.case = TRUE)
    # for CNA amplification
    alterations <- gsub(pattern = "CNA .*amplification", replacement = "amplification", x=alterations, ignore.case = TRUE)
    # for CNA loss
    alterations <- gsub(pattern = " CNA ", replacement = " ", x=alterations, ignore.case = TRUE)
    # drop repeated alterations
    alterations <- unique(alterations)
    
    } else alterations = NULL
    
    
    ## return value
  return(alterations)
})

## test eTARGET integration with the following URL
# http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2 CNA amplification,EGFR CNA partial_amplification,PTEN CNA loss,ABL1 rearrangement duplication,ABL1 rearrangement duplication,KRAS SV c.34G>T p.(G12C),ERBB2 amplification,EP300 rearrangement duplication,EP300 rearrangement duplication 
```

```{r display gene filter}
## having reactive list of alterations means only those with matching studies are shown, but if toggle solid tumour on/off, the UI reacts and selected values are reset to the url arguments...

## define how filter values will be populated
output$reactiveGeneFilter <- renderUI({
   ## uncomment to enable reactive gene filter
   # cancer.types <- selectedCancerTypes()
   # table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types) 
   # table <- merge(x=table, by.x="nct_id", y=scoredMatches, by.y = "nct_id")
   # gene_variant_type.list <- sort(unique(table$gene_variant_type))
   
   gene_variant_type.list <- sort(unique(scoredMatches$gene_variant_type))
   
   selectInput(inputId = "geneFilter", label=NULL, choices = gene_variant_type.list, selected = intersect(urlAlterations(),gene_variant_type.list), multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
   
})

# display filter
shiny::renderUI({
   uiOutput("reactiveGeneFilter") 
})
```

```{r define reactive value to hold selected alterations}

# if url values passed, these are stored
# however, if url values are added/deleted from geneFilter, this reactive value is updated accordingly
selectedAlterations <- reactive({
  ## just return value of input$geneFilter
  ## if URL alterations have been passed, these will be preselected in the filter
  ## if nothing is selected, NULL is returned
  alterations <- input$geneFilter
  
  ## print to console to aid development... 
  #print(paste0("selectedAlterations value: ", alterations))
  
  ## return value
  return(alterations)
})

```
(Use Entrez symbol, e.g. ERBB2 instead of HER2)  


**Filter matching studies on study drug mechanisms**    

```{r define reactive mechanism filter}
## dropdown should display all mechanisms available for selected cancer type, regardless of which alterations have been selected
## if matches on solid tumour have been excluded, mechanisms for those matches should not be displayed

## define how filter values will be populated
output$reactive.mechanism.filter <- renderUI({
   cancer.types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)   
   mechanism.list <- sort(unique(table$Mechanism))

   selectInput(inputId = "mechanismFilter", label=NULL, choices = mechanism.list, selected = NULL, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
})

# display filter
shiny::renderUI({
   uiOutput("reactive.mechanism.filter") 
})
```

```{r display cancer type alone filter}
checkboxInput(inputId="confidenceFilter", label="Hide matches on cancer type alone?", value = FALSE, width = NULL)
```

```{r filter scoredMatches table}
reactiveScoredMatches <- reactive({
   table <- scoredMatches

   ## filter based on selectedAlterations
   ## if null, a table with no rows is returned
   ## if selectedAlterations not in gene_variant_type, get a table with header but no rows
   table <- dplyr::filter(table, gene_variant_type %in% selectedAlterations())
   
   ## return table
   return(unique(table))
})


## names of reactiveScoredMatches are
# [1] "symbol"                 "variant_type"           "gene_variant_type"     
# [4] "nct_id"                 "intervention_rationale" "eligibility_rationale" 
# [7] "matching_criteria"      "combined_score"   

```
 
```{r define reactive mergedStudyTable}

mergedStudyTable <-  reactive({
  ## get cancerStudies filtered on cancer type 
  cancerstudies <- reactiveCancerStudies()
  ## get scoredMatches filtered on alterations
  scoredmatches <- reactiveScoredMatches()
  ## left join, i.e. keep matches on cancer type alone
  ## if scoredMatches is empty, will just get empty columns
  table <- merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE, 
                     y=scoredmatches, by.y=c("nct_id"))
  ## display error message if table is empty 
  validate(
            need(nrow(table)>0, "No results based on selections")
        )
  
   ## if combined_score is NA, set value to zero
   table$combined_score[is.na(table$combined_score)] <- 0
   ## if a mechanism has been selected, filter table
   if(!is.null(input$mechanismFilter)) {
     tryCatch({
       table <- dplyr::filter(table, Mechanism %in% input$mechanismFilter)
       table$intervention_rationale <- paste0( "Match on selected mechanism (", table$interventions, "; ", table$Mechanism, ")")
       ## set confidence score so these matches are retained even if excluding matches on cancer type alone
       table$combined_score <- 1
       },error=function(cond) {return(NA)})
   }
   ## if excluding matches on cancer type alone, filter table
   if(input$confidenceFilter==TRUE) {table <- filter(table, combined_score >0)}
   
  ## display error message if table is empty 
  validate(
            need(nrow(table)>0, "No results based on selections")
            #need(!is.null(table), "table is NULL")
        )
   
   ## add some html code to brief_title value with relevant link
   table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
   
   ## return table
   return(unique(table))
})


## names of mergedStudyTable are 
#  [1] "nct_id"                 "interventions"          "brief_title"           
#  [4] "overall_status"         "matching.condition"     "TARGET.condition"      
#  [7] "Link"                   "Mechanism"              "locations"             
# [10] "sites"                  "conditions"             "investigators"         
# [13] "central_contacts"       "contacts"               "Exclusions"            
# [16] "symbol"                 "variant_type"           "gene_variant_type"     
# [19] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [22] "combined_score"  
  

## mergedStudyTable is the master set of data, all info for all matching studies based on user selections
## locations and sites are aggregated

```

  
Row {.tabset}
-----------------------------------------------------------------------

### Map view of sites

```{r print a map with study sites indicated}

## zoomed based on lat and long values in configuration file
## NOTE: layerIds must be unique (i.e. one study would only appear once)
## need to use combination of study ID and location to make layerIds unique
output$studiesmap <- renderLeaflet({
   studies <- unique(dplyr::select(mergedStudyTable(), nct_id, brief_title))
   locations <- merge(x=studies,by.x="nct_id", y=cancer.study.locations, by.y="nct_id")
   locations$uniqueId <- paste(locations$nct_id, locations$lat, locations$long, sep = "_")
   if(nrow(locations)>0) {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6) %>%
         addMarkers(data=locations, 
                    lat = ~lat,
                 lng = ~long,
                 popup = ~brief_title,
                 layerId = ~uniqueId, 
                 clusterOptions = markerClusterOptions())
  } else {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6)
  }
})

## render reactive map
shiny::renderUI({
   leafletOutput("studiesmap")
   
})

## create a reactive variable that will hold ID of a study selected on map
map.selection <- reactiveValues(id = NA)

## detect clicks on markers and use them to get study ID for marker that was clicked
observeEvent(input$studiesmap_marker_click, { 
   map.selection$id <- input$studiesmap_marker_click$id
   map.selection$id <- gsub(pattern = "_.*", replacement = "", x=map.selection$id)
  })

## detect click on map and use them to reset value of map.selection
observeEvent(input$studiesmap_click, {
   map.selection$id <- NA
  })
```
  
### Study details  

```{r define reactive formattedTable catch error for empty}

## render as datatable
formattedTable <- reactive({
  table <- mergedStudyTable()
  ## display error message if table is empty 
  validate(
            need(nrow(table)>0, "No matching studies based on selected options")
        )
  ## if a study has been selected on map, just display that study
  if(!is.na(map.selection$id )) {
      table <- dplyr::filter(table, nct_id == map.selection$id )
   }
   
   table <- arrange(table, desc(combined_score)) 
   table <- aggregate(table, by=table['nct_id'], function(x) {paste(unique(na.omit(x)), collapse = ";\n")})
   
   ## aggregate leads to duplication of nct_id column, so create a duplicate column called StudyID, then drop the nct_id column... 
   table$StudyID <- table$nct_id
   ## now drop nct_id column
   table <- dplyr::select(table, -nct_id)
   ## now rename back to nct_id
   table <- rename(table, nct_id = StudyID)
   ## sort of ranking score descending
   table <- arrange(table, desc(combined_score))
   ## drop redundant rows, if any
   table <- unique(table)

   return(table)
})

## names of formattedTable are same as mergedStudyTable... 
#  [1] "nct_id"                 "interventions"          "brief_title"           
#  [4] "overall_status"         "matching.condition"     "TARGET.condition"      
#  [7] "Link"                   "Mechanism"              "locations"             
# [10] "sites"                  "conditions"             "investigators"         
# [13] "central_contacts"       "contacts"               "Exclusions"            
# [16] "symbol"                 "variant_type"           "gene_variant_type"     
# [19] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [22] "combined_score"  
## but formattedTable may be subsetted based on map clicks (without losing full set of data from mergedStudyTable)

```

```{r define output for main results table}

## increase width of brief title column to 500 pixels
output$datatable <- DT::renderDT(dplyr::select(formattedTable(),
                            # combined_score,
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                            # "Matching inclusion criteria" = "matching_criteria",
                            # "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                            # "Centres" = "sites",
                            # "Investigators" = "investigators",
                            # "Central contacts" = "central_contacts",
                            "Contacts" = "contacts"
                            # "StudyID" = nct_id,
                            # "Overall status" = "overall_status",
                            # "Interventions" = "interventions",
                            # Mechanism
                            ),
                  rownames=FALSE, escape = 4, 
                  options = list(ordering=F,
                                 paging = TRUE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 columnDefs = list(list(width = '500px', targets = list(4)))
                                )
 )


## UNUSED CODE FOR OTHER OPTIONS...

## add ellipsis to locations, lose ID and contacts columns
# output$datatable <- DT::renderDT(dplyr::select(formattedTable(), -c(ID,Contacts)), escape = 5, options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE, columnDefs = list(list(
#   targets = 6,
#   render = JS(
#     "function(data, type, row, meta) {",
#     "return type === 'display' && data.length > 6 ?",
#     "'<span title=\"' + data + '\">' + data.substr(0, 6) + '...</span>' : data;",
#     "}")
# ))), callback = JS('table.page(3).draw(false);'))



## no ellipsis, keep contacts
# output$datatable <- DT::renderDT(dplyr::select(formattedTable(), -ID), escape = 5, 
#                                  options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE) 
#                                  )

```

```{r layout results table with download and shortlist buttons}

fillCol(height = 600, flex = c(NA, 1), 
        #shiny::renderPrint('printMsg'), 
        #DT::DTOutput("datatable"), 
        inputPanel(shiny::renderUI({
          downloadButton("report", "Download table", class = "btn-primary")
          }), 
          shiny::renderUI({
          actionButton("addToShortlist", "Shortlist selected studies", class = "btn-primary")
          })
          ),
        DT::DTOutput("datatable") 
        )


```

```{r detect selection of rows}
## see also https://yihui.shinyapps.io/DT-proxy/ 

## NOTE: if datatable is sorted, row indices may not match those of formattedTable()

## detect clicks on results table
proxy = dataTableProxy('datatable')
observeEvent(input$select1, {
  selectRows(proxy = proxy, selected = as.numeric(input$rows))
  })

## define reactive value that will hold indices of selected rows
indicesSelectedRows <- reactive({
  return(input$datatable_rows_selected)
})

```

```{r download handler for full results}
## see also https://shiny.rstudio.com/articles/generating-reports.html 

output$report <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)

        table=mergedStudyTable()

          if(!is.na(map.selection$id )) {
            table <- dplyr::filter(table, nct_id == map.selection$id )
         }
        
        ## if parameters (cancer type as minimum) have been passed in the URL, record studies when full table is dowloaded
        if(!is.null(urlValues$CancerType)) {
        ## get timestamp
        datetime <- Sys.time()
        ## get cancer type passed in url
        urlCancerType <- urlValues$CancerType
        ## get alterations (if any) passed in url
        urlAlterations <- NA
        if(!is.null(urlValues$alterations)) {
          urlAlterations <- urlValues$alterations
        }
        
        ## create a separate table that will be written to database
        fullResultsTable <- table 
        ## capture date and time downloaded
        fullResultsTable$datetime <- datetime
        ## capture the cancer type passed in url
        fullResultsTable$urlCancerType <- urlCancerType
        ## capture the alterations (if any) that have been passed in url
        fullResultsTable$urlAlterations <- urlAlterations
        
        ## append to dedicated table in database (if table doesn't exist, it is created)
        con3 <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
        dbWriteTable(conn = con3,name = "allDownloaded", value = fullResultsTable, append=TRUE)
        dbDisconnect(con3)
        ## use existing connection to database
        # dbWriteTable(conn = con,name = "allDownloaded", value = fullResultsTable, append=TRUE)


        }
        
        table[is.na(table)] <- "-"
        table=toJSON(table)
        
       
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       synonyms = synonymsLabel(), 
                       include_solid= input$solidTumourFilter, 
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       #genes=input$geneFilter,
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)


```

  
  
### Shortlist (`r renderText(nrow(shortlist()))` studies)


```{r define reactive shortlist}
## based on https://stackoverflow.com/questions/52427281/add-and-delete-rows-of-dt-datatable-in-r-shiny

## create an empty shortlist...
## first, get names to match those of mergedStudyTable
shortlistNames <- names(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE, 
                     y=scoredMatches, by.y=c("nct_id")))

## next, create an empty dataframe with correct number of columns, no rows
shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0))
## next, assign the column names
names(shortlist) <- shortlistNames

## define as a reactive value
shortlist <- reactiveVal(shortlist)

## observe and act on clicks on addToShortlist button
observeEvent(input$addToShortlist, {
    ## add selected rows
    t = rbind(shortlist(), formattedTable()[indicesSelectedRows(), ])
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })

```




```{r define output for shortlist table}

output$shortlistTable <- DT::renderDT(unique(dplyr::select(shortlist(),
                            # combined_score,
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                            "Matching inclusion criteria" = "matching_criteria",
                            "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                            # "Centres" = "sites",
                            # "Investigators" = "investigators",
                            # "Central contacts" = "central_contacts",
                            "Contacts" = "contacts"
                            # "StudyID" = nct_id,
                            # "Overall status" = "overall_status",
                            # "Interventions" = "interventions",
                            # Mechanism
                            )),
                  rownames=FALSE, escape = 4, 
                  options = list(ordering=F,
                                 paging = TRUE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 columnDefs = list(list(width = '500px', targets = list(4)))
                                )
  )
```

 
```{r layout shortlist with download button}

fillCol(height = 600, flex = c(NA, 1), 
        inputPanel(
          shiny::renderUI({downloadButton("downloadShortlist", "Download shortlist", class = "btn-primary")}),
          actionButton(inputId="removeSelected", "Remove selected studies", class = "btn-primary"),
          actionButton(inputId="clearShortlist", "Clear shortlist", class = "btn-primary")
          ),
        DT::DTOutput("shortlistTable") 
        )

```
 
```{r detect clicks on remove selected}
## detect clicks on shortlist

proxy2 = dataTableProxy('shortlistTable')

observeEvent(input$select1, {
    proxy2 %>% selectRows(as.numeric(input$rows))
  })


## define reactive value that will hold indices of selected rows
indicesRowsToDelete <- reactive({
  return(input$shortlistTable_rows_selected)
})


observeEvent(input$removeSelected, {
    ## add selected rows
    t = shortlist()
    if(!is.null(indicesRowsToDelete())) {
      ## drop selected rows
      t = t[-indicesRowsToDelete(), ]
  
    }
    
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


## observe clicks on clearShortlist button
observeEvent(input$clearShortlist, {
    
    ## drop all rows
    t = shortlist()[0, ]
  
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


``` 

 
 
```{r download handler for shortlist}

output$downloadShortlist <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)
        ## pass the shortlist
        table <- shortlist()
        
        
        ## if parameters (cancer type as minimum) have been passed in the URL, record which studies were shortlisted
        if(!is.null(urlValues$CancerType)) {
              ## get timestamp
              datetime <- Sys.time()
              ## get cancer type passed in url
              urlCancerType <- urlValues$CancerType
              ## get alterations (if any) passed in url
              urlAlterations <- NA
              if(!is.null(urlValues$alterations)) {
                urlAlterations <- urlValues$alterations
                }
        
              ## create a separate table that will be written to database
              shortlistTable <- table 
              ## capture date and time downloaded
              shortlistTable$datetime <- datetime
              ## capture the cancer type passed in url
              shortlistTable$urlCancerType <- urlCancerType
              ## capture the alterations (if any) that have been passed in url
              shortlistTable$urlAlterations <- urlAlterations
        
        
              ## in addition, save a copy of the full set of results obtained
              ## left join, i.e. keep matches on cancer type alone
              ## if scoredMatches is empty, will just get empty columns
              fullTable <- merge(x=reactiveCancerStudies(), by.x=c("nct_id"), all.x=TRUE, 
                           y=reactiveScoredMatches(), by.y=c("nct_id"))  
              ## aggregate interventions column
              fullTable <- fullTable %>%
                  group_by(across(c(-interventions))) %>%
                  summarise("interventions" = paste(na.omit(unique(interventions)), collapse = ", ")) %>%
                  as.data.frame()
              
              fullTable$datetime <- datetime
              fullTable$urlCancerType <- urlCancerType
              fullTable$urlAlterations <- urlAlterations
        
        
        
              ## append to dedicated table in database (if table doesn't exist, it is created)
              con2 <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")
              dbWriteTable(conn = con2,name = "shortlisted", value = shortlistTable, append=TRUE)
              dbWriteTable(conn = con2,name = "fullresults", value = fullTable, append=TRUE)
              dbDisconnect(con2)
              
              ## use existing database connection
              # dbWriteTable(conn = con,name = "shortlisted", value = shortlistTable, append=TRUE)
              # dbWriteTable(conn = con,name = "fullresults", value = fullTable, append=TRUE)

        }
        

        table[is.na(table)] <- "-"
        table=toJSON(table)
        
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       include_solid= input$solidTumourFilter, 
                       synonyms = synonymsLabel(), 
                       #genes=input$geneFilter,
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)


```
  
  

```{r disconnect from database}
dbDisconnect(con) 

```

  

     

### About  
  
#### About us  

`r configuration$about.us`.    


We would be grateful for feedback as to utility of this tool – if you have any feedback, or you would like to know more detail about this tool, please contact `r configuration$contact.email`.  

#### What does this tool do?  
  
The digital ECMT cancer trial matching tool is intended to support clinicians in the matching of people with cancer to clinical trials based on their cancer type, genetic alterations and/or trial drug mechanism. This is an early version that could possibly change.  
  
  
Potential matching trials are ranked according to the following order:   
  
  
1.	Study is enrolling patients with specified genetic alterations, AND specified gene is targeted by a study drug.  

2.	Study is enrolling patients with specified genetic alterations, AND a study drug targets a gene immediately downstream.  

3.	Study is enrolling patients with specified genetic alterations.  

4.	Study drug targets gene of interest.  

5.	Study drug targets a gene immediately downstream of specified genetic alteration.  

6.	Match on cancer type alone.  
  
  
#### Data sources  
  
Trial data are sourced exclusively from clinicaltrials.gov via the Clinical Trials Transformation Initiative (https://www.ctti-clinicaltrials.org/ ).   

Data regarding mechanisms of trial interventions are sourced from the NCI Thesaurus: https://ncithesaurus.nci.nih.gov/ncitbrowser/  

Data regarding biological pathways are sourced from KEGG (https://www.kegg.jp/kegg/) using the R BioConductor package: https://www.bioconductor.org/  
  
#### Limitations  
  
**Please note that it is not a comprehensive source of information about clinical trials, and its utility not been validated for use in clinical decision making.**  

Trials that are not included in clinicaltrials.gov will not be included in the search.  
Only studies with at least one UK site are included. If you are interested in hosting a site for other countries, please contact paul.oregan@digitalecmt.org .  

Only sites that are listed as “Recruiting” are included in the search.  

Data are refreshed daily, but clinicians are advised to contact the relevant investigators to confirm recruitment status.  

Study eligibility criteria are tagged with the relevant genetic alterations based on natural language processing – some criteria may be incorrectly tagged, and some relevant criteria may be missed.  
  
  
### Legal  
  
  
    
* The University of Manchester digital ECMT team’s cancer trial matching tool includes content intended for use only by healthcare professionals. This tool does not give professional advice; physicians and other healthcare professionals who use this tool should exercise their own clinical judgment as to the information it provides. Individuals with any type of medical condition are specifically cautioned to seek professional medical advice before beginning any sort of health treatment. For medical concerns, including decisions about medications and other treatments, non-medical users should always consult their physician or other qualified healthcare professional.  


*	We do not give medical advice, nor do we provide medical or diagnostic services. Medical information changes rapidly. Neither we nor our content providers guarantee that the content of this tool covers all possible uses, directions, precautions, drug interactions, or adverse effects that may be associated with any therapeutic treatments.  

*	In the absence of any negligence or other breach of duty by us: (1) your reliance upon information and content obtained by you at or through this site is solely at your own risk; and (2) neither we nor our content providers are responsible for any damage or injury (including death) to you, other persons, or property arising from any use of any product, information, idea, or instruction in the content of the tool.  
  
#### Privacy  
  
`r configuration$privacy.statement`.  
 
  
  

```{r exit script }
knitr::knit_exit()
```
 
  
