---
title: "digital ECMT cancer trial matching tool"
output: 
  flexdashboard::flex_dashboard:
    #source_code: embed
    orientation: rows
    logo: digitalECMTlogo48px.PNG
    theme: spacelab
    # includes:
    #    in_header: JS/matomo.js
runtime: shiny

---
```{r setup, include=FALSE}
require(flexdashboard)
require(dplyr)
require(tidyr)
require(kableExtra)
require(shinyWidgets)
require(leaflet)
require(htmltools)
require(rjson)
require(RSQLite)
require(DT)

#require(DT)


## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
```
  
```{r connect to SQLite DB}
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

```

  
```{r read cancer study data into memory}
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")



## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
# [1] "interventions"      "locations"          "postcode"          
#  [4] "nct_id"             "brief_title"        "overall_status"    
#  [7] "condition"          "site_name"          "site_status"       
# [10] "investigators"      "contacts"           "Refresh.date"      
# [13] "matching.condition" "TARGET.condition"   "Link"              
# [16] "postcode.lat"       "postcode.long"      "lat"               
# [19] "long"               "ParentTerm"  
# no columns are aggregated

## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")

## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))

## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")

## read conditions and synonyms into memory
# conditionSynonyms <- read.csv(file="conditionSynonyms4.csv", header = TRUE, stringsAsFactors = FALSE)
```

```{r get a full set of all study locations}
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
```


```{r aggregate cancerStudies into compact form}
## aggregating interventions was causing some study:intervention combinations to be missed out
cancerStudies <- cancerStudies %>%
       group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts, lat, long, Refresh.date))) %>%
       summarize(locations = toString(sort(unique(na.omit(locations)))),
                 sites = toString(sort(unique(na.omit(site_name)))),
                 conditions = toString(sort(unique(na.omit(condition)))),
                 investigators = toString(sort(unique(na.omit(investigators)))),
                 contacts = toString(sort(unique(na.omit(contacts))))) %>%
       as.data.frame()
```

```{r get prior tx exclusions}
## read indexed eligibilities table into memory
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")

## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")

## filter for prior therapy
excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")

## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))

## aggregate into single row per study
excludedTX <- excludedTX %>%
       group_by(nct_id) %>%
       summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
       as.data.frame()

## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")

```

```{r read studies scored on match against genes of interest}
## read cancerStudies table into memory
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")

## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest

## column names are
# [1] "symbol"                 "variant_type"           "nct_id"                
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [7] "combined_score"

```

Inputs {.sidebar}
-----------------------------------------------------------------------
**FILTERS**  
  
  
**Filter studies on cancer type**    

```{r parse cancer type from URL}
## define a reactive value that will hold cancer type from URL, if any
urlValues <- reactiveValues()

#urlCancerType <- reactive({
observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['cancerType']])) {
        urlValues$CancerType <- query[['cancerType']]
        #updateTextInput(session, "cancerType", value = urlValues$CancerType)
      } 
})


output$reactiveCancerFilter <- renderUI({
   selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = urlValues$CancerType, multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL)
})
# display filter
shiny::renderUI({
   uiOutput("reactiveCancerFilter")
})

## can test when running locally by manually changing URL to e.g. http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast

```


```{r static cancer type filter}
## display filter for cancer type
available.cancer.types <- sort(unique(cancerStudies$TARGET.condition))
# selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = NULL, multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL)

## get cancer type from URL
# selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = urlCancerType, multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL)


checkboxInput(inputId="solidTumourFilter", label="Include matches on solid tumour?", value = TRUE, width = NULL)

## define a reactive value that will hold selected cancer type
selectedCancerTypes <- reactive({
  if(input$solidTumourFilter==FALSE) {cancer.types <- input$cancerTypeFilter}
  else {cancer.types <- c(input$cancerTypeFilter, "Solid")}
  ## return value
  cancer.types
})



```

```{r filter cancerStudies table}
reactiveCancerStudies <- reactive({
   # cancer.types <- c(input$cancerTypeFilter, "Solid") 
   # if(input$solidTumourFilter==FALSE) {cancer.types <- input$cancerTypeFilter}
   # else {cancer.types <- c(input$cancerTypeFilter, "Solid")}
   cancer.types <- selectedCancerTypes()
  
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)
   ## return table
   unique(table)
})
```
 



**Order studies based on genetic alterations**    
```{r parse alterations from URL}

observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['alterations']])) {
        urlValues$alterations <- query[['alterations']]
        urlValues$alterations <- urlValues$alterations
        #updateTextInput(session, "alterations", value = urlValues$alterations)
      } 
})


## can test when running locally by manually changing URL to e.g. 
##  http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2 amplification
## or http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation

```



```{r define reactive gene filter}
## if alterations have been passed as URL arguments, get values
urlAlterations <- reactive({
    if(!is.null(urlValues$alterations)) {
    alterations <- unlist(strsplit(urlValues$alterations, split=","))
    } else alterations = NULL
  ## return value
  alterations
})




## define how filter values will be populated
output$reactiveGeneFilter <- renderUI({
   cancer.types <- selectedCancerTypes()
   
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types) 
   table <- merge(x=table, by.x="nct_id", y=scoredMatches, by.y = "nct_id")
   gene_variant_type.list <- sort(unique(table$gene_variant_type))
   
   selectInput(inputId = "geneFilter", label=NULL, choices = gene_variant_type.list, selected = urlAlterations(), multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)

})

# display filter
shiny::renderUI({
   uiOutput("reactiveGeneFilter") 
})



## define a reactive value that will hold selected alterations
# if url values passed, these are stored
# however, if url values are deleted from geneFilter, this reactive value is updated accordingly
selectedAlterations <- reactive({
  
  if(!is.null(urlAlterations()) & is.null(input$geneFilter)) {
    alterations <-urlAlterations()
  } else if(!is.null(input$geneFilter)) {
    alterations <- input$geneFilter
  } else {alterations <- NULL}
  
  
  # if(!is.null(input$geneFilter)) {
  #   alterations <- input$geneFilter
  # } else {alterations <-urlAlterations()}
  
  
  #alterations <- input$geneFilter
  ## return value
  alterations
})

```
(Entrez symbols - e.g. for HER2, search on ERBB2)  


**Filter on study drug mechanisms**    


```{r define reactive mechanism filter}
## define how filter values will be populated
output$reactive.mechanism.filter <- renderUI({
   # if(input$solidTumourFilter==FALSE) {cancer.types <- input$cancerTypeFilter}
   # else {cancer.types <- c(input$cancerTypeFilter, "Solid")}
   cancer.types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)   
   mechanism.list <- sort(unique(table$Mechanism))

   selectInput(inputId = "mechanismFilter", label=NULL, choices = mechanism.list, selected = NULL, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
})
# display filter
shiny::renderUI({
   uiOutput("reactive.mechanism.filter") 
})
```

  
```{r omit cancer type alone}
checkboxInput(inputId="confidenceFilter", label="Hide matches on cancer type alone?", value = FALSE, width = NULL)
```
      

  
```{r download button}

# display filter
shiny::renderUI({
   downloadButton("report", "Download results") 
})

```

  
```{r print results to file}
## see also https://shiny.rstudio.com/articles/generating-reports.html 


output$report <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        #file.copy("trial_report.Rmd", overwrite = TRUE)
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)

        table=mergedStudyTable()
        
        ## filter and retain only studies on the shortlist
        shortlist = shortlist()
        table <- dplyr::filter(table, nct_id %in% shortlist$ID)
        
        ## pass the shortlist instead of full table
        #table = shortlist()
        # table <- formattedTable()
        # indices <- input$datatable_rows_selected
        # table <- table[indices, ]

          if(!is.na(map.selection$id )) {
            table <- dplyr::filter(table, nct_id == map.selection$id )
         }
        
        table[is.na(table)] <- "-"
        table=toJSON(table)
        
       

        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       include_solid= input$solidTumourFilter, 
                       genes=input$geneFilter,
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)





```





```{r filter scoredMatches table}
reactiveScoredMatches <- reactive({
   table <- scoredMatches
   table <- dplyr::filter(table, gene_variant_type %in% selectedAlterations())
   

   # if(!is.null(input$geneFilter)) {
   #    table <- dplyr::filter(table, gene_variant_type %in% input$geneFilter)
   # }
   
   
   ## return table
   unique(table)
})
```
 
```{r join reactiveCancerStudies and reactiveScoredMatches tables}

mergedStudyTable <-  reactive({
   table <- reactiveCancerStudies()
  if(!is.null(input$geneFilter)) {
     table <- merge(x=table, by.x=c("nct_id"), all.x=TRUE, 
                     y=reactiveScoredMatches(), by.y=c("nct_id"))
    } else {table[ , c("symbol", "variant_type", "intervention_rationale", "eligibility_rationale", "matching_criteria", "combined_score", "gene_variant_type")] <- NA}  ## add empty columns so can select and rename for display...
   
   ## if combined_score is NA, set value to zero
   table$combined_score[is.na(table$combined_score)] <- 0
   
   if(!is.null(input$mechanismFilter)) {
     tryCatch({
       table <- dplyr::filter(table, Mechanism %in% input$mechanismFilter)
       table$intervention_rationale <- paste0( "Match on selected mechanism (", table$interventions, "; ", table$Mechanism, ")")
       },error=function(cond) {return(NA)})
   }
   ## 
   if(input$confidenceFilter==TRUE) {table <- filter(table, combined_score >0)}
   
   
   ## return table
   unique(table)
  
})
  
  

   



```

  
Row {.tabset}
-----------------------------------------------------------------------

### Map view of sites

```{r print a map with study sites indicated}

## zoomed based on lat and long values in configuration file
## NOTE: layerIds must be unique (i.e. one study would only appear once)
## need to use combination of study ID and location to make layerIds unique
output$studiesmap <- renderLeaflet({
   studies <- unique(dplyr::select(mergedStudyTable(), nct_id, brief_title))
   locations <- merge(x=studies,by.x="nct_id", y=cancer.study.locations, by.y="nct_id")
   locations$uniqueId <- paste(locations$nct_id, locations$lat, locations$long, sep = "_")
   if(nrow(locations)>0) {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6) %>%
         addMarkers(data=locations, 
                    lat = ~lat,
                 lng = ~long,
                 popup = ~brief_title,
                 layerId = ~uniqueId, 
                 clusterOptions = markerClusterOptions())
  } else {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6)
  }
})

## render reactive map
shiny::renderUI({
   leafletOutput("studiesmap")
   
})

## create a reactive variable that will hold ID of a study selected on map
map.selection <- reactiveValues(id = NA)

## detect clicks on markers and use them to get study ID for marker that was clicked
observeEvent(input$studiesmap_marker_click, { 
   map.selection$id <- input$studiesmap_marker_click$id
   map.selection$id <- gsub(pattern = "_.*", replacement = "", x=map.selection$id)
  })

## detect click on map and use them to reset value of map.selection
observeEvent(input$studiesmap_click, {
   map.selection$id <- NA
  })
```
  
  

### Study details  

```{r render reactive kable}

# ## render as kable
# shiny::renderUI({
#    table <- mergedStudyTable()
#    table[is.na(table)] <- "-"
#    if(!is.na(map.selection$id )) {
#       table <- dplyr::filter(table, nct_id == map.selection$id )
#    }
#    if(nrow(table)>0) {
#    HTML(table %>%
#             mutate(brief_title = cell_spec(x=table$brief_title,format="html", link = table$Link, new_tab = TRUE )) %>%
#             dplyr::select(-c(Link, TARGET.condition, conditions)) %>%
#             mutate(locations = cell_spec(x=table$locations,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#           mutate(sites = cell_spec(x=table$sites,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(investigators = cell_spec(x=table$investigators,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(contacts = cell_spec(x=table$contacts,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(criteria = cell_spec(x=table$matching_criteria,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#           aggregate( by=table['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
#           #arrange( desc(combined_score)) %>% ## sort on score desc
#           #as.data.frame() %>%
#           dplyr::select(combined_score, 
#                         "Matching cancer type(s)" = "matching.condition",
#                          "Matching alteration(s)" = "gene_variant_type",
#                          "Drug rationale" = "intervention_rationale",
#                          "Eligibility" = "eligibility_rationale",
#                          "Brief title" = "brief_title",
#                         # "Matching inclusion criteria" = "criteria",
#                         # "Prior Therapy exclusions" = Exclusions,
#                          "Locations" = "locations",
#                         # "Centres" = "sites",
#                         # "Investigators" = "investigators",
#                          "Contacts" = "contacts",
#                         # "Study ID" = nct_id
#                          #"Overall status" = "overall_status"
#    #                      "Interventions" = "interventions",
#    #                      Mechanism
#                          ) %>%
#             arrange( desc(combined_score)) %>% ## sort on score desc
#             dplyr::select(-combined_score) %>%
#             unique() %>%
#             kable("html", escape = FALSE) %>%
#             # kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
#             kable_styling(bootstrap_options = c("hover", "condensed", "responsive")) %>%
#             #collapse_rows(columns = c(1,2,4,5), valign = "middle") %>%
#             #row_spec(row=3, hline_after = TRUE) %>%
#             kable_styling(fixed_thead = T))
# 
#    } else print("No matching studies fround")
# })
```


```{r render reactive datatable catch error for empty}

## render as datatable

formattedTable <- reactive({
  table <- mergedStudyTable()
   validate(
            need(nrow(table)>0, "No matching studies based on selected options")
        )
   table[is.na(table)] <- "-"
   if(!is.na(map.selection$id )) {
      table <- dplyr::filter(table, nct_id == map.selection$id )
   }
        table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
        table$ID <- table$nct_id
        table <- aggregate(table, by=table['nct_id'], function(x) {paste(unique(x), collapse = ";\n")})
        table <- unique(dplyr::select(table, 
                            combined_score, 
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                          # "Matching inclusion criteria" = "criteria",
                          # "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                          # "Centres" = "sites",
                          # "Investigators" = "investigators",
                            "Contacts" = "contacts",
                          ID
                          # "StudyID" = nct_id
                          #"Overall status" = "overall_status"
   #                      "Interventions" = "interventions",
   #                      Mechanism
                               ))
        table <- arrange(table, desc(combined_score))
        table <- dplyr::select(table, -combined_score)
        
        # table <- DT::datatable(table, escape = which(names(table) == "Brief title"), options = list(ordering=F))
        #table <- DT::datatable(table, escape = TRUE, options = list(ordering=F))

        
        return(table)
})

# output$datatable <- DT::renderDT(formattedTable(), escape = which(names(table) == "Brief title"), options = list(ordering=F))

output$datatable <- DT::renderDT(formattedTable(), escape = 5, options = list(ordering=F))


# display formatted table
DT::DTOutput("datatable") 

```
  
### Shortlisted studies (`r renderText(countSelectedRows())`)
  
    
```{r detect selection of rows}
## see also https://yihui.shinyapps.io/DT-proxy/ 

proxy = dataTableProxy('datatable')

  observeEvent(input$select1, {
    proxy %>% selectRows(as.numeric(input$rows))
  })

  
  
output$info = renderPrint({
  input$datatable_rows_selected
  })



## define a reactive value that will hold number selected rows
countSelectedRows <- reactive({
  count <- length(input$datatable_rows_selected)
  ## return value
  count
})


```
  
  
```{r show selected rows}
#verbatimTextOutput('info')
#renderPrint(length(input$datatable_rows_selected))

shortlist <- reactive({
  table <- formattedTable()
  indices <- input$datatable_rows_selected
  table <- table[indices, ]
  return(table)
})


#renderPrint()

# output$shortlistTable <- DT::renderDT(shortlist(), escape = which(names(table) == "Brief title"), options = list(ordering=F))

output$shortlistTable <- DT::renderDT(shortlist(), escape = 5, options = list(ordering=F))


# display formatted table
DT::DTOutput("shortlistTable") 
```
     
<!-- ### URL parameters -->
  
```{r access parameters from URL}
# textInput("cancerType", "Cancer type", "no cancer type in URL")
# textInput("alterations", "Genetic alterations", "none specified in URL")
## see also https://stackoverflow.com/questions/32872222/how-do-you-pass-parameters-to-a-shiny-app-via-url


```


### Study ranking details  

  
* Studies are filtered on cancer type, plus/minus solid tumour.  
  
* If one or more drug mechanisms are selected, only studies that include one or more matching interventions are displayed.  
  
* If one or more genetic alterations are selected, only studies relevant for those alterations are displayed, matches are ranked based on:  

    * Study is enrolling patients with specified genetic alterations, and specified gene is targeted by a study drug.  

    * Study is enrolling patients with specified genetic alterations, and a study drug targets a gene immediately downstream.   
  
  
    * Study is enrolling patients with specified genetic alterations.   
  
  
    * Study drug targets gene of interest.  
  
  
    * Study drug targets a gene immediately downstream of specified genetic alteration.  
  
  

  
### Acknowledgements
  
`r configuration$about.us`  
   
   
`r configuration$privacy.statement`  

  
INTENDED USE: This tool is a prototype, intended for research use by Medical Professionals. Please note that it is not a comprehensive source of information about clinical trials, and is not for use in clinical decision making. If you have any questions, please contact `r configuration$contact.email` for more information.  
  
    
DATA SOURCES:  
  
  
* Trial data are sourced from clinicaltrials.gov via the Clinical Trials Transformation Initiative: https://www.ctti-clinicaltrials.org/  
  
* Data regarding mechanisms of trial interventions are sourced from the NCI Thesaurus: https://ncithesaurus.nci.nih.gov/ncitbrowser/  
  
* Data regarding biological pathways are sourced from KEGG (https://www.kegg.jp/kegg/) using the R BioConductor package: https://www.bioconductor.org/  
  
  
  

```{r disconnect from database}
dbDisconnect(con) 

```

  


```{r exit script }
knitr::knit_exit()
```
  
  

<!-- **Cancer types included in search:**   -->

```{r reactive label}
# synonymsLabel <- reactive({
#    synonyms <- paste(unique(conditionSynonyms$condition.synonyms[conditionSynonyms$controlled.cancer.type==input$cancerTypeFilter]), collapse = ", ")
#    synonyms
# })

## uncomment this line if you want to show synonyms included in matches for each cancer type
# shiny::renderText({
#    paste(synonymsLabel(), collapse = "\n")
# })


```

    
  
  
  