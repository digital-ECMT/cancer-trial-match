---
title: "digital ECMT cancer trial matching tool"
output: 
  flexdashboard::flex_dashboard:
    #source_code: embed
    orientation: rows
    logo: digitalECMTlogo48px.PNG
    theme: spacelab
    # includes:
    #    in_header: JS/matomo.js
runtime: shiny

---
```{r setup, include=FALSE}
require(flexdashboard)
require(dplyr)
require(tidyr)
require(kableExtra)
require(shinyWidgets)
require(leaflet)
require(htmltools)
require(rjson)
require(RSQLite)
require(DT)

#require(DT)


## load configuration data from JSON file
configuration <- fromJSON(file = "trialMatchConfiguration.json")
```
  
```{r connect to SQLite DB}
# Create an RSQLite database
con <- dbConnect(RSQLite::SQLite(), "trialMatchData.sqlite")

```

  
```{r read cancer study data into memory}
## read cancerStudies table into memory
cancerStudies <- dbGetQuery(con, "SELECT * FROM cancerStudies")

## get refresh date
refresh.date <- unique(cancerStudies$Refresh.date)

## contains study details, mapped to a controlled set of cancer types in the "TARGET.condition"  column
## names are
# [1] "interventions"      "locations"          "postcode"          
#  [4] "nct_id"             "brief_title"        "overall_status"    
#  [7] "condition"          "site_name"          "site_status"       
# [10] "investigators"      "contacts"           "Refresh.date"      
# [13] "matching.condition" "TARGET.condition"   "Link"              
# [16] "postcode.lat"       "postcode.long"      "lat"               
# [19] "long"               "ParentTerm"  
# no columns are aggregated

## filter and retain only studies with overall status of "Recruiting"
cancerStudies <- dplyr::filter(cancerStudies, overall_status == "Recruiting")

## drop postcode.lat and postcode.long columns
cancerStudies <- unique(dplyr::select(cancerStudies, -c("postcode.lat", "postcode.long")))

## rename parentTerm column as "Mechanism"
cancerStudies <- rename(cancerStudies, "Mechanism"="ParentTerm")

## read conditions and synonyms into memory
conditionSynonyms <- dbGetQuery(con, "SELECT * FROM cancers")
```

```{r get a full set of all study locations}
cancer.study.locations <- unique(dplyr::select(cancerStudies, nct_id, lat, long))
## drop any rows with missing lat/long values
## NOTE THAT THIS MEANS THESE STUDIES WILL NOT BE DISPLAYED ON MAP
## (BUT WILL BE IN THE TABLE UNDERNEATH)
cancer.study.locations <- cancer.study.locations[complete.cases(cancer.study.locations), ]
```


```{r aggregate cancerStudies into compact form}
## aggregating interventions was causing some study:intervention combinations to be missed out
cancerStudies <- cancerStudies %>%
       group_by_at(vars(-c( locations, postcode, condition, site_name, site_status, investigators, contacts, lat, long, Refresh.date))) %>%
       summarize(locations = toString(sort(unique(na.omit(locations)))),
                 sites = toString(sort(unique(na.omit(site_name)))),
                 conditions = toString(sort(unique(na.omit(condition)))),
                 investigators = toString(sort(unique(na.omit(investigators)))),
                 contacts = toString(sort(unique(na.omit(contacts))))) %>%
       as.data.frame()
```

```{r get prior tx exclusions}
## read indexed eligibilities table into memory
indexedEligibility <- dbGetQuery(con, "SELECT * FROM indexedEligibility")

## filter for exclusions
excludedTX <- filter(indexedEligibility, criterion.type=="EXCLUSION")

## filter for prior therapy
excludedTX <- filter(excludedTX, feature=="PRIOR_THERAPY")

## drop unnecessary columns
excludedTX <- unique(dplyr::select(excludedTX, nct_id, "Exclusions"="criteria"))

## aggregate into single row per study
excludedTX <- excludedTX %>%
       group_by(nct_id) %>%
       summarize(Exclusions = paste(sort(unique(na.omit(Exclusions))), collapse="\n")) %>%
       as.data.frame()

## join to cancerStudies
cancerStudies <- merge(x=cancerStudies, by.x = "nct_id", all.x = TRUE, y=excludedTX, by.y="nct_id")

```

```{r read studies scored on match against genes of interest}
## read cancerStudies table into memory
scoredMatches <- dbGetQuery(con, "SELECT * FROM scoredMatches")

## scoredMatches contains all possible matches of studies, their interventions and inclusion criteria against all possible genes of interest

## column names are
# [1] "symbol"                 "variant_type"           "nct_id"                
# [4] "intervention_rationale" "eligibility_rationale"  "matching_criteria"     
# [7] "combined_score"

```

# (data refreshed `r refresh.date`)  

Inputs {.sidebar}
-----------------------------------------------------------------------

**Filter studies on cancer type**    

```{r define a reactive value that will hold parameters from url}
## define a reactive value that will hold cancer type from URL, if any
urlValues <- reactiveValues()

```

```{r parse cancer type from URL}

#urlCancerType <- reactive({
observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['cancerType']])) {
        urlValues$CancerType <- query[['cancerType']]
        #updateTextInput(session, "cancerType", value = urlValues$CancerType)
      } 
})
```

```{r display cancer type dropdown}
available.cancer.types <- sort(unique(cancerStudies$TARGET.condition))

output$reactiveCancerFilter <- renderUI({
  ## multiple = TRUE allows user to start typing 
  selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = urlValues$CancerType, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
  
})
# display filter
shiny::renderUI({
   uiOutput("reactiveCancerFilter")
})

## can test when running locally by manually changing URL to e.g. http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast

```

```{r static cancer type filter}
## display filter for cancer type
# selectInput(inputId = "cancerTypeFilter", label=NULL, choices = available.cancer.types, selected = NULL, multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL)
```

```{r include matches on solid tumour}

checkboxInput(inputId="solidTumourFilter", label="Include matches on solid tumour?", value = TRUE, width = NULL)


```

```{r define a reactive value that will hold selected cancer type}
selectedCancerTypes <- reactive({
  if(input$solidTumourFilter==FALSE) {cancer.types <- input$cancerTypeFilter}
  else {cancer.types <- c(input$cancerTypeFilter, "Solid")}
  ## return value
  cancer.types
})

```

```{r define reactive cancerStudies table}
reactiveCancerStudies <- reactive({
   cancer.types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)
   ## return table
   return(unique(table))
})

## names of reactiveCancerStudies are
# [1] "nct_id"             "interventions"      "brief_title"        "overall_status"    
#  [5] "matching.condition" "TARGET.condition"   "Link"               "Mechanism"         
#  [9] "locations"          "sites"              "conditions"         "investigators"     
# [13] "contacts"           "Exclusions"        


```
 
```{r define reactive synonymsLabel to hold cancer type synonyms}

synonymsLabel <- reactive({
   synonyms <- paste(unique(conditionSynonyms$condition.synonyms[conditionSynonyms$controlled.cancer.type==input$cancerTypeFilter]), collapse = ", ")
   synonyms
})


```



**Rank matching studies based on genetic alterations**    

```{r parse alterations from URL}
## try this on command line
# parseQueryString("http://127.0.0.1:5793/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2%20amplification,KRAS%20mutation")



observe({
      query <- parseQueryString(session$clientData$url_search)
      if (!is.null(query[['alterations']])) {
        # urlValues$alterations <- query[['alterations']]
        # urlValues$alterations <- urlValues$alterations
        
        # get alterations from url
        alterations <- query[['alterations']]
        
        
        urlValues$alterations <- alterations
        #updateTextInput(session, "alterations", value = urlValues$alterations)
      } 
})





```

```{r define reactive value to hold alterations from url}
## if alterations have been passed as URL arguments, get values, else set to NULL
urlAlterations <- reactive({
    if(!is.null(urlValues$alterations)) {
    alterations <- unlist(strsplit(urlValues$alterations, split=","))
    
    ## strip out surplus argument details
    # for mutations
    alterations <- gsub(pattern = "SV .*", replacement = "mutation", x=alterations, ignore.case = TRUE)
    # for rearrangements
    alterations <- gsub(pattern = "rearrangement .*", replacement = "rearrangement", x=alterations, ignore.case = TRUE)
    # for CNA amplification
    alterations <- gsub(pattern = "CNA .*amplification", replacement = "amplification", x=alterations, ignore.case = TRUE)
    # for CNA loss
    alterations <- gsub(pattern = " CNA ", replacement = " ", x=alterations, ignore.case = TRUE)
    # drop repeated alterations
    alterations <- unique(alterations)
    
    ## if a variant is passed that is not in scoredMatches table, set to NULL
    if(!(alterations %in% scoredMatches$gene_variant_type)) {
      alterations <- NULL
    }
    
    
    } else alterations = NULL
    
    
    ## return value
  return(alterations)
})

## test eTARGET integration with the following URL
# http://127.0.0.1:7712/TRIAL_MATCH_SHINY.Rmd?cancerType=Breast&alterations=ERBB2 CNA amplification,EGFR CNA partial_amplification,PTEN CNA loss,ABL1 rearrangement duplication,ABL1 rearrangement duplication,KRAS SV c.34G>T p.(G12C),ERBB2 amplification,EP300 rearrangement duplication,EP300 rearrangement duplication 
```

```{r display gene filter}
## having reactive list of alterations means only those with matching studies are shown, but if toggle solid tumour on/off, the UI reacts and selected values are reset to the url arguments...

## define how filter values will be populated
output$reactiveGeneFilter <- renderUI({
   ## uncomment to enable reactive gene filter
   # cancer.types <- selectedCancerTypes()
   # table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types) 
   # table <- merge(x=table, by.x="nct_id", y=scoredMatches, by.y = "nct_id")
   # gene_variant_type.list <- sort(unique(table$gene_variant_type))
   
   gene_variant_type.list <- sort(unique(scoredMatches$gene_variant_type))
   
   selectInput(inputId = "geneFilter", label=NULL, choices = gene_variant_type.list, selected = urlAlterations(), multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)

})

# display filter
shiny::renderUI({
   uiOutput("reactiveGeneFilter") 
})
```

```{r define reactive value to hold selected alterations}

# if url values passed, these are stored
# however, if url values are added/deleted from geneFilter, this reactive value is updated accordingly
selectedAlterations <- reactive({
  
  if(!is.null(urlAlterations()) & is.null(input$geneFilter)) {
    alterations <- urlAlterations()
    ## reset urlAlterations value
    urlAlterations() <- NULL
    
   
    
    
  } else if(!is.null(input$geneFilter)) {
    alterations <- input$geneFilter
  } else {alterations <- NULL}
  

  
  
  ## return value
  return(alterations)
})

```
(Use Entrez symbol, e.g. ERBB2 instead of HER2)  


**Filter matching studies on study drug mechanisms**    

```{r define reactive mechanism filter}
## dropdown should display all mechanisms available for selected cancer type, regardless of which alterations have been selected
## if matches on solid tumour have been excluded, mechanisms for those matches should not be displayed


## define how filter values will be populated
output$reactive.mechanism.filter <- renderUI({
   cancer.types <- selectedCancerTypes()
   table <- dplyr::filter(cancerStudies, TARGET.condition %in% cancer.types)   
   mechanism.list <- sort(unique(table$Mechanism))

   selectInput(inputId = "mechanismFilter", label=NULL, choices = mechanism.list, selected = NULL, multiple = TRUE,  selectize = TRUE, width = NULL, size = NULL)
})

# display filter
shiny::renderUI({
   uiOutput("reactive.mechanism.filter") 
})
```

```{r display cancer type alone filter}
checkboxInput(inputId="confidenceFilter", label="Hide matches on cancer type alone?", value = FALSE, width = NULL)
```
      
```{r download button}

# display button
# shiny::renderUI({
#    downloadButton("report", "Download table") 
# })

```

```{r filter scoredMatches table}
reactiveScoredMatches <- reactive({
   table <- scoredMatches
   ## deal with edge case where exclude matches on cancer type alone but no alterations selected
#   if(!is.null(selectedAlterations())) {
     table <- dplyr::filter(table, gene_variant_type %in% selectedAlterations())
     # validate(
     #        need(nrow(table)>0, "selected variants not present")
     #        #need(!is.null(table), "table is NULL")
     #    )
     
   # } else {table <- scoredMatches[NULL, ]}
   
   
   
   ## return table
   return(unique(table))
})


## names of reactiveScoredMatches are
# [1] "symbol"                 "variant_type"           "gene_variant_type"     
# [4] "nct_id"                 "intervention_rationale" "eligibility_rationale" 
# [7] "matching_criteria"      "combined_score"   


## if selectedAlterations not in gene_variant_type, get a table with header but no rows
```
 
```{r define reactive mergedStudyTable}

mergedStudyTable <-  reactive({
  ## get cancerStudies filtered on cancer type 
  cancerstudies <- reactiveCancerStudies()
  ## get scoredMatches filtered on alterations
  scoredmatches <- reactiveScoredMatches()
  ## left join, i.e. keep matches on cancer type alone
  ## if scoredMatches is empty, will just get empty columns
  table <- merge(x=cancerstudies, by.x=c("nct_id"), all.x=TRUE, 
                     y=scoredmatches, by.y=c("nct_id"))

  # validate(
  #           need(nrow(table)>0, "No results based on selections")
  #           #need(!is.null(table), "table is NULL")
  #       )
  
   ## if combined_score is NA, set value to zero
   table$combined_score[is.na(table$combined_score)] <- 0
   ## if a mechanism has been selected, filter table
   if(!is.null(input$mechanismFilter)) {
     tryCatch({
       table <- dplyr::filter(table, Mechanism %in% input$mechanismFilter)
       table$intervention_rationale <- paste0( "Match on selected mechanism (", table$interventions, "; ", table$Mechanism, ")")
       ## set confidence score so these matches are retained even if excluding matches on cancer type alone
       table$combined_score <- 1
       },error=function(cond) {return(NA)})
   }
   ## if excluding matches on cancer type alone, filter table
   if(input$confidenceFilter==TRUE) {table <- filter(table, combined_score >0)}
   
   
  validate(
            need(nrow(table)>0, "No results based on selections")
            #need(!is.null(table), "table is NULL")
        )
   
   ## add some html code to brief_title value with relevant link
   table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
   
   
   
   ## return table
   return(unique(table))
})


## names of mergedStudyTable are 
# [1] "nct_id"                 "interventions"          "brief_title"           
#  [4] "overall_status"         "matching.condition"     "TARGET.condition"      
#  [7] "Link"                   "Mechanism"              "locations"             
# [10] "sites"                  "conditions"             "investigators"         
# [13] "contacts"               "Exclusions"             "symbol"                
# [16] "variant_type"           "gene_variant_type"      "intervention_rationale"
# [19] "eligibility_rationale"  "matching_criteria"      "combined_score"    
  

## mergedStudyTable is the master set of data, all info for all matching studies based on user selections
## locations and sites are aggregated

```

  
Row {.tabset}
-----------------------------------------------------------------------

### Map view of sites

```{r print a map with study sites indicated}

## zoomed based on lat and long values in configuration file
## NOTE: layerIds must be unique (i.e. one study would only appear once)
## need to use combination of study ID and location to make layerIds unique
output$studiesmap <- renderLeaflet({
   studies <- unique(dplyr::select(mergedStudyTable(), nct_id, brief_title))
   locations <- merge(x=studies,by.x="nct_id", y=cancer.study.locations, by.y="nct_id")
   locations$uniqueId <- paste(locations$nct_id, locations$lat, locations$long, sep = "_")
   if(nrow(locations)>0) {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6) %>%
         addMarkers(data=locations, 
                    lat = ~lat,
                 lng = ~long,
                 popup = ~brief_title,
                 layerId = ~uniqueId, 
                 clusterOptions = markerClusterOptions())
  } else {
     leaflet() %>%
         addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
         setView(lat = configuration$zoom.lat, lng = configuration$zoom.long, zoom = 6)
  }
})

## render reactive map
shiny::renderUI({
   leafletOutput("studiesmap")
   
})

## create a reactive variable that will hold ID of a study selected on map
map.selection <- reactiveValues(id = NA)

## detect clicks on markers and use them to get study ID for marker that was clicked
observeEvent(input$studiesmap_marker_click, { 
   map.selection$id <- input$studiesmap_marker_click$id
   map.selection$id <- gsub(pattern = "_.*", replacement = "", x=map.selection$id)
  })

## detect click on map and use them to reset value of map.selection
observeEvent(input$studiesmap_click, {
   map.selection$id <- NA
  })
```
  
### Study details  


```{r render reactive kable}

# ## render as kable
# shiny::renderUI({
#    table <- mergedStudyTable()
#    table[is.na(table)] <- "-"
#    if(!is.na(map.selection$id )) {
#       table <- dplyr::filter(table, nct_id == map.selection$id )
#    }
#    if(nrow(table)>0) {
#    HTML(table %>%
#             mutate(brief_title = cell_spec(x=table$brief_title,format="html", link = table$Link, new_tab = TRUE )) %>%
#             dplyr::select(-c(Link, TARGET.condition, conditions)) %>%
#             mutate(locations = cell_spec(x=table$locations,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#           mutate(sites = cell_spec(x=table$sites,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(investigators = cell_spec(x=table$investigators,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(contacts = cell_spec(x=table$contacts,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#            mutate(criteria = cell_spec(x=table$matching_criteria,format="html", extra_css = "display: -webkit-box;-webkit-line-clamp: 5; -webkit-box-orient: vertical;  overflow: auto;")) %>%
#           aggregate( by=table['nct_id'], function(x) {paste(unique(x), collapse = ";\n")}) %>%
#           #arrange( desc(combined_score)) %>% ## sort on score desc
#           #as.data.frame() %>%
#           dplyr::select(combined_score, 
#                         "Matching cancer type(s)" = "matching.condition",
#                          "Matching alteration(s)" = "gene_variant_type",
#                          "Drug rationale" = "intervention_rationale",
#                          "Eligibility" = "eligibility_rationale",
#                          "Brief title" = "brief_title",
#                         # "Matching inclusion criteria" = "criteria",
#                         # "Prior Therapy exclusions" = Exclusions,
#                          "Locations" = "locations",
#                         # "Centres" = "sites",
#                         # "Investigators" = "investigators",
#                          "Contacts" = "contacts",
#                         # "Study ID" = nct_id
#                          #"Overall status" = "overall_status"
#    #                      "Interventions" = "interventions",
#    #                      Mechanism
#                          ) %>%
#             arrange( desc(combined_score)) %>% ## sort on score desc
#             dplyr::select(-combined_score) %>%
#             unique() %>%
#             kable("html", escape = FALSE) %>%
#             # kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
#             kable_styling(bootstrap_options = c("hover", "condensed", "responsive")) %>%
#             #collapse_rows(columns = c(1,2,4,5), valign = "middle") %>%
#             #row_spec(row=3, hline_after = TRUE) %>%
#             kable_styling(fixed_thead = T))
# 
#    } else print("No matching studies fround")
# })
```

```{r define reactive formattedTable catch error for empty}

## render as datatable
formattedTable <- reactive({
  table <- mergedStudyTable()
  validate(
            need(nrow(table)>0, "No matching studies based on selected options")
        )
  
   # table[is.na(table)] <- "-"
   if(!is.na(map.selection$id )) {
      table <- dplyr::filter(table, nct_id == map.selection$id )
   }
        # table$brief_title <- paste0('<a href="',table$Link,'" target="_blank">',table$brief_title ,  " </a>")
        #table$ID <- table$nct_id
   table <- arrange(table, desc(combined_score)) 
   table <- aggregate(table, by=table['nct_id'], function(x) {paste(unique(na.omit(x)), collapse = ";\n")})
   #table[is.na(table)] <- "-"
   ## aggregate leads to duplication of nct_id column
   table$StudyID <- table$nct_id
   ##drop nct_id column
   table <- dplyr::select(table, -nct_id)
   ## now rename back to nct_id
   table <- rename(table, nct_id = StudyID)
        # table <- unique(dplyr::select(table,
        #                     combined_score,
        #                     "Matching cancer type(s)" = "matching.condition",
        #                     "Matching alteration(s)" = "gene_variant_type",
        #                     "Drug rationale" = "intervention_rationale",
        #                     "Eligibility" = "eligibility_rationale",
        #                     "Brief title" = "brief_title",
        #                     "Matching inclusion criteria" = "criteria",
        #                     "Prior Therapy exclusions" = Exclusions,
        #                     "Locations" = "locations",
        #                     "Centres" = "sites",
        #                     "Investigators" = "investigators",
        #                     "Contacts" = "contacts",
        #                     "StudyID" = nct_id,
        #                     "Overall status" = "overall_status",
        #                     "Interventions" = "interventions",
        #                     Mechanism
        #                   
        #                        ))
   table <- arrange(table, desc(combined_score))
   table <- unique(table)

   return(table)
})

## names of formattedTable are same as mergedStudyTable... 
# [1] "nct_id"                 "interventions"          "brief_title"           
#  [4] "overall_status"         "matching.condition"     "TARGET.condition"      
#  [7] "Link"                   "Mechanism"              "locations"             
# [10] "sites"                  "conditions"             "investigators"         
# [13] "contacts"               "Exclusions"             "symbol"                
# [16] "variant_type"           "gene_variant_type"      "intervention_rationale"
# [19] "eligibility_rationale"  "matching_criteria"      "combined_score" 
## but formattedTable may be subsetted based on map clicks (without losing full set of data from mergedStudyTable)

```





```{r define output for main results table}




## increase width of brief title column to 500 pixels
output$datatable <- DT::renderDT(dplyr::select(formattedTable(),
                            # combined_score,
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                            # "Matching inclusion criteria" = "matching_criteria",
                            # "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                            # "Centres" = "sites",
                            # "Investigators" = "investigators",
                            "Contacts" = "contacts"
                            # "StudyID" = nct_id,
                            # "Overall status" = "overall_status",
                            # "Interventions" = "interventions",
                            # Mechanism
                            ),
 # output$datatable <- DT::renderDT(formattedTable(),                           
                  rownames=FALSE, escape = 4, 
                  options = list(ordering=F,
                                 paging = TRUE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 #language = list(emptyTable = 'My Custom No Data Message'),
                                 columnDefs = list(list(width = '500px', targets = list(4)))
                                )
 )


## UNUSED CODE FOR OTHER OPTIONS...

## add ellipsis to locations, lose ID and contacts columns
# output$datatable <- DT::renderDT(dplyr::select(formattedTable(), -c(ID,Contacts)), escape = 5, options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE, columnDefs = list(list(
#   targets = 6,
#   render = JS(
#     "function(data, type, row, meta) {",
#     "return type === 'display' && data.length > 6 ?",
#     "'<span title=\"' + data + '\">' + data.substr(0, 6) + '...</span>' : data;",
#     "}")
# ))), callback = JS('table.page(3).draw(false);'))



## no ellipsis, keep contacts
# output$datatable <- DT::renderDT(dplyr::select(formattedTable(), -ID), escape = 5, 
#                                  options = list(ordering=F, paging = FALSE, scrollX = TRUE, scrollY = "450px", scrollCollapse = TRUE) 
#                                  )

```

```{r layout results table with download and shortlist buttons}

fillCol(height = 600, flex = c(NA, 1), 
        #shiny::renderPrint('printMsg'), 
        #DT::DTOutput("datatable"), 
        inputPanel(shiny::renderUI({
          downloadButton("report", "Download table", class = "btn-primary")
          }), 
          shiny::renderUI({
          actionButton("addToShortlist", "Shortlist selected studies", class = "btn-primary")
          })
          ),
        DT::DTOutput("datatable") 
        )


```

```{r detect selection of rows}
## see also https://yihui.shinyapps.io/DT-proxy/ 

# ## define a reactive value that will hold number selected rows
# countSelectedRows <- reactive({
#   count <- length(input$datatable_rows_selected)
#   ## return value
#   return(count)
# })




## NOTE: if datatable is sorted, row indices may not match those of formattedTable()

## define reactive value that will hold NCT IDs for studies selected from datatable
# create empty vector
#selectedStudyIDS <- character(0)
## define reactivity
# initialise as empty dataframe
#selectedStudyIDS <- reactiveVal(selectedStudyIDS)
## detect clicks on results table
proxy = dataTableProxy('datatable')
observeEvent(input$select1, {
   # proxy %>% selectRows(as.numeric(input$rows))
  
  selectRows(proxy = proxy, selected = as.numeric(input$rows))
  })

## define reactive value that will hold indices of selected rows
indicesSelectedRows <- reactive({
  return(input$datatable_rows_selected)
})



## update selectedStudyIDS based on selected rows
# selectedStudyIDS <- reactive({
#   indices <- input$datatable_rows_selected
#   ids <- unique(output$datatable$StudyID[indices])
#   return(ids)
# })



```

```{r download handler for full results}
## see also https://shiny.rstudio.com/articles/generating-reports.html 


output$report <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        #file.copy("trial_report.Rmd", overwrite = TRUE)
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)

        table=mergedStudyTable()
        
        
        
        ## filter and retain only studies on the shortlist
        # shortlist = shortlist()
        # table <- dplyr::filter(table, nct_id %in% shortlist$ID)

          if(!is.na(map.selection$id )) {
            table <- dplyr::filter(table, nct_id == map.selection$id )
         }
        
        table[is.na(table)] <- "-"
        table=toJSON(table)
        
       
        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       synonyms = synonymsLabel(), 
                       include_solid= input$solidTumourFilter, 
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       #genes=input$geneFilter,
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)





```

  
  
### Shortlist (`r renderText(nrow(shortlist()))` studies)


```{r define reactive shortlist}
## based on https://stackoverflow.com/questions/52427281/add-and-delete-rows-of-dt-datatable-in-r-shiny

## NB USING INDICES OF SELECTED ROWS IN OUTPUT TABLE ONLY WORKS IF ROW ORDERING OF OUTPUT TABLE IS ALWAYS THE SAME AS THAT FOR FORMATTEDTABLE(), (i.e. ok as long as sorting out output table by user is disabled, and rendering of output table only involves renaming columns, not reordering rows)



## create an empty shortlist
# shortlistNames <- c("Matching cancer type(s)","Matching alteration(s)","Drug rationale","Eligibility","Brief title","Locations","Contacts","ID")
# # shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0, dimnames=list(NULL, shortlistNames)))

shortlistNames <- names(merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE, 
                     y=scoredMatches, by.y=c("nct_id")))


shortlist <- data.frame(matrix(ncol=length(shortlistNames),nrow=0))
names(shortlist) <- shortlistNames




## define reactivity
# initialise as empty dataframe
shortlist <- reactiveVal(shortlist)



## observe clicks on addToShortlist button
observeEvent(input$addToShortlist, {
    ## add selected rows
    t = rbind(shortlist(), formattedTable()[indicesSelectedRows(), ])
    #t = rbind(shortlist(), formattedTable()[nct_id %in% selectedStudyIDS(),] )
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })

```




```{r define output for shortlist table}




# output$shortlistTable <- DT::renderDT(shortlist(),
output$shortlistTable <- DT::renderDT(unique(dplyr::select(shortlist(),
                            # combined_score,
                            "Matching cancer type(s)" = "matching.condition",
                            "Matching alteration(s)" = "gene_variant_type",
                            "Drug rationale" = "intervention_rationale",
                            "Eligibility" = "eligibility_rationale",
                            "Brief title" = "brief_title",
                            # "Matching inclusion criteria" = "matching_criteria",
                            # "Prior Therapy exclusions" = Exclusions,
                            "Locations" = "locations",
                            # "Centres" = "sites",
                            # "Investigators" = "investigators",
                            "Contacts" = "contacts"
                            # "StudyID" = nct_id,
                            # "Overall status" = "overall_status",
                            # "Interventions" = "interventions",
                            # Mechanism
                            )),
                  rownames=FALSE, escape = 4, 
                  options = list(ordering=F,
                                 paging = TRUE,
                                 scrollX = TRUE,
                                 scrollY = "60vh",
                                 scrollCollapse = TRUE,
                                 autoWidth = TRUE,
                                 columnDefs = list(list(width = '500px', targets = list(4)))
                                )
  )
```
 
```{r define reactive value to hold selected study IDs}
# selectedStudyIDs <- reactive({
#   ids <- unique(formattedTable()$ID[indicesSelectedRows()])
#   
#   ## return value
#   return(ids)
# })

# namesMergedStudyTable <- reactive({
#   names <- names(mergedStudyTable())
#   return(names)
#   
# })


```

```{r define detailed reactive shortlist for download}

## create an empty shortlist
# detailedShortlistNames <- c("nct_id","interventions","locations","postcode","brief_title","overall_status","condition","site_name","site_status","investigators","contacts","Refresh.date","matching.condition","TARGET.condition","Link","postcode.lat","postcode.long","lat","long","ParentTerm","symbol","variant_type","gene_variant_type","intervention_rationale","eligibility_rationale","matching_criteria","combined_score")


# detailedShortlistNames <- names( merge(x=cancerStudies, by.x=c("nct_id"), all.x=TRUE,
#                      y=scoredMatches, by.y=c("nct_id")))
# # 
# detailedShortlist <- data.frame(matrix(ncol=length(detailedShortlistNames),nrow=0, dimnames=list(NULL, detailedShortlistNames)))
# 
# ## define reactivity
# # initialise as empty dataframe
# detailedShortlist <- reactiveVal(detailedShortlist)
# #detailedShortlist <- reactiveVal(mergedStudyTable()[0,])



## observe clicks on addToShortlist button
# observeEvent(input$addToShortlist, {
#     ## add corresponding rows from mergedStudyTable
#     # get IDs for selected studies
#     ids <- unique(formattedTable()[indicesSelectedRows(),])
#     ids <- dplyr::select(unique(ids, ID))
# 
#     t = rbind(detailedShortlist(), filter(mergedStudyTable(), nct_id %in% ids) )
#     ## drop duplicated rows
#     t = unique(t)
#     # update shortlist with new value
#     detailedShortlist(t)
#   })







## define output
# output$detailedShortlistTable <- renderDT({
#    datatable(dplyr::select(detailedShortlist(), -ID), selection = 'single',rownames=FALSE, escape = 4, options = list(dom = 't', ordering=F,paging = FALSE,scrollX = TRUE,scrollY = "450px",scrollCollapse = TRUE,autoWidth = TRUE,columnDefs = list(list(width = '500px', targets = list(4))))
#              )
#   })

```
 
  
 
 
```{r layout shortlist with download button}

fillCol(height = 600, flex = c(NA, 1), 
        #DT::DTOutput("shortlistTable"),
        inputPanel(
          shiny::renderUI({downloadButton("downloadShortlist", "Download shortlist", class = "btn-primary")}),
          actionButton(inputId="removeSelected", "Remove selected studies", class = "btn-primary"),
          actionButton(inputId="clearShortlist", "Clear shortlist", class = "btn-primary")
          ),
        DT::DTOutput("shortlistTable") 
        # DT::DTOutput("shiny_table")
        )

```
 
```{r detect clicks on remove selected}
## detect clicks on shortlist

proxy2 = dataTableProxy('shortlistTable')

observeEvent(input$select1, {
    proxy2 %>% selectRows(as.numeric(input$rows))
  })


## define reactive value that will hold indices of selected rows
indicesRowsToDelete <- reactive({
  return(input$shortlistTable_rows_selected)
})

# ## define reactive value that will hold indices of selected rows
# indicesSelectedRows <- reactive({
#   return(input$datatable_rows_selected)
# })

observeEvent(input$removeSelected, {
    ## add selected rows
    #t = rbind(shortlist(), formattedTable()[indicesSelectedRows(),] )
    t = shortlist()
    if(!is.null(indicesRowsToDelete())) {
      ## drop selected rows
      t = t[-indicesRowsToDelete(), ]
  
    }
    ## drop selected rows
    # t = shortlist()[-indicesRowsToDelete(), ]
  
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


## observe clicks on clearShortlist button
observeEvent(input$clearShortlist, {
    ## add selected rows
    #t = rbind(shortlist(), formattedTable()[indicesSelectedRows(),] )
    
    ## drop selected rows
    t = shortlist()[0, ]
  
    ## drop duplicated rows
    t = unique(t)
    # update shortlist with new value
    shortlist(t)
  })


``` 

 
 
```{r download handler for shortlist}

output$downloadShortlist <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "trial_report.html",
      content = function(file) {
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which can happen when deployed).
        tempReport <- file.path(tempdir(), "trial_report.Rmd")
        file.copy("trial_report.Rmd", tempReport, overwrite = TRUE)
        
        # tempReport <- file.path(tempdir(), "trials_shortlist.Rmd")
        # file.copy("trials_shortlist.Rmd", tempReport, overwrite = TRUE)

        # table=mergedStudyTable()
        # ## filter and retain only studies on the shortlist
        # shortlist = shortlist()
        # table <- dplyr::filter(table, nct_id %in% shortlist$ID)
        
        ## note that some of the studies on shortlist may not be in mergedStudyTable 
        ## INSTEAD, USE shortlist() AND APPEND MISSING COLUMNS FROM cancerStudies (interventions, centres, investigators), indexed.eligibilities (prior therapy exclusions) and and scoredMatches (full inclusion criteria) tables
        ## MAY NEED TO RENAME AND/OR REORDER TO MAKE IT WORK WITH trial_report.Rmd
        #table <- detailedShortlist()
        table <- shortlist()
        

         #  if(!is.na(map.selection$id )) {
         #    table <- dplyr::filter(table, nct_id == map.selection$id )
         # }
        
        table[is.na(table)] <- "-"
        table=toJSON(table)
        
       

        # Set up parameters to pass to Rmd document
        params <- list(subject_ID="not provided", 
                       cancer_type= input$cancerTypeFilter,
                       include_solid= input$solidTumourFilter, 
                       synonyms = synonymsLabel(), 
                       #genes=input$geneFilter,
                       #genes = urlAlterations(),
                       genes = selectedAlterations(),
                       mechanism_filter=input$mechanismFilter, 
                       hide_cancer_only=input$confidenceFilter, 
                       #table=toJSON(read.csv("exampleTable.csv"))
                       table=table
                       )

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
       )
   }
)






```
  
  

```{r disconnect from database}
dbDisconnect(con) 

```

  

     

### About  
  
#### About us  

`r configuration$about.us`.    


We would be grateful for feedback as to utility of this tool – if you have any feedback, or you would like to know more detail about this tool, please contact `r configuration$contact.email`.  

#### What does this tool do?  
  
The digital ECMT cancer trial matching tool is intended to support clinicians in the matching of people with cancer to clinical trials based on their cancer type, genetic alterations and/or trial drug mechanism. This is an early version that could possibly change.  
  
  
Potential matching trials are ranked according to the following order:   
  
  
1.	Study is enrolling patients with specified genetic alterations, AND specified gene is targeted by a study drug.  

2.	Study is enrolling patients with specified genetic alterations, AND a study drug targets a gene immediately downstream.  

3.	Study is enrolling patients with specified genetic alterations.  

4.	Study drug targets gene of interest.  

5.	Study drug targets a gene immediately downstream of specified genetic alteration.  

6.	Match on cancer type alone.  
  
  
#### Data sources  
  
Trial data are sourced exclusively from clinicaltrials.gov via the Clinical Trials Transformation Initiative (https://www.ctti-clinicaltrials.org/ ).   

Data regarding mechanisms of trial interventions are sourced from the NCI Thesaurus: https://ncithesaurus.nci.nih.gov/ncitbrowser/  

Data regarding biological pathways are sourced from KEGG (https://www.kegg.jp/kegg/) using the R BioConductor package: https://www.bioconductor.org/  
  
#### Limitations  
  
**Please note that it is not a comprehensive source of information about clinical trials, and its utility not been validated for use in clinical decision making.**  

Trials that are not included in clinicaltrials.gov will not be included in the search.  
Only studies with at least one UK site are included. If you are interested in hosting a site for other countries, please contact paul.oregan@digitalecmt.org .  

Only sites that are listed as “Recruiting” are included in the search.  

Data are refreshed daily, but clinicians are advised to contact the relevant investigators to confirm recruitment status.  

Study eligibility criteria are tagged with the relevant genetic alterations based on natural language processing – some criteria may be incorrectly tagged, and some relevant criteria may be missed.  
  
  
### Legal  
  
  
    
* The digital ECMT cancer trial matching tool includes content intended for use by healthcare professionals. This tool does not give professional advice; physicians and other healthcare professionals who use this tool should exercise their own clinical judgment as to the information it provides. Individuals with any type of medical condition are specifically cautioned to seek professional medical advice before beginning any sort of health treatment. For medical concerns, including decisions about medications and other treatments, non-medical users should always consult their physician or other qualified healthcare professional.  


*	We do not give medical advice, nor do we provide medical or diagnostic services. Medical information changes rapidly. Neither we nor our content providers guarantee that the content covers all possible uses, directions, precautions, drug interactions, or adverse effects that may be associated with any therapeutic treatments.  

*	Your reliance upon information and content obtained by you at or through this site is solely at your own risk. Neither we nor our content providers assume any liability or responsibility for damage or injury (including death) to you, other persons, or property arising from any use of any product, information, idea, or instruction contained in the content or services provided to you.  
  
#### Privacy  
  
`r configuration$privacy.statement`.  
 
  
  

```{r exit script }
knitr::knit_exit()
```
 
  
  


  
    
### Study ranking details  

  
* Studies are filtered on cancer type, plus/minus solid tumour.  
  
* If one or more drug mechanisms are selected, only studies that include one or more matching interventions are displayed.  
  
* If one or more genetic alterations are selected, only studies relevant for those alterations are displayed, matches are ranked based on:  

    * Study is enrolling patients with specified genetic alterations, and specified gene is targeted by a study drug.  

    * Study is enrolling patients with specified genetic alterations, and a study drug targets a gene immediately downstream.   
  
  
    * Study is enrolling patients with specified genetic alterations.   
  
  
    * Study drug targets gene of interest.  
  
  
    * Study drug targets a gene immediately downstream of specified genetic alteration.  
  
  

  
### Acknowledgements
  
`r configuration$about.us`  
   
   
`r configuration$privacy.statement`  

  
INTENDED USE: This tool is a prototype, intended for research use by Medical Professionals. Please note that it is not a comprehensive source of information about clinical trials, and is not for use in clinical decision making. If you have any questions, please contact `r configuration$contact.email` for more information.  
  
    
DATA SOURCES:  
  
  
* Trial data are sourced from clinicaltrials.gov via the Clinical Trials Transformation Initiative: https://www.ctti-clinicaltrials.org/  
  
* Data regarding mechanisms of trial interventions are sourced from the NCI Thesaurus: https://ncithesaurus.nci.nih.gov/ncitbrowser/  
  
* Data regarding biological pathways are sourced from KEGG (https://www.kegg.jp/kegg/) using the R BioConductor package: https://www.bioconductor.org/  
  
  
  

  

<!-- **Cancer types included in search:**   -->

```{r reactive label}
# synonymsLabel <- reactive({
#    synonyms <- paste(unique(conditionSynonyms$condition.synonyms[conditionSynonyms$controlled.cancer.type==input$cancerTypeFilter]), collapse = ", ")
#    synonyms
# })

## uncomment this line if you want to show synonyms included in matches for each cancer type
# shiny::renderText({
#    paste(synonymsLabel(), collapse = "\n")
# })


```

    
  
  
  